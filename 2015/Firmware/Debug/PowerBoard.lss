
PowerBoard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00001390  00001424  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001390  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000a4  00800146  00800146  0000146a  2**0
                  ALLOC
  3 .comment      00000041  00000000  00000000  0000146a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000450  00000000  00000000  000014ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000084f4  00000000  00000000  000018fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001b67  00000000  00000000  00009def  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000017b8  00000000  00000000  0000b956  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000cc8  00000000  00000000  0000d110  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000242b  00000000  00000000  0000ddd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000048aa  00000000  00000000  00010203  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004b8  00000000  00000000  00014aad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
       0:	0c 94 23 01 	jmp	0x246	; 0x246 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
      1c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
      28:	0c 94 08 08 	jmp	0x1010	; 0x1010 <__vector_10>
      2c:	0c 94 d4 06 	jmp	0xda8	; 0xda8 <__vector_11>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
      30:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
      38:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
      40:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
      5c:	0c 94 b8 02 	jmp	0x570	; 0x570 <__vector_23>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
		#endif			
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      90:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      94:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      98:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      9c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>

000000ac <__trampolines_end>:
      ac:	07 06       	cpc	r0, r23
      ae:	05 04       	cpc	r0, r5
      b0:	01 00       	.word	0x0001	; ????
      b2:	08 0a       	sbc	r0, r24
      b4:	0b 0c       	add	r0, r11
      b6:	0d 09       	sbc	r16, r13

000000b8 <_cdcInterface>:
      b8:	08 0b 00 02 02 02 01 00 09 04 00 00 01 02 02 00     ................
      c8:	00 05 24 00 10 01 05 24 01 01 01 04 24 02 06 05     ..$....$....$...
      d8:	24 06 00 01 07 05 81 03 10 00 40 09 04 01 00 02     $.........@.....
      e8:	0a 00 00 00 07 05 02 02 40 00 00 07 05 83 02 40     ........@......@
	...

000000fa <_initEndpoints>:
      fa:	00 c1 80 81 c1                                      .....

000000ff <USB_DeviceDescriptorA>:
      ff:	12 01 00 02 02 00 00 40 41 23 36 80 00 01 01 02     .......@A#6.....
     10f:	00 01                                               ..

00000111 <USB_DeviceDescriptor>:
     111:	12 01 00 02 00 00 00 40 41 23 36 80 00 01 01 02     .......@A#6.....
     121:	00 01                                               ..

00000123 <STRING_MANUFACTURER>:
     123:	41 72 64 75 69 6e 6f 20 4c 4c 43 00                 Arduino LLC.

0000012f <STRING_PRODUCT>:
     12f:	41 72 64 75 69 6e 6f 20 4c 65 6f 6e 61 72 64 6f     Arduino Leonardo
	...

00000140 <STRING_LANGUAGE>:
     140:	04 03 09 04                                         ....

00000144 <_asciimap>:
	...
     14c:	2a 2b 28 00 00 00 00 00 00 00 00 00 00 00 00 00     *+(.............
	...
     164:	2c 9e b4 a0 a1 a2 a4 34 a6 a7 a5 ae 36 2d 37 38     ,......4....6-78
     174:	27 1e 1f 20 21 22 23 24 25 26 b3 33 b6 2e b7 b8     '.. !"#$%&.3....
     184:	9f 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92     ................
     194:	93 94 95 96 97 98 99 9a 9b 9c 9d 2f 31 30 a3 ad     .........../10..
     1a4:	35 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12     5...............
     1b4:	13 14 15 16 17 18 19 1a 1b 1c 1d af b1 b0 b5 00     ................

000001c4 <_hidInterface>:
     1c4:	09 04 02 00 01 03 00 00 00 09 21 01 01 00 01 22     ..........!...."
     1d4:	65 00 07 05 84 03 40 00 01                          e.....@..

000001dd <_hidReportDescriptor>:
     1dd:	05 01 09 02 a1 01 09 01 a1 00 85 01 05 09 19 01     ................
     1ed:	29 03 15 00 25 01 95 03 75 01 81 02 95 01 75 05     )...%...u.....u.
     1fd:	81 03 05 01 09 30 09 31 09 38 15 81 25 7f 75 08     .....0.1.8..%.u.
     20d:	95 03 81 06 c0 c0 05 01 09 06 a1 01 85 02 05 07     ................
     21d:	19 e0 29 e7 15 00 25 01 75 01 95 08 81 02 95 01     ..)...%.u.......
     22d:	75 08 81 03 95 06 75 08 15 00 25 65 05 07 19 00     u.....u...%e....
     23d:	29 65 81 00 c0                                      )e...

00000242 <__ctors_start>:
     242:	93 04       	cpc	r9, r3
     244:	b3 09       	sbc	r27, r3

00000246 <__ctors_end>:
     246:	11 24       	eor	r1, r1
     248:	1f be       	out	0x3f, r1	; 63
     24a:	cf ef       	ldi	r28, 0xFF	; 255
     24c:	da e0       	ldi	r29, 0x0A	; 10
     24e:	de bf       	out	0x3e, r29	; 62
     250:	cd bf       	out	0x3d, r28	; 61

00000252 <__do_copy_data>:
     252:	11 e0       	ldi	r17, 0x01	; 1
     254:	a0 e0       	ldi	r26, 0x00	; 0
     256:	b1 e0       	ldi	r27, 0x01	; 1
     258:	e0 e9       	ldi	r30, 0x90	; 144
     25a:	f3 e1       	ldi	r31, 0x13	; 19
     25c:	02 c0       	rjmp	.+4      	; 0x262 <__do_copy_data+0x10>
     25e:	05 90       	lpm	r0, Z+
     260:	0d 92       	st	X+, r0
     262:	a6 34       	cpi	r26, 0x46	; 70
     264:	b1 07       	cpc	r27, r17
     266:	d9 f7       	brne	.-10     	; 0x25e <__do_copy_data+0xc>

00000268 <__do_clear_bss>:
     268:	21 e0       	ldi	r18, 0x01	; 1
     26a:	a6 e4       	ldi	r26, 0x46	; 70
     26c:	b1 e0       	ldi	r27, 0x01	; 1
     26e:	01 c0       	rjmp	.+2      	; 0x272 <.do_clear_bss_start>

00000270 <.do_clear_bss_loop>:
     270:	1d 92       	st	X+, r1

00000272 <.do_clear_bss_start>:
     272:	aa 3e       	cpi	r26, 0xEA	; 234
     274:	b2 07       	cpc	r27, r18
     276:	e1 f7       	brne	.-8      	; 0x270 <.do_clear_bss_loop>

00000278 <__do_global_ctors>:
     278:	12 e0       	ldi	r17, 0x02	; 2
     27a:	c6 e4       	ldi	r28, 0x46	; 70
     27c:	d2 e0       	ldi	r29, 0x02	; 2
     27e:	04 c0       	rjmp	.+8      	; 0x288 <__do_global_ctors+0x10>
     280:	22 97       	sbiw	r28, 0x02	; 2
     282:	fe 01       	movw	r30, r28
     284:	0e 94 c2 09 	call	0x1384	; 0x1384 <__tablejump__>
     288:	c2 34       	cpi	r28, 0x42	; 66
     28a:	d1 07       	cpc	r29, r17
     28c:	c9 f7       	brne	.-14     	; 0x280 <__do_global_ctors+0x8>
     28e:	0e 94 5e 01 	call	0x2bc	; 0x2bc <main>
     292:	0c 94 c6 09 	jmp	0x138c	; 0x138c <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <initVariant>:
void loop();

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
     29a:	08 95       	ret

0000029c <setup>:

#define NUM_PORTS  4

void setup() 
{
	initializeMotorController();
     29c:	0e 94 76 01 	call	0x2ec	; 0x2ec <_Z25initializeMotorControllerv>
	turnOnAllMotors();
     2a0:	0e 94 3e 02 	call	0x47c	; 0x47c <_Z15turnOnAllMotorsv>
	DDRB |= 0b00000001;
     2a4:	20 9a       	sbi	0x04, 0	; 4
	PORTB |= 0b00000001;
     2a6:	28 9a       	sbi	0x05, 0	; 5
     2a8:	08 95       	ret

000002aa <loop>:
}

void loop()
{
	// put your main code here, to run repeatedly:
	readMotorCurrents();
     2aa:	0e 94 bc 01 	call	0x378	; 0x378 <_Z17readMotorCurrentsv>
	delay(100);
     2ae:	64 e6       	ldi	r22, 0x64	; 100
     2b0:	70 e0       	ldi	r23, 0x00	; 0
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	0e 94 25 03 	call	0x64a	; 0x64a <delay>
     2ba:	08 95       	ret

000002bc <main>:
void ErrorMessage(const char *file, const int lineNumber);

int main(void)
{
	// Start the platform
	init();
     2bc:	0e 94 4d 03 	call	0x69a	; 0x69a <init>
	initVariant();
     2c0:	0e 94 4d 01 	call	0x29a	; 0x29a <initVariant>
	USBDevice.attach();
     2c4:	84 ed       	ldi	r24, 0xD4	; 212
     2c6:	91 e0       	ldi	r25, 0x01	; 1
     2c8:	0e 94 5e 08 	call	0x10bc	; 0x10bc <_ZN10USBDevice_6attachEv>

	// Call setup
	setup();
     2cc:	0e 94 4e 01 	call	0x29c	; 0x29c <setup>
	
	while (1)
	{
		// Main loop function
		loop();
     2d0:	0e 94 55 01 	call	0x2aa	; 0x2aa <loop>
		
		// Check for USB serial events
		if (serialEventRun)
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	89 2b       	or	r24, r25
     2da:	29 f0       	breq	.+10     	; 0x2e6 <main+0x2a>
		{
			serialEventRun();
     2dc:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	setup();
	
	while (1)
	{
		// Main loop function
		loop();
     2e0:	0e 94 55 01 	call	0x2aa	; 0x2aa <loop>
     2e4:	fb cf       	rjmp	.-10     	; 0x2dc <main+0x20>
     2e6:	0e 94 55 01 	call	0x2aa	; 0x2aa <loop>
     2ea:	fd cf       	rjmp	.-6      	; 0x2e6 <main+0x2a>

000002ec <_Z25initializeMotorControllerv>:
int analogIntRead[NUM_MOTORS];
float motorVoltageValues[NUM_MOTORS];
uint8_t numOverCurrentReads[NUM_MOTORS];

void initializeMotorController()
{
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	40 91 77 01 	lds	r20, 0x0177
     2f4:	50 91 78 01 	lds	r21, 0x0178
     2f8:	60 91 79 01 	lds	r22, 0x0179
     2fc:	70 91 7a 01 	lds	r23, 0x017A
     300:	e9 e1       	ldi	r30, 0x19	; 25
     302:	f1 e0       	ldi	r31, 0x01	; 1
     304:	c6 e4       	ldi	r28, 0x46	; 70
     306:	d1 e0       	ldi	r29, 0x01	; 1
     308:	a2 e1       	ldi	r26, 0x12	; 18
     30a:	b1 e0       	ldi	r27, 0x01	; 1
     30c:	27 e2       	ldi	r18, 0x27	; 39
     30e:	31 e0       	ldi	r19, 0x01	; 1
	uint8_t i;
	extern uint8_t motorSingalPorts[NUM_IO_PORTS];
	
	for( i = 0; i < NUM_MOTORS; ++i )
	{
		if( MOTOR_SIGNAL_PORT[i] == &PORTB )
     310:	81 91       	ld	r24, Z+
     312:	91 91       	ld	r25, Z+
     314:	85 32       	cpi	r24, 0x25	; 37
     316:	91 05       	cpc	r25, r1
     318:	19 f4       	brne	.+6      	; 0x320 <_Z25initializeMotorControllerv+0x34>
		{
			motorSingalPorts[0] |= MOTOR_SIGNAL_PIN[i];
     31a:	8c 91       	ld	r24, X
     31c:	48 2b       	or	r20, r24
     31e:	10 c0       	rjmp	.+32     	; 0x340 <_Z25initializeMotorControllerv+0x54>
		}
		else if( MOTOR_SIGNAL_PORT[i] == &PORTC )
     320:	88 32       	cpi	r24, 0x28	; 40
     322:	91 05       	cpc	r25, r1
     324:	19 f4       	brne	.+6      	; 0x32c <_Z25initializeMotorControllerv+0x40>
		{
			motorSingalPorts[1] |= MOTOR_SIGNAL_PIN[i];
     326:	8c 91       	ld	r24, X
     328:	58 2b       	or	r21, r24
     32a:	0a c0       	rjmp	.+20     	; 0x340 <_Z25initializeMotorControllerv+0x54>
		}
		else if( MOTOR_SIGNAL_PORT[i] == &PORTD )
     32c:	8b 32       	cpi	r24, 0x2B	; 43
     32e:	91 05       	cpc	r25, r1
     330:	19 f4       	brne	.+6      	; 0x338 <_Z25initializeMotorControllerv+0x4c>
		{
			motorSingalPorts[2] |= MOTOR_SIGNAL_PIN[i];
     332:	8c 91       	ld	r24, X
     334:	68 2b       	or	r22, r24
     336:	04 c0       	rjmp	.+8      	; 0x340 <_Z25initializeMotorControllerv+0x54>
		}
		else if( MOTOR_SIGNAL_PORT[i] == &PORTE )
     338:	8e 97       	sbiw	r24, 0x2e	; 46
     33a:	11 f4       	brne	.+4      	; 0x340 <_Z25initializeMotorControllerv+0x54>
		{
			motorSingalPorts[3] |= MOTOR_SIGNAL_PIN[i];
     33c:	8c 91       	ld	r24, X
     33e:	78 2b       	or	r23, r24
		}
		numOverCurrentReads[i] = 0;
     340:	19 92       	st	Y+, r1
     342:	11 96       	adiw	r26, 0x01	; 1
void initializeMotorController()
{
	uint8_t i;
	extern uint8_t motorSingalPorts[NUM_IO_PORTS];
	
	for( i = 0; i < NUM_MOTORS; ++i )
     344:	e2 17       	cp	r30, r18
     346:	f3 07       	cpc	r31, r19
     348:	19 f7       	brne	.-58     	; 0x310 <_Z25initializeMotorControllerv+0x24>
     34a:	40 93 77 01 	sts	0x0177, r20
     34e:	50 93 78 01 	sts	0x0178, r21
     352:	60 93 79 01 	sts	0x0179, r22
     356:	70 93 7a 01 	sts	0x017A, r23
			motorSingalPorts[3] |= MOTOR_SIGNAL_PIN[i];
		}
		numOverCurrentReads[i] = 0;
	}
	
	DDRB |= motorSingalPorts[0];
     35a:	84 b1       	in	r24, 0x04	; 4
     35c:	48 2b       	or	r20, r24
     35e:	44 b9       	out	0x04, r20	; 4
	DDRC |= motorSingalPorts[1];
     360:	87 b1       	in	r24, 0x07	; 7
     362:	58 2b       	or	r21, r24
     364:	57 b9       	out	0x07, r21	; 7
	DDRD |= motorSingalPorts[2];
     366:	8a b1       	in	r24, 0x0a	; 10
     368:	68 2b       	or	r22, r24
     36a:	6a b9       	out	0x0a, r22	; 10
	DDRE |= motorSingalPorts[3];
     36c:	8d b1       	in	r24, 0x0d	; 13
     36e:	78 2b       	or	r23, r24
     370:	7d b9       	out	0x0d, r23	; 13
}
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <_Z17readMotorCurrentsv>:

void readMotorCurrents()
{
     378:	7f 92       	push	r7
     37a:	8f 92       	push	r8
     37c:	9f 92       	push	r9
     37e:	af 92       	push	r10
     380:	bf 92       	push	r11
     382:	cf 92       	push	r12
     384:	df 92       	push	r13
     386:	ef 92       	push	r14
     388:	ff 92       	push	r15
     38a:	0f 93       	push	r16
     38c:	1f 93       	push	r17
     38e:	cf 93       	push	r28
     390:	df 93       	push	r29
     392:	0f 2e       	mov	r0, r31
     394:	fb e0       	ldi	r31, 0x0B	; 11
     396:	8f 2e       	mov	r8, r31
     398:	f1 e0       	ldi	r31, 0x01	; 1
     39a:	9f 2e       	mov	r9, r31
     39c:	f0 2d       	mov	r31, r0
     39e:	0f 2e       	mov	r0, r31
     3a0:	f9 e6       	ldi	r31, 0x69	; 105
     3a2:	af 2e       	mov	r10, r31
     3a4:	f1 e0       	ldi	r31, 0x01	; 1
     3a6:	bf 2e       	mov	r11, r31
     3a8:	f0 2d       	mov	r31, r0
     3aa:	0f 2e       	mov	r0, r31
     3ac:	fd e4       	ldi	r31, 0x4D	; 77
     3ae:	cf 2e       	mov	r12, r31
     3b0:	f1 e0       	ldi	r31, 0x01	; 1
     3b2:	df 2e       	mov	r13, r31
     3b4:	f0 2d       	mov	r31, r0
     3b6:	0f 2e       	mov	r0, r31
     3b8:	f9 e1       	ldi	r31, 0x19	; 25
     3ba:	ef 2e       	mov	r14, r31
     3bc:	f1 e0       	ldi	r31, 0x01	; 1
     3be:	ff 2e       	mov	r15, r31
     3c0:	f0 2d       	mov	r31, r0
     3c2:	c6 e4       	ldi	r28, 0x46	; 70
     3c4:	d1 e0       	ldi	r29, 0x01	; 1
     3c6:	00 e0       	ldi	r16, 0x00	; 0
     3c8:	10 e0       	ldi	r17, 0x00	; 0
	
	for(i = 0; i < NUM_MOTORS; ++i)
	{
		analogIntRead[i] = analogRead(MOTOR_READ_PIN[i]);
		/* transforming a range of 0 - 1023 to a range of -50 to 50 */
		motorVoltageValues[i] = (analogIntRead[i] - 512) * 50/512;
     3ca:	0f 2e       	mov	r0, r31
     3cc:	f2 e3       	ldi	r31, 0x32	; 50
     3ce:	7f 2e       	mov	r7, r31
     3d0:	f0 2d       	mov	r31, r0
{
	uint8_t i;
	
	for(i = 0; i < NUM_MOTORS; ++i)
	{
		analogIntRead[i] = analogRead(MOTOR_READ_PIN[i]);
     3d2:	d4 01       	movw	r26, r8
     3d4:	8d 91       	ld	r24, X+
     3d6:	4d 01       	movw	r8, r26
     3d8:	0e 94 a3 03 	call	0x746	; 0x746 <analogRead>
     3dc:	f5 01       	movw	r30, r10
     3de:	81 93       	st	Z+, r24
     3e0:	91 93       	st	Z+, r25
     3e2:	5f 01       	movw	r10, r30
		/* transforming a range of 0 - 1023 to a range of -50 to 50 */
		motorVoltageValues[i] = (analogIntRead[i] - 512) * 50/512;
     3e4:	92 50       	subi	r25, 0x02	; 2
     3e6:	78 9e       	mul	r7, r24
     3e8:	b0 01       	movw	r22, r0
     3ea:	79 9e       	mul	r7, r25
     3ec:	70 0d       	add	r23, r0
     3ee:	11 24       	eor	r1, r1
     3f0:	77 23       	and	r23, r23
     3f2:	14 f4       	brge	.+4      	; 0x3f8 <_Z17readMotorCurrentsv+0x80>
     3f4:	61 50       	subi	r22, 0x01	; 1
     3f6:	7e 4f       	sbci	r23, 0xFE	; 254
     3f8:	67 2f       	mov	r22, r23
     3fa:	77 0f       	add	r23, r23
     3fc:	77 0b       	sbc	r23, r23
     3fe:	65 95       	asr	r22
     400:	88 27       	eor	r24, r24
     402:	77 fd       	sbrc	r23, 7
     404:	80 95       	com	r24
     406:	98 2f       	mov	r25, r24
     408:	0e 94 55 02 	call	0x4aa	; 0x4aa <__floatsisf>
     40c:	d6 01       	movw	r26, r12
     40e:	6d 93       	st	X+, r22
     410:	7d 93       	st	X+, r23
     412:	8d 93       	st	X+, r24
     414:	9d 93       	st	X+, r25
     416:	6d 01       	movw	r12, r26
		if( motorVoltageValues[i] > MAX_MOTOR_CURRENT )
     418:	20 e0       	ldi	r18, 0x00	; 0
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	48 ec       	ldi	r20, 0xC8	; 200
     41e:	51 e4       	ldi	r21, 0x41	; 65
     420:	0e 94 90 02 	call	0x520	; 0x520 <__gesf2>
     424:	18 16       	cp	r1, r24
     426:	8c f4       	brge	.+34     	; 0x44a <_Z17readMotorCurrentsv+0xd2>
		{
			numOverCurrentReads[i]++;
     428:	88 81       	ld	r24, Y
     42a:	8f 5f       	subi	r24, 0xFF	; 255
     42c:	88 83       	st	Y, r24
			if (numOverCurrentReads[i] == NUM_CURRENT_READS_TRIGGER_FAULT )
     42e:	85 30       	cpi	r24, 0x05	; 5
     430:	69 f4       	brne	.+26     	; 0x44c <_Z17readMotorCurrentsv+0xd4>
	}
}

inline void turnOffMotorController(const uint8_t motorNumber)
{
	*MOTOR_SIGNAL_PORT[motorNumber] &= ~(MOTOR_SIGNAL_PIN[motorNumber]);
     432:	d7 01       	movw	r26, r14
     434:	ed 91       	ld	r30, X+
     436:	fc 91       	ld	r31, X
     438:	90 81       	ld	r25, Z
     43a:	d8 01       	movw	r26, r16
     43c:	ae 5e       	subi	r26, 0xEE	; 238
     43e:	be 4f       	sbci	r27, 0xFE	; 254
     440:	8c 91       	ld	r24, X
     442:	80 95       	com	r24
     444:	89 23       	and	r24, r25
     446:	80 83       	st	Z, r24
     448:	01 c0       	rjmp	.+2      	; 0x44c <_Z17readMotorCurrentsv+0xd4>
				turnOffMotorController(i);
			}
		}
		else
		{
			numOverCurrentReads[i] = 0;
     44a:	18 82       	st	Y, r1
     44c:	0f 5f       	subi	r16, 0xFF	; 255
     44e:	1f 4f       	sbci	r17, 0xFF	; 255
     450:	b2 e0       	ldi	r27, 0x02	; 2
     452:	eb 0e       	add	r14, r27
     454:	f1 1c       	adc	r15, r1
     456:	21 96       	adiw	r28, 0x01	; 1

void readMotorCurrents()
{
	uint8_t i;
	
	for(i = 0; i < NUM_MOTORS; ++i)
     458:	07 30       	cpi	r16, 0x07	; 7
     45a:	11 05       	cpc	r17, r1
     45c:	09 f0       	breq	.+2      	; 0x460 <_Z17readMotorCurrentsv+0xe8>
     45e:	b9 cf       	rjmp	.-142    	; 0x3d2 <_Z17readMotorCurrentsv+0x5a>
		else
		{
			numOverCurrentReads[i] = 0;
		}
	}
}
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	1f 91       	pop	r17
     466:	0f 91       	pop	r16
     468:	ff 90       	pop	r15
     46a:	ef 90       	pop	r14
     46c:	df 90       	pop	r13
     46e:	cf 90       	pop	r12
     470:	bf 90       	pop	r11
     472:	af 90       	pop	r10
     474:	9f 90       	pop	r9
     476:	8f 90       	pop	r8
     478:	7f 90       	pop	r7
     47a:	08 95       	ret

0000047c <_Z15turnOnAllMotorsv>:
	*MOTOR_SIGNAL_PORT[motorNumber] |= MOTOR_SIGNAL_PIN[motorNumber];
}

void turnOnAllMotors()
{ 
	PORTB |= motorSingalPorts[0];
     47c:	95 b1       	in	r25, 0x05	; 5
     47e:	80 91 77 01 	lds	r24, 0x0177
     482:	89 2b       	or	r24, r25
     484:	85 b9       	out	0x05, r24	; 5
	PORTC |= motorSingalPorts[1];
     486:	98 b1       	in	r25, 0x08	; 8
     488:	80 91 78 01 	lds	r24, 0x0178
     48c:	89 2b       	or	r24, r25
     48e:	88 b9       	out	0x08, r24	; 8
	PORTD |= motorSingalPorts[2];
     490:	9b b1       	in	r25, 0x0b	; 11
     492:	80 91 79 01 	lds	r24, 0x0179
     496:	89 2b       	or	r24, r25
     498:	8b b9       	out	0x0b, r24	; 11
	PORTE |= motorSingalPorts[3];
     49a:	9e b1       	in	r25, 0x0e	; 14
     49c:	80 91 7a 01 	lds	r24, 0x017A
     4a0:	89 2b       	or	r24, r25
     4a2:	8e b9       	out	0x0e, r24	; 14
     4a4:	08 95       	ret

000004a6 <__floatunsisf>:
     4a6:	e8 94       	clt
     4a8:	09 c0       	rjmp	.+18     	; 0x4bc <__floatsisf+0x12>

000004aa <__floatsisf>:
     4aa:	97 fb       	bst	r25, 7
     4ac:	3e f4       	brtc	.+14     	; 0x4bc <__floatsisf+0x12>
     4ae:	90 95       	com	r25
     4b0:	80 95       	com	r24
     4b2:	70 95       	com	r23
     4b4:	61 95       	neg	r22
     4b6:	7f 4f       	sbci	r23, 0xFF	; 255
     4b8:	8f 4f       	sbci	r24, 0xFF	; 255
     4ba:	9f 4f       	sbci	r25, 0xFF	; 255
     4bc:	99 23       	and	r25, r25
     4be:	a9 f0       	breq	.+42     	; 0x4ea <__floatsisf+0x40>
     4c0:	f9 2f       	mov	r31, r25
     4c2:	96 e9       	ldi	r25, 0x96	; 150
     4c4:	bb 27       	eor	r27, r27
     4c6:	93 95       	inc	r25
     4c8:	f6 95       	lsr	r31
     4ca:	87 95       	ror	r24
     4cc:	77 95       	ror	r23
     4ce:	67 95       	ror	r22
     4d0:	b7 95       	ror	r27
     4d2:	f1 11       	cpse	r31, r1
     4d4:	f8 cf       	rjmp	.-16     	; 0x4c6 <__floatsisf+0x1c>
     4d6:	fa f4       	brpl	.+62     	; 0x516 <__floatsisf+0x6c>
     4d8:	bb 0f       	add	r27, r27
     4da:	11 f4       	brne	.+4      	; 0x4e0 <__floatsisf+0x36>
     4dc:	60 ff       	sbrs	r22, 0
     4de:	1b c0       	rjmp	.+54     	; 0x516 <__floatsisf+0x6c>
     4e0:	6f 5f       	subi	r22, 0xFF	; 255
     4e2:	7f 4f       	sbci	r23, 0xFF	; 255
     4e4:	8f 4f       	sbci	r24, 0xFF	; 255
     4e6:	9f 4f       	sbci	r25, 0xFF	; 255
     4e8:	16 c0       	rjmp	.+44     	; 0x516 <__floatsisf+0x6c>
     4ea:	88 23       	and	r24, r24
     4ec:	11 f0       	breq	.+4      	; 0x4f2 <__floatsisf+0x48>
     4ee:	96 e9       	ldi	r25, 0x96	; 150
     4f0:	11 c0       	rjmp	.+34     	; 0x514 <__floatsisf+0x6a>
     4f2:	77 23       	and	r23, r23
     4f4:	21 f0       	breq	.+8      	; 0x4fe <__floatsisf+0x54>
     4f6:	9e e8       	ldi	r25, 0x8E	; 142
     4f8:	87 2f       	mov	r24, r23
     4fa:	76 2f       	mov	r23, r22
     4fc:	05 c0       	rjmp	.+10     	; 0x508 <__floatsisf+0x5e>
     4fe:	66 23       	and	r22, r22
     500:	71 f0       	breq	.+28     	; 0x51e <__floatsisf+0x74>
     502:	96 e8       	ldi	r25, 0x86	; 134
     504:	86 2f       	mov	r24, r22
     506:	70 e0       	ldi	r23, 0x00	; 0
     508:	60 e0       	ldi	r22, 0x00	; 0
     50a:	2a f0       	brmi	.+10     	; 0x516 <__floatsisf+0x6c>
     50c:	9a 95       	dec	r25
     50e:	66 0f       	add	r22, r22
     510:	77 1f       	adc	r23, r23
     512:	88 1f       	adc	r24, r24
     514:	da f7       	brpl	.-10     	; 0x50c <__floatsisf+0x62>
     516:	88 0f       	add	r24, r24
     518:	96 95       	lsr	r25
     51a:	87 95       	ror	r24
     51c:	97 f9       	bld	r25, 7
     51e:	08 95       	ret

00000520 <__gesf2>:
     520:	03 d0       	rcall	.+6      	; 0x528 <__fp_cmp>
     522:	08 f4       	brcc	.+2      	; 0x526 <__gesf2+0x6>
     524:	8f ef       	ldi	r24, 0xFF	; 255
     526:	08 95       	ret

00000528 <__fp_cmp>:
     528:	99 0f       	add	r25, r25
     52a:	00 08       	sbc	r0, r0
     52c:	55 0f       	add	r21, r21
     52e:	aa 0b       	sbc	r26, r26
     530:	e0 e8       	ldi	r30, 0x80	; 128
     532:	fe ef       	ldi	r31, 0xFE	; 254
     534:	16 16       	cp	r1, r22
     536:	17 06       	cpc	r1, r23
     538:	e8 07       	cpc	r30, r24
     53a:	f9 07       	cpc	r31, r25
     53c:	c0 f0       	brcs	.+48     	; 0x56e <__fp_cmp+0x46>
     53e:	12 16       	cp	r1, r18
     540:	13 06       	cpc	r1, r19
     542:	e4 07       	cpc	r30, r20
     544:	f5 07       	cpc	r31, r21
     546:	98 f0       	brcs	.+38     	; 0x56e <__fp_cmp+0x46>
     548:	62 1b       	sub	r22, r18
     54a:	73 0b       	sbc	r23, r19
     54c:	84 0b       	sbc	r24, r20
     54e:	95 0b       	sbc	r25, r21
     550:	39 f4       	brne	.+14     	; 0x560 <__fp_cmp+0x38>
     552:	0a 26       	eor	r0, r26
     554:	61 f0       	breq	.+24     	; 0x56e <__fp_cmp+0x46>
     556:	23 2b       	or	r18, r19
     558:	24 2b       	or	r18, r20
     55a:	25 2b       	or	r18, r21
     55c:	21 f4       	brne	.+8      	; 0x566 <__fp_cmp+0x3e>
     55e:	08 95       	ret
     560:	0a 26       	eor	r0, r26
     562:	09 f4       	brne	.+2      	; 0x566 <__fp_cmp+0x3e>
     564:	a1 40       	sbci	r26, 0x01	; 1
     566:	a6 95       	lsr	r26
     568:	8f ef       	ldi	r24, 0xFF	; 255
     56a:	81 1d       	adc	r24, r1
     56c:	81 1d       	adc	r24, r1
     56e:	08 95       	ret

00000570 <__vector_23>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     570:	1f 92       	push	r1
     572:	0f 92       	push	r0
     574:	0f b6       	in	r0, 0x3f	; 63
     576:	0f 92       	push	r0
     578:	11 24       	eor	r1, r1
     57a:	2f 93       	push	r18
     57c:	3f 93       	push	r19
     57e:	8f 93       	push	r24
     580:	9f 93       	push	r25
     582:	af 93       	push	r26
     584:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     586:	80 91 7c 01 	lds	r24, 0x017C
     58a:	90 91 7d 01 	lds	r25, 0x017D
     58e:	a0 91 7e 01 	lds	r26, 0x017E
     592:	b0 91 7f 01 	lds	r27, 0x017F
	unsigned char f = timer0_fract;
     596:	30 91 7b 01 	lds	r19, 0x017B

	m += MILLIS_INC;
	f += FRACT_INC;
     59a:	23 e0       	ldi	r18, 0x03	; 3
     59c:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
     59e:	2d 37       	cpi	r18, 0x7D	; 125
     5a0:	20 f4       	brcc	.+8      	; 0x5aa <__vector_23+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
     5a2:	01 96       	adiw	r24, 0x01	; 1
     5a4:	a1 1d       	adc	r26, r1
     5a6:	b1 1d       	adc	r27, r1
     5a8:	05 c0       	rjmp	.+10     	; 0x5b4 <__vector_23+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     5aa:	26 e8       	ldi	r18, 0x86	; 134
     5ac:	23 0f       	add	r18, r19
		m += 1;
     5ae:	02 96       	adiw	r24, 0x02	; 2
     5b0:	a1 1d       	adc	r26, r1
     5b2:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
     5b4:	20 93 7b 01 	sts	0x017B, r18
	timer0_millis = m;
     5b8:	80 93 7c 01 	sts	0x017C, r24
     5bc:	90 93 7d 01 	sts	0x017D, r25
     5c0:	a0 93 7e 01 	sts	0x017E, r26
     5c4:	b0 93 7f 01 	sts	0x017F, r27
	timer0_overflow_count++;
     5c8:	80 91 80 01 	lds	r24, 0x0180
     5cc:	90 91 81 01 	lds	r25, 0x0181
     5d0:	a0 91 82 01 	lds	r26, 0x0182
     5d4:	b0 91 83 01 	lds	r27, 0x0183
     5d8:	01 96       	adiw	r24, 0x01	; 1
     5da:	a1 1d       	adc	r26, r1
     5dc:	b1 1d       	adc	r27, r1
     5de:	80 93 80 01 	sts	0x0180, r24
     5e2:	90 93 81 01 	sts	0x0181, r25
     5e6:	a0 93 82 01 	sts	0x0182, r26
     5ea:	b0 93 83 01 	sts	0x0183, r27
}
     5ee:	bf 91       	pop	r27
     5f0:	af 91       	pop	r26
     5f2:	9f 91       	pop	r25
     5f4:	8f 91       	pop	r24
     5f6:	3f 91       	pop	r19
     5f8:	2f 91       	pop	r18
     5fa:	0f 90       	pop	r0
     5fc:	0f be       	out	0x3f, r0	; 63
     5fe:	0f 90       	pop	r0
     600:	1f 90       	pop	r1
     602:	18 95       	reti

00000604 <micros>:
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     604:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
     606:	f8 94       	cli
	m = timer0_overflow_count;
     608:	80 91 80 01 	lds	r24, 0x0180
     60c:	90 91 81 01 	lds	r25, 0x0181
     610:	a0 91 82 01 	lds	r26, 0x0182
     614:	b0 91 83 01 	lds	r27, 0x0183
#if defined(TCNT0)
	t = TCNT0;
     618:	26 b5       	in	r18, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     61a:	a8 9b       	sbis	0x15, 0	; 21
     61c:	05 c0       	rjmp	.+10     	; 0x628 <micros+0x24>
     61e:	2f 3f       	cpi	r18, 0xFF	; 255
     620:	19 f0       	breq	.+6      	; 0x628 <micros+0x24>
		m++;
     622:	01 96       	adiw	r24, 0x01	; 1
     624:	a1 1d       	adc	r26, r1
     626:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     628:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     62a:	66 27       	eor	r22, r22
     62c:	78 2f       	mov	r23, r24
     62e:	89 2f       	mov	r24, r25
     630:	9a 2f       	mov	r25, r26
     632:	62 0f       	add	r22, r18
     634:	71 1d       	adc	r23, r1
     636:	81 1d       	adc	r24, r1
     638:	91 1d       	adc	r25, r1
     63a:	42 e0       	ldi	r20, 0x02	; 2
     63c:	66 0f       	add	r22, r22
     63e:	77 1f       	adc	r23, r23
     640:	88 1f       	adc	r24, r24
     642:	99 1f       	adc	r25, r25
     644:	4a 95       	dec	r20
     646:	d1 f7       	brne	.-12     	; 0x63c <micros+0x38>
}
     648:	08 95       	ret

0000064a <delay>:

void delay(unsigned long ms)
{
     64a:	cf 92       	push	r12
     64c:	df 92       	push	r13
     64e:	ef 92       	push	r14
     650:	ff 92       	push	r15
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	6b 01       	movw	r12, r22
     658:	7c 01       	movw	r14, r24
	uint16_t start = (uint16_t)micros();
     65a:	0e 94 02 03 	call	0x604	; 0x604 <micros>
     65e:	eb 01       	movw	r28, r22

	while (ms > 0) {
     660:	c1 14       	cp	r12, r1
     662:	d1 04       	cpc	r13, r1
     664:	e1 04       	cpc	r14, r1
     666:	f1 04       	cpc	r15, r1
     668:	89 f0       	breq	.+34     	; 0x68c <delay+0x42>
		yield();
     66a:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <yield>
		if (((uint16_t)micros() - start) >= 1000) {
     66e:	0e 94 02 03 	call	0x604	; 0x604 <micros>
     672:	6c 1b       	sub	r22, r28
     674:	7d 0b       	sbc	r23, r29
     676:	68 3e       	cpi	r22, 0xE8	; 232
     678:	73 40       	sbci	r23, 0x03	; 3
     67a:	90 f3       	brcs	.-28     	; 0x660 <delay+0x16>
			ms--;
     67c:	81 e0       	ldi	r24, 0x01	; 1
     67e:	c8 1a       	sub	r12, r24
     680:	d1 08       	sbc	r13, r1
     682:	e1 08       	sbc	r14, r1
     684:	f1 08       	sbc	r15, r1
			start += 1000;
     686:	c8 51       	subi	r28, 0x18	; 24
     688:	dc 4f       	sbci	r29, 0xFC	; 252
     68a:	ea cf       	rjmp	.-44     	; 0x660 <delay+0x16>
		}
	}
}
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	ff 90       	pop	r15
     692:	ef 90       	pop	r14
     694:	df 90       	pop	r13
     696:	cf 90       	pop	r12
     698:	08 95       	ret

0000069a <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     69a:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     69c:	84 b5       	in	r24, 0x24	; 36
     69e:	82 60       	ori	r24, 0x02	; 2
     6a0:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     6a2:	84 b5       	in	r24, 0x24	; 36
     6a4:	81 60       	ori	r24, 0x01	; 1
     6a6:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     6a8:	85 b5       	in	r24, 0x25	; 37
     6aa:	82 60       	ori	r24, 0x02	; 2
     6ac:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     6ae:	85 b5       	in	r24, 0x25	; 37
     6b0:	81 60       	ori	r24, 0x01	; 1
     6b2:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     6b4:	ee e6       	ldi	r30, 0x6E	; 110
     6b6:	f0 e0       	ldi	r31, 0x00	; 0
     6b8:	80 81       	ld	r24, Z
     6ba:	81 60       	ori	r24, 0x01	; 1
     6bc:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     6be:	e1 e8       	ldi	r30, 0x81	; 129
     6c0:	f0 e0       	ldi	r31, 0x00	; 0
     6c2:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     6c4:	80 81       	ld	r24, Z
     6c6:	82 60       	ori	r24, 0x02	; 2
     6c8:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     6ca:	80 81       	ld	r24, Z
     6cc:	81 60       	ori	r24, 0x01	; 1
     6ce:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     6d0:	e0 e8       	ldi	r30, 0x80	; 128
     6d2:	f0 e0       	ldi	r31, 0x00	; 0
     6d4:	80 81       	ld	r24, Z
     6d6:	81 60       	ori	r24, 0x01	; 1
     6d8:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
     6da:	e1 e9       	ldi	r30, 0x91	; 145
     6dc:	f0 e0       	ldi	r31, 0x00	; 0
     6de:	80 81       	ld	r24, Z
     6e0:	82 60       	ori	r24, 0x02	; 2
     6e2:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
     6e4:	80 81       	ld	r24, Z
     6e6:	81 60       	ori	r24, 0x01	; 1
     6e8:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
     6ea:	e0 e9       	ldi	r30, 0x90	; 144
     6ec:	f0 e0       	ldi	r31, 0x00	; 0
     6ee:	80 81       	ld	r24, Z
     6f0:	81 60       	ori	r24, 0x01	; 1
     6f2:	80 83       	st	Z, r24
#endif

#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
     6f4:	e1 ec       	ldi	r30, 0xC1	; 193
     6f6:	f0 e0       	ldi	r31, 0x00	; 0
     6f8:	80 81       	ld	r24, Z
     6fa:	84 60       	ori	r24, 0x04	; 4
     6fc:	80 83       	st	Z, r24
	sbi(TCCR4B, CS41);
     6fe:	80 81       	ld	r24, Z
     700:	82 60       	ori	r24, 0x02	; 2
     702:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
     704:	80 81       	ld	r24, Z
     706:	81 60       	ori	r24, 0x01	; 1
     708:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
     70a:	e3 ec       	ldi	r30, 0xC3	; 195
     70c:	f0 e0       	ldi	r31, 0x00	; 0
     70e:	80 81       	ld	r24, Z
     710:	81 60       	ori	r24, 0x01	; 1
     712:	80 83       	st	Z, r24
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
     714:	e0 ec       	ldi	r30, 0xC0	; 192
     716:	f0 e0       	ldi	r31, 0x00	; 0
     718:	80 81       	ld	r24, Z
     71a:	82 60       	ori	r24, 0x02	; 2
     71c:	80 83       	st	Z, r24
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
     71e:	e2 ec       	ldi	r30, 0xC2	; 194
     720:	f0 e0       	ldi	r31, 0x00	; 0
     722:	80 81       	ld	r24, Z
     724:	81 60       	ori	r24, 0x01	; 1
     726:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
     728:	ea e7       	ldi	r30, 0x7A	; 122
     72a:	f0 e0       	ldi	r31, 0x00	; 0
     72c:	80 81       	ld	r24, Z
     72e:	84 60       	ori	r24, 0x04	; 4
     730:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
     732:	80 81       	ld	r24, Z
     734:	82 60       	ori	r24, 0x02	; 2
     736:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
     738:	80 81       	ld	r24, Z
     73a:	81 60       	ori	r24, 0x01	; 1
     73c:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     73e:	80 81       	ld	r24, Z
     740:	80 68       	ori	r24, 0x80	; 128
     742:	80 83       	st	Z, r24
     744:	08 95       	ret

00000746 <analogRead>:
{
	uint8_t low, high;

#if defined(analogPinToChannel)
#if defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
     746:	82 31       	cpi	r24, 0x12	; 18
     748:	08 f0       	brcs	.+2      	; 0x74c <analogRead+0x6>
     74a:	82 51       	subi	r24, 0x12	; 18
#endif
	pin = analogPinToChannel(pin);
     74c:	e8 2f       	mov	r30, r24
     74e:	f0 e0       	ldi	r31, 0x00	; 0
     750:	e4 55       	subi	r30, 0x54	; 84
     752:	ff 4f       	sbci	r31, 0xFF	; 255
     754:	e4 91       	lpm	r30, Z
#endif

#if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
     756:	80 91 7b 00 	lds	r24, 0x007B
     75a:	e3 fb       	bst	r30, 3
     75c:	22 27       	eor	r18, r18
     75e:	20 f9       	bld	r18, 0
     760:	30 e0       	ldi	r19, 0x00	; 0
     762:	95 e0       	ldi	r25, 0x05	; 5
     764:	22 0f       	add	r18, r18
     766:	33 1f       	adc	r19, r19
     768:	9a 95       	dec	r25
     76a:	e1 f7       	brne	.-8      	; 0x764 <analogRead+0x1e>
     76c:	8f 7d       	andi	r24, 0xDF	; 223
     76e:	82 2b       	or	r24, r18
     770:	80 93 7b 00 	sts	0x007B, r24
  
	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
#if defined(ADMUX)
	ADMUX = (analog_reference << 6) | (pin & 0x07);
     774:	e7 70       	andi	r30, 0x07	; 7
     776:	80 91 00 01 	lds	r24, 0x0100
     77a:	20 e4       	ldi	r18, 0x40	; 64
     77c:	82 9f       	mul	r24, r18
     77e:	c0 01       	movw	r24, r0
     780:	11 24       	eor	r1, r1
     782:	e8 2b       	or	r30, r24
     784:	e0 93 7c 00 	sts	0x007C, r30
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
     788:	80 91 7a 00 	lds	r24, 0x007A
     78c:	80 64       	ori	r24, 0x40	; 64
     78e:	80 93 7a 00 	sts	0x007A, r24

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
     792:	80 91 7a 00 	lds	r24, 0x007A
     796:	86 fd       	sbrc	r24, 6
     798:	fc cf       	rjmp	.-8      	; 0x792 <analogRead+0x4c>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
     79a:	80 91 78 00 	lds	r24, 0x0078
	high = ADCH;
     79e:	20 91 79 00 	lds	r18, 0x0079
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
     7a2:	90 e0       	ldi	r25, 0x00	; 0
}
     7a4:	92 2b       	or	r25, r18
     7a6:	08 95       	ret

000007a8 <_ZN7Serial_5writeEh>:
}

void Serial_::flush(void)
{
	USB_Flush(CDC_TX);
}
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	1f 92       	push	r1
     7ae:	cd b7       	in	r28, 0x3d	; 61
     7b0:	de b7       	in	r29, 0x3e	; 62
     7b2:	69 83       	std	Y+1, r22	; 0x01

     7b4:	dc 01       	movw	r26, r24
     7b6:	ed 91       	ld	r30, X+
     7b8:	fc 91       	ld	r31, X
     7ba:	02 80       	ldd	r0, Z+2	; 0x02
     7bc:	f3 81       	ldd	r31, Z+3	; 0x03
     7be:	e0 2d       	mov	r30, r0
     7c0:	41 e0       	ldi	r20, 0x01	; 1
     7c2:	50 e0       	ldi	r21, 0x00	; 0
     7c4:	be 01       	movw	r22, r28
     7c6:	6f 5f       	subi	r22, 0xFF	; 255
     7c8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ca:	09 95       	icall
size_t Serial_::write(uint8_t c)
     7cc:	0f 90       	pop	r0
     7ce:	df 91       	pop	r29
     7d0:	cf 91       	pop	r28
     7d2:	08 95       	ret

000007d4 <_ZN7Serial_4peekEv>:
{
	if (peek_buffer >= 0) {
		return 1 + USB_Available(CDC_RX);
	}
	return USB_Available(CDC_RX);
}
     7d4:	cf 93       	push	r28
     7d6:	df 93       	push	r29
     7d8:	ec 01       	movw	r28, r24

     7da:	8c 85       	ldd	r24, Y+12	; 0x0c
     7dc:	9d 85       	ldd	r25, Y+13	; 0x0d
     7de:	97 ff       	sbrs	r25, 7
     7e0:	05 c0       	rjmp	.+10     	; 0x7ec <_ZN7Serial_4peekEv+0x18>
int Serial_::peek(void)
     7e2:	82 e0       	ldi	r24, 0x02	; 2
     7e4:	0e 94 a9 05 	call	0xb52	; 0xb52 <_Z8USB_Recvh>
     7e8:	9d 87       	std	Y+13, r25	; 0x0d
     7ea:	8c 87       	std	Y+12, r24	; 0x0c
{
	if (peek_buffer < 0)
     7ec:	8c 85       	ldd	r24, Y+12	; 0x0c
     7ee:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f0:	df 91       	pop	r29
     7f2:	cf 91       	pop	r28
     7f4:	08 95       	ret

000007f6 <_ZN7Serial_5flushEv>:
		peek_buffer = -1;
		return c;
	}
	return USB_Recv(CDC_RX);
}

     7f6:	83 e0       	ldi	r24, 0x03	; 3
     7f8:	0c 94 fe 07 	jmp	0xffc	; 0xffc <_Z9USB_Flushh>

000007fc <_ZN7Serial_9availableEv>:
}

void Serial_::end(void)
{
}

     7fc:	fc 01       	movw	r30, r24
     7fe:	84 85       	ldd	r24, Z+12	; 0x0c
     800:	95 85       	ldd	r25, Z+13	; 0x0d
     802:	97 fd       	sbrc	r25, 7
     804:	06 c0       	rjmp	.+12     	; 0x812 <_ZN7Serial_9availableEv+0x16>
int Serial_::available(void)
     806:	82 e0       	ldi	r24, 0x02	; 2
     808:	0e 94 51 05 	call	0xaa2	; 0xaa2 <_Z13USB_Availableh>
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	01 96       	adiw	r24, 0x01	; 1
     810:	08 95       	ret
{
	if (peek_buffer >= 0) {
     812:	82 e0       	ldi	r24, 0x02	; 2
     814:	0e 94 51 05 	call	0xaa2	; 0xaa2 <_Z13USB_Availableh>
     818:	90 e0       	ldi	r25, 0x00	; 0
		return 1 + USB_Available(CDC_RX);
     81a:	08 95       	ret

0000081c <_ZN7Serial_4readEv>:
int Serial_::peek(void)
{
	if (peek_buffer < 0)
		peek_buffer = USB_Recv(CDC_RX);
	return peek_buffer;
}
     81c:	fc 01       	movw	r30, r24

     81e:	84 85       	ldd	r24, Z+12	; 0x0c
     820:	95 85       	ldd	r25, Z+13	; 0x0d
     822:	97 fd       	sbrc	r25, 7
     824:	05 c0       	rjmp	.+10     	; 0x830 <_ZN7Serial_4readEv+0x14>
int Serial_::read(void)
{
     826:	2f ef       	ldi	r18, 0xFF	; 255
     828:	3f ef       	ldi	r19, 0xFF	; 255
     82a:	35 87       	std	Z+13, r19	; 0x0d
     82c:	24 87       	std	Z+12, r18	; 0x0c
	if (peek_buffer >= 0) {
     82e:	08 95       	ret
		int c = peek_buffer;
		peek_buffer = -1;
     830:	82 e0       	ldi	r24, 0x02	; 2
     832:	0c 94 a9 05 	jmp	0xb52	; 0xb52 <_Z8USB_Recvh>

00000836 <_ZN7Serial_5writeEPKhj>:
}

size_t Serial_::write(uint8_t c)
{
	return write(&c, 1);
}
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
     83a:	ec 01       	movw	r28, r24
	 is open (not just the pipe) - the OS should set lineState when the port
	 is opened and clear lineState when the port is closed.
	 bytes sent before the user opens the connection or after
	 the connection is closed are lost - just like with a UART. */
	
	// TODO - ZE - check behavior on different OSes and test what happens if an
     83c:	80 91 08 01 	lds	r24, 0x0108
     840:	88 23       	and	r24, r24
     842:	31 f0       	breq	.+12     	; 0x850 <_ZN7Serial_5writeEPKhj+0x1a>
	// open connection isn't broken cleanly (cable is yanked out, host dies
     844:	83 e0       	ldi	r24, 0x03	; 3
     846:	0e 94 da 05 	call	0xbb4	; 0xbb4 <_Z8USB_SendhPKvi>
	// or locks up, or host virtual serial port hangs)
     84a:	18 16       	cp	r1, r24
     84c:	19 06       	cpc	r1, r25
     84e:	34 f0       	brlt	.+12     	; 0x85c <_ZN7Serial_5writeEPKhj+0x26>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	9b 83       	std	Y+3, r25	; 0x03
     856:	8a 83       	std	Y+2, r24	; 0x02
		if (r > 0) {
			return r;
		} else {
			setWriteError();
			return 0;
		}
     858:	80 e0       	ldi	r24, 0x00	; 0
     85a:	90 e0       	ldi	r25, 0x00	; 0
	}
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	08 95       	ret

00000862 <_Z16CDC_GetInterfacePh>:
};

int WEAK CDC_GetInterface(u8* interfaceNum)
{
	interfaceNum[0] += 2;	// uses 2
	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
     862:	fc 01       	movw	r30, r24
     864:	20 81       	ld	r18, Z
     866:	2e 5f       	subi	r18, 0xFE	; 254
     868:	20 83       	st	Z, r18
}
     86a:	42 e4       	ldi	r20, 0x42	; 66
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	68 eb       	ldi	r22, 0xB8	; 184
     870:	70 e0       	ldi	r23, 0x00	; 0
     872:	80 e8       	ldi	r24, 0x80	; 128
     874:	0c 94 75 06 	jmp	0xcea	; 0xcea <_Z15USB_SendControlhPKvi>

00000878 <_Z9CDC_SetupR5Setup>:

bool WEAK CDC_Setup(Setup& setup)
{
	u8 r = setup.bRequest;
     878:	fc 01       	movw	r30, r24
	u8 requestType = setup.bmRequestType;
     87a:	81 81       	ldd	r24, Z+1	; 0x01

     87c:	90 81       	ld	r25, Z
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
	{
     87e:	91 3a       	cpi	r25, 0xA1	; 161
     880:	59 f4       	brne	.+22     	; 0x898 <_Z9CDC_SetupR5Setup+0x20>
		if (CDC_GET_LINE_CODING == r)
		{
     882:	81 32       	cpi	r24, 0x21	; 33
     884:	09 f0       	breq	.+2      	; 0x888 <_Z9CDC_SetupR5Setup+0x10>
     886:	4b c0       	rjmp	.+150    	; 0x91e <_Z9CDC_SetupR5Setup+0xa6>
			USB_SendControl(0,(void*)&_usbLineInfo,7);
			return true;
     888:	47 e0       	ldi	r20, 0x07	; 7
     88a:	50 e0       	ldi	r21, 0x00	; 0
     88c:	61 e0       	ldi	r22, 0x01	; 1
     88e:	71 e0       	ldi	r23, 0x01	; 1
     890:	80 e0       	ldi	r24, 0x00	; 0
     892:	0e 94 75 06 	call	0xcea	; 0xcea <_Z15USB_SendControlhPKvi>
     896:	45 c0       	rjmp	.+138    	; 0x922 <_Z9CDC_SetupR5Setup+0xaa>
		}
	}

	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
	{
     898:	91 32       	cpi	r25, 0x21	; 33
     89a:	09 f0       	breq	.+2      	; 0x89e <_Z9CDC_SetupR5Setup+0x26>
     89c:	40 c0       	rjmp	.+128    	; 0x91e <_Z9CDC_SetupR5Setup+0xa6>
		if (CDC_SET_LINE_CODING == r)
		{
     89e:	80 32       	cpi	r24, 0x20	; 32
     8a0:	39 f4       	brne	.+14     	; 0x8b0 <_Z9CDC_SetupR5Setup+0x38>
			USB_RecvControl((void*)&_usbLineInfo,7);
		}
     8a2:	67 e0       	ldi	r22, 0x07	; 7
     8a4:	70 e0       	ldi	r23, 0x00	; 0
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	91 e0       	ldi	r25, 0x01	; 1
     8aa:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_Z15USB_RecvControlPvi>
     8ae:	39 c0       	rjmp	.+114    	; 0x922 <_Z9CDC_SetupR5Setup+0xaa>

		if (CDC_SET_CONTROL_LINE_STATE == r)
		{
			_usbLineInfo.lineState = setup.wValueL;
     8b0:	82 32       	cpi	r24, 0x22	; 34
     8b2:	09 f0       	breq	.+2      	; 0x8b6 <_Z9CDC_SetupR5Setup+0x3e>
     8b4:	34 c0       	rjmp	.+104    	; 0x91e <_Z9CDC_SetupR5Setup+0xa6>
		}

     8b6:	82 81       	ldd	r24, Z+2	; 0x02
     8b8:	80 93 08 01 	sts	0x0108, r24
		if (CDC_SET_LINE_CODING == r || CDC_SET_CONTROL_LINE_STATE == r)
		{
			// auto-reset into the bootloader is triggered when the port, already 
			// open at 1200 bps, is closed.  this is the signal to start the watchdog
			// with a relatively long period so it can finish housekeeping tasks
			// like servicing endpoints before the sketch ends
     8bc:	80 91 01 01 	lds	r24, 0x0101
     8c0:	90 91 02 01 	lds	r25, 0x0102
     8c4:	a0 91 03 01 	lds	r26, 0x0103
     8c8:	b0 91 04 01 	lds	r27, 0x0104
     8cc:	80 3b       	cpi	r24, 0xB0	; 176
     8ce:	94 40       	sbci	r25, 0x04	; 4
     8d0:	a1 05       	cpc	r26, r1
     8d2:	b1 05       	cpc	r27, r1
     8d4:	31 f5       	brne	.+76     	; 0x922 <_Z9CDC_SetupR5Setup+0xaa>

			// We check DTR state to determine if host port is open (bit 0 of lineState).
     8d6:	80 91 08 01 	lds	r24, 0x0108
     8da:	80 fd       	sbrc	r24, 0
     8dc:	12 c0       	rjmp	.+36     	; 0x902 <_Z9CDC_SetupR5Setup+0x8a>
			if (1200 == _usbLineInfo.dwDTERate && (_usbLineInfo.lineState & 0x01) == 0)
     8de:	87 e7       	ldi	r24, 0x77	; 119
     8e0:	97 e7       	ldi	r25, 0x77	; 119
     8e2:	90 93 01 08 	sts	0x0801, r25
     8e6:	80 93 00 08 	sts	0x0800, r24
			{
     8ea:	2b e0       	ldi	r18, 0x0B	; 11
     8ec:	88 e1       	ldi	r24, 0x18	; 24
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	f8 94       	cli
     8f4:	a8 95       	wdr
     8f6:	80 93 60 00 	sts	0x0060, r24
     8fa:	0f be       	out	0x3f, r0	; 63
     8fc:	20 93 60 00 	sts	0x0060, r18
     900:	10 c0       	rjmp	.+32     	; 0x922 <_Z9CDC_SetupR5Setup+0xaa>
				wdt_enable(WDTO_120MS);
			}
			else
			{
				// Most OSs do some intermediate steps when configuring ports and DTR can
				// twiggle more than once before stabilizing.
     902:	88 e1       	ldi	r24, 0x18	; 24
     904:	0f b6       	in	r0, 0x3f	; 63
     906:	f8 94       	cli
     908:	80 93 60 00 	sts	0x0060, r24
     90c:	10 92 60 00 	sts	0x0060, r1
     910:	0f be       	out	0x3f, r0	; 63
				// To avoid spurious resets we set the watchdog to 250ms and eventually
     912:	a8 95       	wdr
				// cancel if DTR goes back high.
     914:	10 92 01 08 	sts	0x0801, r1
     918:	10 92 00 08 	sts	0x0800, r1
     91c:	02 c0       	rjmp	.+4      	; 0x922 <_Z9CDC_SetupR5Setup+0xaa>

				wdt_disable();
				wdt_reset();
				*(uint16_t *)0x0800 = 0x0;
			}
		}
     91e:	80 e0       	ldi	r24, 0x00	; 0
     920:	08 95       	ret
				// twiggle more than once before stabilizing.
				// To avoid spurious resets we set the watchdog to 250ms and eventually
				// cancel if DTR goes back high.

				wdt_disable();
				wdt_reset();
     922:	81 e0       	ldi	r24, 0x01	; 1
				*(uint16_t *)0x0800 = 0x0;
			}
		}
		return true;
     924:	08 95       	ret

00000926 <_GLOBAL__sub_I__cdcInterface>:
  public:
    Print() : write_error(0) {}
     926:	10 92 87 01 	sts	0x0187, r1
     92a:	10 92 86 01 	sts	0x0186, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
     92e:	88 ee       	ldi	r24, 0xE8	; 232
     930:	93 e0       	ldi	r25, 0x03	; 3
     932:	a0 e0       	ldi	r26, 0x00	; 0
     934:	b0 e0       	ldi	r27, 0x00	; 0
     936:	80 93 88 01 	sts	0x0188, r24
     93a:	90 93 89 01 	sts	0x0189, r25
     93e:	a0 93 8a 01 	sts	0x018A, r26
     942:	b0 93 8b 01 	sts	0x018B, r27

#include "USBDesc.h"
#include "USBCore.h"

//================================================================================
//================================================================================
     946:	8b e2       	ldi	r24, 0x2B	; 43
     948:	91 e0       	ldi	r25, 0x01	; 1
     94a:	90 93 85 01 	sts	0x0185, r25
     94e:	80 93 84 01 	sts	0x0184, r24
     952:	8f ef       	ldi	r24, 0xFF	; 255
     954:	9f ef       	ldi	r25, 0xFF	; 255
     956:	90 93 91 01 	sts	0x0191, r25
     95a:	80 93 90 01 	sts	0x0190, r24
     95e:	08 95       	ret

00000960 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     960:	cf 92       	push	r12
     962:	df 92       	push	r13
     964:	ef 92       	push	r14
     966:	ff 92       	push	r15
     968:	0f 93       	push	r16
     96a:	1f 93       	push	r17
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	6c 01       	movw	r12, r24
     972:	7a 01       	movw	r14, r20
     974:	eb 01       	movw	r28, r22
     976:	e6 0e       	add	r14, r22
     978:	f7 1e       	adc	r15, r23
  size_t n = 0;
     97a:	00 e0       	ldi	r16, 0x00	; 0
     97c:	10 e0       	ldi	r17, 0x00	; 0
  while (size--) {
     97e:	ce 15       	cp	r28, r14
     980:	df 05       	cpc	r29, r15
     982:	61 f0       	breq	.+24     	; 0x99c <_ZN5Print5writeEPKhj+0x3c>
    n += write(*buffer++);
     984:	69 91       	ld	r22, Y+
     986:	d6 01       	movw	r26, r12
     988:	ed 91       	ld	r30, X+
     98a:	fc 91       	ld	r31, X
     98c:	01 90       	ld	r0, Z+
     98e:	f0 81       	ld	r31, Z
     990:	e0 2d       	mov	r30, r0
     992:	c6 01       	movw	r24, r12
     994:	09 95       	icall
     996:	08 0f       	add	r16, r24
     998:	19 1f       	adc	r17, r25
     99a:	f1 cf       	rjmp	.-30     	; 0x97e <_ZN5Print5writeEPKhj+0x1e>
  }
  return n;
}
     99c:	c8 01       	movw	r24, r16
     99e:	df 91       	pop	r29
     9a0:	cf 91       	pop	r28
     9a2:	1f 91       	pop	r17
     9a4:	0f 91       	pop	r16
     9a6:	ff 90       	pop	r15
     9a8:	ef 90       	pop	r14
     9aa:	df 90       	pop	r13
     9ac:	cf 90       	pop	r12
     9ae:	08 95       	ret

000009b0 <_ZL11SendControlh>:
static
bool SendControl(u8 d)
{
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
     9b0:	40 91 d8 01 	lds	r20, 0x01D8
     9b4:	50 91 d9 01 	lds	r21, 0x01D9
     9b8:	20 91 d6 01 	lds	r18, 0x01D6
     9bc:	30 91 d7 01 	lds	r19, 0x01D7
     9c0:	42 17       	cp	r20, r18
     9c2:	53 07       	cpc	r21, r19
     9c4:	b4 f4       	brge	.+44     	; 0x9f2 <_ZL11SendControlh+0x42>

static inline u8 WaitForINOrOUT()
{
	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
		;
	return (UEINTX & (1<<RXOUTI)) == 0;
     9c6:	90 91 e8 00 	lds	r25, 0x00E8
     9ca:	95 70       	andi	r25, 0x05	; 5
     9cc:	e1 f3       	breq	.-8      	; 0x9c6 <_ZL11SendControlh+0x16>
}

     9ce:	90 91 e8 00 	lds	r25, 0x00E8
{
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
     9d2:	92 fd       	sbrc	r25, 2
     9d4:	19 c0       	rjmp	.+50     	; 0xa08 <_ZL11SendControlh+0x58>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

     9d6:	80 93 f1 00 	sts	0x00F1, r24
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
			ClearIN();	// Fifo is full, release this packet
	}
     9da:	80 91 d8 01 	lds	r24, 0x01D8
     9de:	90 91 d9 01 	lds	r25, 0x01D9
     9e2:	01 96       	adiw	r24, 0x01	; 1
     9e4:	8f 73       	andi	r24, 0x3F	; 63
     9e6:	99 27       	eor	r25, r25
     9e8:	89 2b       	or	r24, r25
     9ea:	19 f4       	brne	.+6      	; 0x9f2 <_ZL11SendControlh+0x42>

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
}

     9ec:	8e ef       	ldi	r24, 0xFE	; 254
     9ee:	80 93 e8 00 	sts	0x00E8, r24
		if (!((_cmark + 1) & 0x3F))
			ClearIN();	// Fifo is full, release this packet
	}
	_cmark++;
	return true;
};
     9f2:	80 91 d8 01 	lds	r24, 0x01D8
     9f6:	90 91 d9 01 	lds	r25, 0x01D9
     9fa:	01 96       	adiw	r24, 0x01	; 1
     9fc:	90 93 d9 01 	sts	0x01D9, r25
     a00:	80 93 d8 01 	sts	0x01D8, r24

     a04:	81 e0       	ldi	r24, 0x01	; 1
     a06:	08 95       	ret
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
     a08:	80 e0       	ldi	r24, 0x00	; 0
	}
	_cmark++;
	return true;
};

//	Clipped by _cmark/_cend
     a0a:	08 95       	ret

00000a0c <_ZL24USB_SendStringDescriptorPKhh>:
// Send a USB descriptor string. The string is stored in PROGMEM as a
// plain ASCII string but is sent out as UTF-16 with the correct 2-byte
// prefix
static bool USB_SendStringDescriptor(const u8*string_P, u8 string_len) {
        SendControl(2 + string_len * 2);
        SendControl(3);
     a0c:	cf 92       	push	r12
     a0e:	df 92       	push	r13
     a10:	ff 92       	push	r15
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	1f 92       	push	r1
     a1c:	cd b7       	in	r28, 0x3d	; 61
     a1e:	de b7       	in	r29, 0x3e	; 62
     a20:	08 2f       	mov	r16, r24
     a22:	16 2f       	mov	r17, r22
        for(u8 i = 0; i < string_len; i++) {
     a24:	86 2f       	mov	r24, r22
     a26:	88 0f       	add	r24, r24
     a28:	8e 5f       	subi	r24, 0xFE	; 254
     a2a:	99 83       	std	Y+1, r25	; 0x01
     a2c:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <_ZL11SendControlh>
                bool r = SendControl(pgm_read_byte(&string_P[i]));
     a30:	83 e0       	ldi	r24, 0x03	; 3
     a32:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <_ZL11SendControlh>
     a36:	f0 2e       	mov	r15, r16
                r &= SendControl(0); // high byte
     a38:	c0 2e       	mov	r12, r16
     a3a:	99 81       	ldd	r25, Y+1	; 0x01
     a3c:	d9 2e       	mov	r13, r25
     a3e:	8c 2d       	mov	r24, r12
     a40:	8f 19       	sub	r24, r15
     a42:	81 17       	cp	r24, r17
     a44:	78 f4       	brcc	.+30     	; 0xa64 <_ZL24USB_SendStringDescriptorPKhh+0x58>
                if(!r) {
     a46:	f6 01       	movw	r30, r12
     a48:	84 91       	lpm	r24, Z
     a4a:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <_ZL11SendControlh>
     a4e:	08 2f       	mov	r16, r24
                        return false;
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <_ZL11SendControlh>
     a56:	80 23       	and	r24, r16
     a58:	ff ef       	ldi	r31, 0xFF	; 255
     a5a:	cf 1a       	sub	r12, r31
     a5c:	df 0a       	sbc	r13, r31
                }
     a5e:	81 11       	cpse	r24, r1
     a60:	ee cf       	rjmp	.-36     	; 0xa3e <_ZL24USB_SendStringDescriptorPKhh+0x32>
     a62:	01 c0       	rjmp	.+2      	; 0xa66 <_ZL24USB_SendStringDescriptorPKhh+0x5a>
        }
        return true;
}

     a64:	81 e0       	ldi	r24, 0x01	; 1
//	Does not timeout or cross fifo boundaries
     a66:	0f 90       	pop	r0
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	1f 91       	pop	r17
     a6e:	0f 91       	pop	r16
     a70:	ff 90       	pop	r15
     a72:	df 90       	pop	r13
     a74:	cf 90       	pop	r12
     a76:	08 95       	ret

00000a78 <_Z4RecvPVhh>:

void Recv(volatile u8* data, u8 count)
{
	while (count--)
		*data++ = UEDATX;
	
     a78:	61 50       	subi	r22, 0x01	; 1
     a7a:	30 f0       	brcs	.+12     	; 0xa88 <_Z4RecvPVhh+0x10>
	RXLED1;					// light the RX LED
     a7c:	20 91 f1 00 	lds	r18, 0x00F1
     a80:	fc 01       	movw	r30, r24
     a82:	20 83       	st	Z, r18
     a84:	01 96       	adiw	r24, 0x01	; 1
     a86:	f8 cf       	rjmp	.-16     	; 0xa78 <_Z4RecvPVhh>
	RxLEDPulse = TX_RX_LED_PULSE_MS;	
}
     a88:	28 98       	cbi	0x05, 0	; 5

     a8a:	84 e6       	ldi	r24, 0x64	; 100
     a8c:	80 93 db 01 	sts	0x01DB, r24
     a90:	08 95       	ret

00000a92 <_ZN6LockEPC1Eh>:
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
	{
		cli();
     a92:	2f b7       	in	r18, 0x3f	; 63
     a94:	fc 01       	movw	r30, r24
     a96:	20 83       	st	Z, r18
		SetEP(ep & 7);
	}
     a98:	f8 94       	cli
	~LockEP()
     a9a:	67 70       	andi	r22, 0x07	; 7

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

     a9c:	60 93 e9 00 	sts	0x00E9, r22
     aa0:	08 95       	ret

00000aa2 <_Z13USB_Availableh>:

//	Number of bytes, assumes a rx endpoint
u8 USB_Available(u8 ep)
{
	LockEP lock(ep);
	return FifoByteCount();
     aa2:	cf 93       	push	r28
     aa4:	df 93       	push	r29
     aa6:	1f 92       	push	r1
     aa8:	cd b7       	in	r28, 0x3d	; 61
     aaa:	de b7       	in	r29, 0x3e	; 62
}
     aac:	68 2f       	mov	r22, r24
     aae:	ce 01       	movw	r24, r28
     ab0:	01 96       	adiw	r24, 0x01	; 1
     ab2:	0e 94 49 05 	call	0xa92	; 0xa92 <_ZN6LockEPC1Eh>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

     ab6:	80 91 f2 00 	lds	r24, 0x00F2
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
     aba:	99 81       	ldd	r25, Y+1	; 0x01
     abc:	9f bf       	out	0x3f, r25	; 63
{
	LockEP lock(ep);
	return FifoByteCount();
}

//	Non Blocking receive
     abe:	0f 90       	pop	r0
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	08 95       	ret

00000ac6 <_Z8USB_RecvhPvi>:
//	Return number of bytes read
int USB_Recv(u8 ep, void* d, int len)
{
	if (!_usbConfiguration || len < 0)
		return -1;
     ac6:	ff 92       	push	r15
     ac8:	0f 93       	push	r16
     aca:	1f 93       	push	r17
     acc:	cf 93       	push	r28
     ace:	df 93       	push	r29
     ad0:	00 d0       	rcall	.+0      	; 0xad2 <_Z8USB_RecvhPvi+0xc>
     ad2:	cd b7       	in	r28, 0x3d	; 61
     ad4:	de b7       	in	r29, 0x3e	; 62
     ad6:	f6 2e       	mov	r15, r22
     ad8:	8a 01       	movw	r16, r20
	
     ada:	90 91 da 01 	lds	r25, 0x01DA
     ade:	99 23       	and	r25, r25
     ae0:	11 f0       	breq	.+4      	; 0xae6 <_Z8USB_RecvhPvi+0x20>
     ae2:	57 ff       	sbrs	r21, 7
     ae4:	03 c0       	rjmp	.+6      	; 0xaec <_Z8USB_RecvhPvi+0x26>
	LockEP lock(ep);
     ae6:	8f ef       	ldi	r24, 0xFF	; 255
     ae8:	9f ef       	ldi	r25, 0xFF	; 255
     aea:	2b c0       	rjmp	.+86     	; 0xb42 <__stack+0x43>
	u8 n = FifoByteCount();
	len = min(n,len);
     aec:	68 2f       	mov	r22, r24
     aee:	ce 01       	movw	r24, r28
     af0:	01 96       	adiw	r24, 0x01	; 1
     af2:	7a 83       	std	Y+2, r23	; 0x02
     af4:	0e 94 49 05 	call	0xa92	; 0xa92 <_ZN6LockEPC1Eh>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

     af8:	80 91 f2 00 	lds	r24, 0x00F2
	
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	a8 01       	movw	r20, r16
     b00:	7a 81       	ldd	r23, Y+2	; 0x02
     b02:	80 17       	cp	r24, r16
     b04:	91 07       	cpc	r25, r17
     b06:	0c f4       	brge	.+2      	; 0xb0a <__stack+0xb>
     b08:	ac 01       	movw	r20, r24
     b0a:	ef 2d       	mov	r30, r15
     b0c:	f7 2f       	mov	r31, r23
     b0e:	f4 0e       	add	r15, r20
static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;

	return UEDATX;	
     b10:	84 e6       	ldi	r24, 0x64	; 100
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
     b12:	fe 16       	cp	r15, r30
     b14:	39 f0       	breq	.+14     	; 0xb24 <__stack+0x25>

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;

     b16:	28 98       	cbi	0x05, 0	; 5
	return UEDATX;	
     b18:	80 93 db 01 	sts	0x01DB, r24
}

     b1c:	90 91 f1 00 	lds	r25, 0x00F1
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
		ReleaseRX();
     b20:	91 93       	st	Z+, r25
     b22:	f7 cf       	rjmp	.-18     	; 0xb12 <__stack+0x13>
	
     b24:	41 15       	cp	r20, r1
     b26:	51 05       	cpc	r21, r1
     b28:	21 f0       	breq	.+8      	; 0xb32 <__stack+0x33>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

     b2a:	80 91 f2 00 	lds	r24, 0x00F2
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
		ReleaseRX();
	
     b2e:	88 23       	and	r24, r24
     b30:	21 f0       	breq	.+8      	; 0xb3a <__stack+0x3b>
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
     b32:	89 81       	ldd	r24, Y+1	; 0x01
     b34:	8f bf       	out	0x3f, r24	; 63
	
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
     b36:	ca 01       	movw	r24, r20
     b38:	04 c0       	rjmp	.+8      	; 0xb42 <__stack+0x43>

static inline void ReleaseRX()
{
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

     b3a:	8b e6       	ldi	r24, 0x6B	; 107
     b3c:	80 93 e8 00 	sts	0x00E8, r24
     b40:	f8 cf       	rjmp	.-16     	; 0xb32 <__stack+0x33>
		ReleaseRX();
	
	return len;
}

//	Recv 1 byte if ready
     b42:	0f 90       	pop	r0
     b44:	0f 90       	pop	r0
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	1f 91       	pop	r17
     b4c:	0f 91       	pop	r16
     b4e:	ff 90       	pop	r15
     b50:	08 95       	ret

00000b52 <_Z8USB_Recvh>:
int USB_Recv(u8 ep)
{
	u8 c;
	if (USB_Recv(ep,&c,1) != 1)
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	1f 92       	push	r1
     b58:	cd b7       	in	r28, 0x3d	; 61
     b5a:	de b7       	in	r29, 0x3e	; 62
		return -1;
	return c;
     b5c:	41 e0       	ldi	r20, 0x01	; 1
     b5e:	50 e0       	ldi	r21, 0x00	; 0
     b60:	be 01       	movw	r22, r28
     b62:	6f 5f       	subi	r22, 0xFF	; 255
     b64:	7f 4f       	sbci	r23, 0xFF	; 255
     b66:	0e 94 63 05 	call	0xac6	; 0xac6 <_Z8USB_RecvhPvi>
     b6a:	01 97       	sbiw	r24, 0x01	; 1
     b6c:	19 f4       	brne	.+6      	; 0xb74 <_Z8USB_Recvh+0x22>
}

     b6e:	89 81       	ldd	r24, Y+1	; 0x01
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	02 c0       	rjmp	.+4      	; 0xb78 <_Z8USB_Recvh+0x26>
{
	u8 c;
	if (USB_Recv(ep,&c,1) != 1)
		return -1;
	return c;
}
     b74:	8f ef       	ldi	r24, 0xFF	; 255
     b76:	9f ef       	ldi	r25, 0xFF	; 255

//	Space in send EP
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_Z13USB_SendSpaceh>:
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	1f 92       	push	r1
     b86:	cd b7       	in	r28, 0x3d	; 61
     b88:	de b7       	in	r29, 0x3e	; 62
		return 0;
     b8a:	68 2f       	mov	r22, r24
     b8c:	ce 01       	movw	r24, r28
     b8e:	01 96       	adiw	r24, 0x01	; 1
     b90:	0e 94 49 05 	call	0xa92	; 0xa92 <_ZN6LockEPC1Eh>

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
}

     b94:	90 91 e8 00 	lds	r25, 0x00E8
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
     b98:	89 2f       	mov	r24, r25
     b9a:	80 72       	andi	r24, 0x20	; 32
     b9c:	95 ff       	sbrs	r25, 5
     b9e:	04 c0       	rjmp	.+8      	; 0xba8 <_Z13USB_SendSpaceh+0x28>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

     ba0:	90 91 f2 00 	lds	r25, 0x00F2
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
}

     ba4:	80 e4       	ldi	r24, 0x40	; 64
     ba6:	89 1b       	sub	r24, r25
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
     ba8:	99 81       	ldd	r25, Y+1	; 0x01
     baa:	9f bf       	out	0x3f, r25	; 63
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
}

//	Blocking Send of data to an endpoint
     bac:	0f 90       	pop	r0
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <_Z8USB_SendhPKvi>:
int USB_Send(u8 ep, const void* d, int len)
{
	if (!_usbConfiguration)
		return -1;
     bb4:	6f 92       	push	r6
     bb6:	7f 92       	push	r7
     bb8:	8f 92       	push	r8
     bba:	9f 92       	push	r9
     bbc:	af 92       	push	r10
     bbe:	bf 92       	push	r11
     bc0:	cf 92       	push	r12
     bc2:	df 92       	push	r13
     bc4:	ef 92       	push	r14
     bc6:	ff 92       	push	r15
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	1f 92       	push	r1
     bd2:	cd b7       	in	r28, 0x3d	; 61
     bd4:	de b7       	in	r29, 0x3e	; 62
     bd6:	78 2e       	mov	r7, r24
     bd8:	7b 01       	movw	r14, r22
     bda:	c4 2e       	mov	r12, r20
     bdc:	b5 2e       	mov	r11, r21

     bde:	80 91 da 01 	lds	r24, 0x01DA
     be2:	88 23       	and	r24, r24
     be4:	69 f0       	breq	.+26     	; 0xc00 <_Z8USB_SendhPKvi+0x4c>
     be6:	04 2f       	mov	r16, r20
     be8:	15 2f       	mov	r17, r21
     bea:	8a ef       	ldi	r24, 0xFA	; 250
     bec:	d8 2e       	mov	r13, r24
			if (!ReadWriteAllowed())
				continue;
			len -= n;
			if (ep & TRANSFER_ZERO)
			{
				while (n--)
     bee:	87 2d       	mov	r24, r7
     bf0:	80 72       	andi	r24, 0x20	; 32
     bf2:	98 2e       	mov	r9, r24

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
}

     bf4:	9a e3       	ldi	r25, 0x3A	; 58
     bf6:	a9 2e       	mov	r10, r25
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
				ReleaseTX();
		}
     bf8:	87 2d       	mov	r24, r7
     bfa:	80 74       	andi	r24, 0x40	; 64
     bfc:	88 2e       	mov	r8, r24
     bfe:	11 c0       	rjmp	.+34     	; 0xc22 <_Z8USB_SendhPKvi+0x6e>
int USB_Send(u8 ep, const void* d, int len)
{
	if (!_usbConfiguration)
		return -1;

	int r = len;
     c00:	8f ef       	ldi	r24, 0xFF	; 255
     c02:	9f ef       	ldi	r25, 0xFF	; 255
     c04:	57 c0       	rjmp	.+174    	; 0xcb4 <_Z8USB_SendhPKvi+0x100>
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
	{
		u8 n = USB_SendSpace(ep);
		if (n == 0)
		{
     c06:	87 2d       	mov	r24, r7
     c08:	0e 94 c0 05 	call	0xb80	; 0xb80 <_Z13USB_SendSpaceh>
     c0c:	68 2e       	mov	r6, r24
			if (!(--timeout))
     c0e:	81 11       	cpse	r24, r1
     c10:	0c c0       	rjmp	.+24     	; 0xc2a <_Z8USB_SendhPKvi+0x76>
				return -1;
			delay(1);
     c12:	da 94       	dec	r13
     c14:	a9 f3       	breq	.-22     	; 0xc00 <_Z8USB_SendhPKvi+0x4c>
			continue;
		}
     c16:	61 e0       	ldi	r22, 0x01	; 1
     c18:	70 e0       	ldi	r23, 0x00	; 0
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	0e 94 25 03 	call	0x64a	; 0x64a <delay>
	int r = len;
	const u8* data = (const u8*)d;
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
	{
		u8 n = USB_SendSpace(ep);
     c22:	01 15       	cp	r16, r1
     c24:	11 05       	cpc	r17, r1
     c26:	79 f7       	brne	.-34     	; 0xc06 <_Z8USB_SendhPKvi+0x52>
     c28:	3b c0       	rjmp	.+118    	; 0xca0 <_Z8USB_SendhPKvi+0xec>
			continue;
		}

		if (n > len)
			n = len;
		{
     c2a:	28 2f       	mov	r18, r24
     c2c:	30 e0       	ldi	r19, 0x00	; 0
     c2e:	02 17       	cp	r16, r18
     c30:	13 07       	cpc	r17, r19
     c32:	0c f4       	brge	.+2      	; 0xc36 <_Z8USB_SendhPKvi+0x82>
			LockEP lock(ep);
     c34:	60 2e       	mov	r6, r16
			// Frame may have been released by the SOF interrupt handler
			if (!ReadWriteAllowed())
     c36:	67 2d       	mov	r22, r7
     c38:	ce 01       	movw	r24, r28
     c3a:	01 96       	adiw	r24, 0x01	; 1
     c3c:	0e 94 49 05 	call	0xa92	; 0xa92 <_ZN6LockEPC1Eh>

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
}

     c40:	80 91 e8 00 	lds	r24, 0x00E8
		{
			LockEP lock(ep);
			// Frame may have been released by the SOF interrupt handler
			if (!ReadWriteAllowed())
				continue;
			len -= n;
     c44:	85 ff       	sbrs	r24, 5
     c46:	29 c0       	rjmp	.+82     	; 0xc9a <_Z8USB_SendhPKvi+0xe6>
			if (ep & TRANSFER_ZERO)
			{
     c48:	26 2d       	mov	r18, r6
     c4a:	30 e0       	ldi	r19, 0x00	; 0
     c4c:	02 1b       	sub	r16, r18
     c4e:	13 0b       	sbc	r17, r19
				while (n--)
     c50:	99 20       	and	r9, r9
     c52:	39 f0       	breq	.+14     	; 0xc62 <_Z8USB_SendhPKvi+0xae>
					Send8(0);
			}
     c54:	6a 94       	dec	r6
     c56:	8f ef       	ldi	r24, 0xFF	; 255
     c58:	68 16       	cp	r6, r24
     c5a:	b1 f0       	breq	.+44     	; 0xc88 <_Z8USB_SendhPKvi+0xd4>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

     c5c:	10 92 f1 00 	sts	0x00F1, r1
     c60:	f9 cf       	rjmp	.-14     	; 0xc54 <_Z8USB_SendhPKvi+0xa0>
				while (n--)
					Send8(0);
			}
			else if (ep & TRANSFER_PGM)
			{
				while (n--)
     c62:	f7 01       	movw	r30, r14
     c64:	86 2d       	mov	r24, r6
     c66:	77 fe       	sbrs	r7, 7
     c68:	07 c0       	rjmp	.+14     	; 0xc78 <_Z8USB_SendhPKvi+0xc4>
					Send8(pgm_read_byte(data++));
			}
     c6a:	81 50       	subi	r24, 0x01	; 1
     c6c:	58 f0       	brcs	.+22     	; 0xc84 <_Z8USB_SendhPKvi+0xd0>
			else
     c6e:	94 91       	lpm	r25, Z

static inline void Send8(u8 d)
{
	UEDATX = d;
}

     c70:	90 93 f1 00 	sts	0x00F1, r25
     c74:	31 96       	adiw	r30, 0x01	; 1
     c76:	f9 cf       	rjmp	.-14     	; 0xc6a <_Z8USB_SendhPKvi+0xb6>
			}
			else
			{
				while (n--)
					Send8(*data++);
			}
     c78:	81 50       	subi	r24, 0x01	; 1
     c7a:	20 f0       	brcs	.+8      	; 0xc84 <_Z8USB_SendhPKvi+0xd0>
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
     c7c:	91 91       	ld	r25, Z+

static inline void Send8(u8 d)
{
	UEDATX = d;
}

     c7e:	90 93 f1 00 	sts	0x00F1, r25
     c82:	fa cf       	rjmp	.-12     	; 0xc78 <_Z8USB_SendhPKvi+0xc4>
     c84:	e2 0e       	add	r14, r18
     c86:	f3 1e       	adc	r15, r19

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
}

     c88:	80 91 e8 00 	lds	r24, 0x00E8
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
				ReleaseTX();
		}
     c8c:	85 ff       	sbrs	r24, 5
     c8e:	0f c0       	rjmp	.+30     	; 0xcae <_Z8USB_SendhPKvi+0xfa>
     c90:	01 15       	cp	r16, r1
     c92:	11 05       	cpc	r17, r1
     c94:	11 f4       	brne	.+4      	; 0xc9a <_Z8USB_SendhPKvi+0xe6>
     c96:	81 10       	cpse	r8, r1
     c98:	0a c0       	rjmp	.+20     	; 0xcae <_Z8USB_SendhPKvi+0xfa>
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
     c9a:	89 81       	ldd	r24, Y+1	; 0x01
     c9c:	8f bf       	out	0x3f, r24	; 63
     c9e:	c1 cf       	rjmp	.-126    	; 0xc22 <_Z8USB_SendhPKvi+0x6e>
				ReleaseTX();
		}
	}
	TXLED1;					// light the TX LED
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	return r;
     ca0:	5d 98       	cbi	0x0b, 5	; 11
}
     ca2:	84 e6       	ldi	r24, 0x64	; 100
     ca4:	80 93 dc 01 	sts	0x01DC, r24

     ca8:	8c 2d       	mov	r24, r12
     caa:	9b 2d       	mov	r25, r11
     cac:	03 c0       	rjmp	.+6      	; 0xcb4 <_Z8USB_SendhPKvi+0x100>

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
}

     cae:	a0 92 e8 00 	sts	0x00E8, r10
     cb2:	f3 cf       	rjmp	.-26     	; 0xc9a <_Z8USB_SendhPKvi+0xe6>
	TXLED1;					// light the TX LED
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	return r;
}

extern const u8 _initEndpoints[] PROGMEM;
     cb4:	0f 90       	pop	r0
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	1f 91       	pop	r17
     cbc:	0f 91       	pop	r16
     cbe:	ff 90       	pop	r15
     cc0:	ef 90       	pop	r14
     cc2:	df 90       	pop	r13
     cc4:	cf 90       	pop	r12
     cc6:	bf 90       	pop	r11
     cc8:	af 90       	pop	r10
     cca:	9f 90       	pop	r9
     ccc:	8f 90       	pop	r8
     cce:	7f 90       	pop	r7
     cd0:	6f 90       	pop	r6
     cd2:	08 95       	ret

00000cd4 <_Z11InitControli>:

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

     cd4:	10 92 e9 00 	sts	0x00E9, r1
void InitControl(int end)
{
	SetEP(0);
	_cmark = 0;
	_cend = end;
}
     cd8:	10 92 d9 01 	sts	0x01D9, r1
     cdc:	10 92 d8 01 	sts	0x01D8, r1

     ce0:	90 93 d7 01 	sts	0x01D7, r25
     ce4:	80 93 d6 01 	sts	0x01D6, r24
     ce8:	08 95       	ret

00000cea <_Z15USB_SendControlhPKvi>:

//	Clipped by _cmark/_cend
int USB_SendControl(u8 flags, const void* d, int len)
{
	int sent = len;
	const u8* data = (const u8*)d;
     cea:	cf 92       	push	r12
     cec:	df 92       	push	r13
     cee:	ff 92       	push	r15
     cf0:	0f 93       	push	r16
     cf2:	1f 93       	push	r17
     cf4:	cf 93       	push	r28
     cf6:	df 93       	push	r29
     cf8:	00 d0       	rcall	.+0      	; 0xcfa <_Z15USB_SendControlhPKvi+0x10>
     cfa:	cd b7       	in	r28, 0x3d	; 61
     cfc:	de b7       	in	r29, 0x3e	; 62
     cfe:	f8 2e       	mov	r15, r24
     d00:	8a 01       	movw	r16, r20
	bool pgm = flags & TRANSFER_PGM;
	while (len--)
	{
		u8 c = pgm ? pgm_read_byte(data++) : *data++;
     d02:	6b 01       	movw	r12, r22
     d04:	01 15       	cp	r16, r1
     d06:	11 05       	cpc	r17, r1
     d08:	b1 f0       	breq	.+44     	; 0xd36 <_Z15USB_SendControlhPKvi+0x4c>
		if (!SendControl(c))
			return -1;
     d0a:	f6 01       	movw	r30, r12
     d0c:	f7 fe       	sbrs	r15, 7
     d0e:	02 c0       	rjmp	.+4      	; 0xd14 <_Z15USB_SendControlhPKvi+0x2a>
     d10:	84 91       	lpm	r24, Z
     d12:	01 c0       	rjmp	.+2      	; 0xd16 <_Z15USB_SendControlhPKvi+0x2c>
     d14:	80 81       	ld	r24, Z
	}
     d16:	49 83       	std	Y+1, r20	; 0x01
     d18:	5a 83       	std	Y+2, r21	; 0x02
     d1a:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <_ZL11SendControlh>
     d1e:	01 50       	subi	r16, 0x01	; 1
     d20:	11 09       	sbc	r17, r1
     d22:	ff ef       	ldi	r31, 0xFF	; 255
     d24:	cf 1a       	sub	r12, r31
     d26:	df 0a       	sbc	r13, r31
     d28:	49 81       	ldd	r20, Y+1	; 0x01
     d2a:	5a 81       	ldd	r21, Y+2	; 0x02
     d2c:	81 11       	cpse	r24, r1
     d2e:	ea cf       	rjmp	.-44     	; 0xd04 <_Z15USB_SendControlhPKvi+0x1a>
	return sent;
     d30:	8f ef       	ldi	r24, 0xFF	; 255
     d32:	9f ef       	ldi	r25, 0xFF	; 255
     d34:	01 c0       	rjmp	.+2      	; 0xd38 <_Z15USB_SendControlhPKvi+0x4e>
}

     d36:	ca 01       	movw	r24, r20
// Send a USB descriptor string. The string is stored in PROGMEM as a
     d38:	0f 90       	pop	r0
     d3a:	0f 90       	pop	r0
     d3c:	df 91       	pop	r29
     d3e:	cf 91       	pop	r28
     d40:	1f 91       	pop	r17
     d42:	0f 91       	pop	r16
     d44:	ff 90       	pop	r15
     d46:	df 90       	pop	r13
     d48:	cf 90       	pop	r12
     d4a:	08 95       	ret

00000d4c <_Z15USB_RecvControlPvi>:
//	Will only work for transfers <= 64 bytes
//	TODO
int USB_RecvControl(void* d, int len)
{
	WaitOUT();
	Recv((u8*)d,len);
     d4c:	1f 93       	push	r17
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
     d52:	1f 92       	push	r1
     d54:	cd b7       	in	r28, 0x3d	; 61
     d56:	de b7       	in	r29, 0x3e	; 62
     d58:	16 2f       	mov	r17, r22

static inline void WaitOUT(void)
{
	while (!(UEINTX & (1<<RXOUTI)))
		;
}
     d5a:	20 91 e8 00 	lds	r18, 0x00E8
     d5e:	22 ff       	sbrs	r18, 2
     d60:	fc cf       	rjmp	.-8      	; 0xd5a <_Z15USB_RecvControlPvi+0xe>
int USB_RecvControl(void* d, int len)
{
	WaitOUT();
	Recv((u8*)d,len);
	ClearOUT();
	return len;
     d62:	61 2f       	mov	r22, r17
     d64:	79 83       	std	Y+1, r23	; 0x01
     d66:	0e 94 3c 05 	call	0xa78	; 0xa78 <_Z4RecvPVhh>

static inline void ClearOUT(void)
{
	UEINTX = ~(1<<RXOUTI);
}

     d6a:	8b ef       	ldi	r24, 0xFB	; 251
     d6c:	80 93 e8 00 	sts	0x00E8, r24
	Recv((u8*)d,len);
	ClearOUT();
	return len;
}

int SendInterfaces()
     d70:	81 2f       	mov	r24, r17
     d72:	79 81       	ldd	r23, Y+1	; 0x01
     d74:	97 2f       	mov	r25, r23
     d76:	0f 90       	pop	r0
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	1f 91       	pop	r17
     d7e:	08 95       	ret

00000d80 <_Z14SendInterfacesv>:
{
	int total = 0;
	u8 interfaces = 0;
     d80:	cf 93       	push	r28
     d82:	df 93       	push	r29
     d84:	1f 92       	push	r1
     d86:	cd b7       	in	r28, 0x3d	; 61
     d88:	de b7       	in	r29, 0x3e	; 62

#ifdef CDC_ENABLED
     d8a:	19 82       	std	Y+1, r1	; 0x01
	total = CDC_GetInterface(&interfaces);
#endif

     d8c:	ce 01       	movw	r24, r28
     d8e:	01 96       	adiw	r24, 0x01	; 1
     d90:	0e 94 31 04 	call	0x862	; 0x862 <_Z16CDC_GetInterfacePh>
#ifdef HID_ENABLED
	total += HID_GetInterface(&interfaces);
#endif

     d94:	ce 01       	movw	r24, r28
     d96:	01 96       	adiw	r24, 0x01	; 1
     d98:	0e 94 9b 08 	call	0x1136	; 0x1136 <_Z16HID_GetInterfacePh>
	return interfaces;
}

     d9c:	89 81       	ldd	r24, Y+1	; 0x01
//	Construct a dynamic configuration descriptor
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	0f 90       	pop	r0
     da2:	df 91       	pop	r29
     da4:	cf 91       	pop	r28
     da6:	08 95       	ret

00000da8 <__vector_11>:

//	Endpoint 0 interrupt
ISR(USB_COM_vect)
{
    SetEP(0);
	if (!ReceivedSetupInt())
     da8:	1f 92       	push	r1
     daa:	0f 92       	push	r0
     dac:	0f b6       	in	r0, 0x3f	; 63
     dae:	0f 92       	push	r0
     db0:	11 24       	eor	r1, r1
     db2:	ef 92       	push	r14
     db4:	ff 92       	push	r15
     db6:	0f 93       	push	r16
     db8:	1f 93       	push	r17
     dba:	2f 93       	push	r18
     dbc:	3f 93       	push	r19
     dbe:	4f 93       	push	r20
     dc0:	5f 93       	push	r21
     dc2:	6f 93       	push	r22
     dc4:	7f 93       	push	r23
     dc6:	8f 93       	push	r24
     dc8:	9f 93       	push	r25
     dca:	af 93       	push	r26
     dcc:	bf 93       	push	r27
     dce:	ef 93       	push	r30
     dd0:	ff 93       	push	r31
     dd2:	cf 93       	push	r28
     dd4:	df 93       	push	r29
     dd6:	cd b7       	in	r28, 0x3d	; 61
     dd8:	de b7       	in	r29, 0x3e	; 62
     dda:	62 97       	sbiw	r28, 0x12	; 18
     ddc:	de bf       	out	0x3e, r29	; 62
     dde:	cd bf       	out	0x3d, r28	; 61

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

     de0:	10 92 e9 00 	sts	0x00E9, r1

static inline u8 ReceivedSetupInt()
{
	return UEINTX & (1<<RXSTPI);
}

     de4:	80 91 e8 00 	lds	r24, 0x00E8
ISR(USB_COM_vect)
{
    SetEP(0);
	if (!ReceivedSetupInt())
		return;

     de8:	83 ff       	sbrs	r24, 3
     dea:	eb c0       	rjmp	.+470    	; 0xfc2 <__vector_11+0x21a>
	Setup setup;
	Recv((u8*)&setup,8);
	ClearSetupInt();

     dec:	68 e0       	ldi	r22, 0x08	; 8
     dee:	ce 01       	movw	r24, r28
     df0:	0a 96       	adiw	r24, 0x0a	; 10
     df2:	0e 94 3c 05 	call	0xa78	; 0xa78 <_Z4RecvPVhh>

static inline void ClearSetupInt()
{
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
}

     df6:	82 ef       	ldi	r24, 0xF2	; 242
     df8:	80 93 e8 00 	sts	0x00E8, r24
	Recv((u8*)&setup,8);
	ClearSetupInt();

	u8 requestType = setup.bmRequestType;
	if (requestType & REQUEST_DEVICETOHOST)
		WaitIN();
     dfc:	9a 85       	ldd	r25, Y+10	; 0x0a
	else
     dfe:	97 ff       	sbrs	r25, 7
     e00:	05 c0       	rjmp	.+10     	; 0xe0c <__vector_11+0x64>

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)))
		;
}
     e02:	80 91 e8 00 	lds	r24, 0x00E8
     e06:	80 ff       	sbrs	r24, 0
     e08:	fc cf       	rjmp	.-8      	; 0xe02 <__vector_11+0x5a>
     e0a:	03 c0       	rjmp	.+6      	; 0xe12 <__vector_11+0x6a>

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
}

     e0c:	8e ef       	ldi	r24, 0xFE	; 254
     e0e:	80 93 e8 00 	sts	0x00E8, r24
		ClearIN();

    bool ok = true;
	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
	{
		//	Standard Requests
     e12:	89 2f       	mov	r24, r25
     e14:	80 76       	andi	r24, 0x60	; 96
     e16:	09 f0       	breq	.+2      	; 0xe1a <__vector_11+0x72>
     e18:	b9 c0       	rjmp	.+370    	; 0xf8c <__vector_11+0x1e4>
		u8 r = setup.bRequest;
		if (GET_STATUS == r)
		{
     e1a:	8b 85       	ldd	r24, Y+11	; 0x0b
			Send8(0);		// TODO
     e1c:	81 11       	cpse	r24, r1
     e1e:	05 c0       	rjmp	.+10     	; 0xe2a <__vector_11+0x82>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

     e20:	10 92 f1 00 	sts	0x00F1, r1
     e24:	10 92 f1 00 	sts	0x00F1, r1
     e28:	c5 c0       	rjmp	.+394    	; 0xfb4 <__vector_11+0x20c>
			Send8(0);		// TODO
			Send8(0);
		}
		else if (CLEAR_FEATURE == r)
		{
		}
     e2a:	28 2f       	mov	r18, r24
     e2c:	2d 7f       	andi	r18, 0xFD	; 253
     e2e:	21 30       	cpi	r18, 0x01	; 1
     e30:	09 f4       	brne	.+2      	; 0xe34 <__vector_11+0x8c>
     e32:	c0 c0       	rjmp	.+384    	; 0xfb4 <__vector_11+0x20c>
		else if (SET_FEATURE == r)
		{
		}
		else if (SET_ADDRESS == r)
		{
			WaitIN();
     e34:	85 30       	cpi	r24, 0x05	; 5
     e36:	49 f4       	brne	.+18     	; 0xe4a <__vector_11+0xa2>

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)))
		;
}
     e38:	80 91 e8 00 	lds	r24, 0x00E8
     e3c:	80 ff       	sbrs	r24, 0
     e3e:	fc cf       	rjmp	.-8      	; 0xe38 <__vector_11+0x90>
		else if (SET_ADDRESS == r)
		{
			WaitIN();
			UDADDR = setup.wValueL | (1<<ADDEN);
		}
		else if (GET_DESCRIPTOR == r)
     e40:	8c 85       	ldd	r24, Y+12	; 0x0c
     e42:	80 68       	ori	r24, 0x80	; 128
     e44:	80 93 e3 00 	sts	0x00E3, r24
     e48:	b5 c0       	rjmp	.+362    	; 0xfb4 <__vector_11+0x20c>
		{
			ok = SendDescriptor(setup);
     e4a:	86 30       	cpi	r24, 0x06	; 6
     e4c:	09 f0       	breq	.+2      	; 0xe50 <__vector_11+0xa8>
     e4e:	76 c0       	rjmp	.+236    	; 0xf3c <__vector_11+0x194>
static
bool SendDescriptor(Setup& setup)
{
	u8 t = setup.wValueH;
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
		return SendConfiguration(setup.wLength);
     e50:	2d 85       	ldd	r18, Y+13	; 0x0d
     e52:	e8 88       	ldd	r14, Y+16	; 0x10
     e54:	f9 88       	ldd	r15, Y+17	; 0x11

     e56:	22 30       	cpi	r18, 0x02	; 2
     e58:	71 f5       	brne	.+92     	; 0xeb6 <__vector_11+0x10e>
bool SendConfiguration(int maxlen)
{
	//	Count and measure interfaces
	InitControl(0);	
	int interfaces = SendInterfaces();
	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	2a 8b       	std	Y+18, r18	; 0x12
     e60:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <_Z11InitControli>

     e64:	0e 94 c0 06 	call	0xd80	; 0xd80 <_Z14SendInterfacesv>
	//	Now send them
     e68:	99 e0       	ldi	r25, 0x09	; 9
     e6a:	8e 01       	movw	r16, r28
     e6c:	0f 5f       	subi	r16, 0xFF	; 255
     e6e:	1f 4f       	sbci	r17, 0xFF	; 255
     e70:	f8 01       	movw	r30, r16
     e72:	39 2f       	mov	r19, r25
     e74:	11 92       	st	Z+, r1
     e76:	3a 95       	dec	r19
     e78:	e9 f7       	brne	.-6      	; 0xe74 <__vector_11+0xcc>
     e7a:	99 83       	std	Y+1, r25	; 0x01
     e7c:	2a 89       	ldd	r18, Y+18	; 0x12
     e7e:	2a 83       	std	Y+2, r18	; 0x02
     e80:	91 e0       	ldi	r25, 0x01	; 1
     e82:	9e 83       	std	Y+6, r25	; 0x06
     e84:	90 e8       	ldi	r25, 0x80	; 128
     e86:	98 87       	std	Y+8, r25	; 0x08
     e88:	9a ef       	ldi	r25, 0xFA	; 250
     e8a:	99 87       	std	Y+9, r25	; 0x09
     e8c:	20 91 d8 01 	lds	r18, 0x01D8
     e90:	30 91 d9 01 	lds	r19, 0x01D9
     e94:	27 5f       	subi	r18, 0xF7	; 247
     e96:	3f 4f       	sbci	r19, 0xFF	; 255
     e98:	3c 83       	std	Y+4, r19	; 0x04
     e9a:	2b 83       	std	Y+3, r18	; 0x03
     e9c:	8d 83       	std	Y+5, r24	; 0x05
	InitControl(maxlen);
	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
	SendInterfaces();
     e9e:	c7 01       	movw	r24, r14
     ea0:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <_Z11InitControli>
	return true;
     ea4:	49 e0       	ldi	r20, 0x09	; 9
     ea6:	50 e0       	ldi	r21, 0x00	; 0
     ea8:	b8 01       	movw	r22, r16
     eaa:	80 e0       	ldi	r24, 0x00	; 0
     eac:	0e 94 75 06 	call	0xcea	; 0xcea <_Z15USB_SendControlhPKvi>
}
     eb0:	0e 94 c0 06 	call	0xd80	; 0xd80 <_Z14SendInterfacesv>
     eb4:	7f c0       	rjmp	.+254    	; 0xfb4 <__vector_11+0x20c>
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
		return SendConfiguration(setup.wLength);

	InitControl(setup.wLength);
#ifdef HID_ENABLED
	if (HID_REPORT_DESCRIPTOR_TYPE == t)
     eb6:	c7 01       	movw	r24, r14
     eb8:	2a 8b       	std	Y+18, r18	; 0x12
     eba:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <_Z11InitControli>
		return HID_GetDescriptor(t);
#endif
     ebe:	2a 89       	ldd	r18, Y+18	; 0x12
     ec0:	22 32       	cpi	r18, 0x22	; 34
     ec2:	41 f4       	brne	.+16     	; 0xed4 <__vector_11+0x12c>

     ec4:	82 e2       	ldi	r24, 0x22	; 34
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	0e 94 a6 08 	call	0x114c	; 0x114c <_Z17HID_GetDescriptori>
     ecc:	89 2b       	or	r24, r25
     ece:	09 f0       	breq	.+2      	; 0xed2 <__vector_11+0x12a>
     ed0:	71 c0       	rjmp	.+226    	; 0xfb4 <__vector_11+0x20c>
     ed2:	74 c0       	rjmp	.+232    	; 0xfbc <__vector_11+0x214>
	const u8* desc_addr = 0;
	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
	{
		if (setup.wLength == 8)
     ed4:	21 30       	cpi	r18, 0x01	; 1
     ed6:	69 f4       	brne	.+26     	; 0xef2 <__vector_11+0x14a>
			_cdcComposite = 1;
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
     ed8:	88 89       	ldd	r24, Y+16	; 0x10
     eda:	99 89       	ldd	r25, Y+17	; 0x11
     edc:	08 97       	sbiw	r24, 0x08	; 8
     ede:	11 f4       	brne	.+4      	; 0xee4 <__vector_11+0x13c>
	}
     ee0:	20 93 d5 01 	sts	0x01D5, r18
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
     ee4:	80 91 d5 01 	lds	r24, 0x01D5
     ee8:	81 11       	cpse	r24, r1
     eea:	18 c0       	rjmp	.+48     	; 0xf1c <__vector_11+0x174>
     eec:	61 e1       	ldi	r22, 0x11	; 17
     eee:	71 e0       	ldi	r23, 0x01	; 1
     ef0:	1a c0       	rjmp	.+52     	; 0xf26 <__vector_11+0x17e>
	{
		if (setup.wValueL == 0) {
     ef2:	23 30       	cpi	r18, 0x03	; 3
     ef4:	09 f0       	breq	.+2      	; 0xef8 <__vector_11+0x150>
     ef6:	62 c0       	rjmp	.+196    	; 0xfbc <__vector_11+0x214>
			desc_addr = (const u8*)&STRING_LANGUAGE;
		}
     ef8:	8c 85       	ldd	r24, Y+12	; 0x0c
     efa:	88 23       	and	r24, r24
     efc:	91 f0       	breq	.+36     	; 0xf22 <__vector_11+0x17a>
		else if (setup.wValueL == IPRODUCT) {
			return USB_SendStringDescriptor(STRING_PRODUCT, strlen(USB_PRODUCT));
		}
     efe:	82 30       	cpi	r24, 0x02	; 2
     f00:	21 f4       	brne	.+8      	; 0xf0a <__vector_11+0x162>
		else if (setup.wValueL == IMANUFACTURER) {
     f02:	60 e1       	ldi	r22, 0x10	; 16
     f04:	8f e2       	ldi	r24, 0x2F	; 47
     f06:	91 e0       	ldi	r25, 0x01	; 1
     f08:	06 c0       	rjmp	.+12     	; 0xf16 <__vector_11+0x16e>
			return USB_SendStringDescriptor(STRING_MANUFACTURER, strlen(USB_MANUFACTURER));
		}
     f0a:	81 30       	cpi	r24, 0x01	; 1
     f0c:	09 f0       	breq	.+2      	; 0xf10 <__vector_11+0x168>
     f0e:	56 c0       	rjmp	.+172    	; 0xfbc <__vector_11+0x214>
		else
     f10:	6b e0       	ldi	r22, 0x0B	; 11
     f12:	83 e2       	ldi	r24, 0x23	; 35
     f14:	91 e0       	ldi	r25, 0x01	; 1
     f16:	0e 94 06 05 	call	0xa0c	; 0xa0c <_ZL24USB_SendStringDescriptorPKhh>
     f1a:	4a c0       	rjmp	.+148    	; 0xfb0 <__vector_11+0x208>
	{
		if (setup.wLength == 8)
			_cdcComposite = 1;
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
     f1c:	6f ef       	ldi	r22, 0xFF	; 255
     f1e:	70 e0       	ldi	r23, 0x00	; 0
     f20:	02 c0       	rjmp	.+4      	; 0xf26 <__vector_11+0x17e>
	{
		if (setup.wValueL == 0) {
			desc_addr = (const u8*)&STRING_LANGUAGE;
		}
		else if (setup.wValueL == IPRODUCT) {
     f22:	60 e4       	ldi	r22, 0x40	; 64
     f24:	71 e0       	ldi	r23, 0x01	; 1
			return false;
	}

	if (desc_addr == 0)
		return false;
	u8 desc_length = pgm_read_byte(desc_addr);
     f26:	61 15       	cp	r22, r1
     f28:	71 05       	cpc	r23, r1
     f2a:	09 f4       	brne	.+2      	; 0xf2e <__vector_11+0x186>
     f2c:	47 c0       	rjmp	.+142    	; 0xfbc <__vector_11+0x214>

	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
     f2e:	fb 01       	movw	r30, r22
     f30:	44 91       	lpm	r20, Z
	return true;
}
     f32:	50 e0       	ldi	r21, 0x00	; 0
     f34:	80 e8       	ldi	r24, 0x80	; 128
     f36:	0e 94 75 06 	call	0xcea	; 0xcea <_Z15USB_SendControlhPKvi>
     f3a:	3c c0       	rjmp	.+120    	; 0xfb4 <__vector_11+0x20c>
		{
			ok = SendDescriptor(setup);
		}
		else if (SET_DESCRIPTOR == r)
		{
			ok = false;
     f3c:	87 30       	cpi	r24, 0x07	; 7
     f3e:	09 f4       	brne	.+2      	; 0xf42 <__vector_11+0x19a>
     f40:	3d c0       	rjmp	.+122    	; 0xfbc <__vector_11+0x214>
		}
		else if (GET_CONFIGURATION == r)
		{
			Send8(1);
     f42:	88 30       	cpi	r24, 0x08	; 8
     f44:	21 f4       	brne	.+8      	; 0xf4e <__vector_11+0x1a6>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	80 93 f1 00 	sts	0x00F1, r24
     f4c:	33 c0       	rjmp	.+102    	; 0xfb4 <__vector_11+0x20c>
		{
			Send8(1);
		}
		else if (SET_CONFIGURATION == r)
		{
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
     f4e:	89 30       	cpi	r24, 0x09	; 9
     f50:	89 f5       	brne	.+98     	; 0xfb4 <__vector_11+0x20c>
			{
				InitEndpoints();
     f52:	93 70       	andi	r25, 0x03	; 3
     f54:	99 f5       	brne	.+102    	; 0xfbc <__vector_11+0x214>
     f56:	eb ef       	ldi	r30, 0xFB	; 251
     f58:	f0 e0       	ldi	r31, 0x00	; 0
     f5a:	81 e0       	ldi	r24, 0x01	; 1
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
		UECONX = 1;
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
     f5c:	21 e0       	ldi	r18, 0x01	; 1
	}
	UERST = 0x7E;	// And reset them
     f5e:	96 e3       	ldi	r25, 0x36	; 54
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
		UECONX = 1;
		UECFG0X = pgm_read_byte(_initEndpoints+i);
     f60:	80 93 e9 00 	sts	0x00E9, r24
		UECFG1X = EP_DOUBLE_64;
     f64:	20 93 eb 00 	sts	0x00EB, r18
	}
     f68:	34 91       	lpm	r19, Z
     f6a:	30 93 ec 00 	sts	0x00EC, r19
	UERST = 0x7E;	// And reset them
     f6e:	90 93 ed 00 	sts	0x00ED, r25
static
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
     f72:	8f 5f       	subi	r24, 0xFF	; 255
     f74:	31 96       	adiw	r30, 0x01	; 1
     f76:	85 30       	cpi	r24, 0x05	; 5
     f78:	99 f7       	brne	.-26     	; 0xf60 <__vector_11+0x1b8>
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
	}
	UERST = 0x7E;	// And reset them
	UERST = 0;
}
     f7a:	8e e7       	ldi	r24, 0x7E	; 126
     f7c:	80 93 ea 00 	sts	0x00EA, r24

     f80:	10 92 ea 00 	sts	0x00EA, r1
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
			{
				InitEndpoints();
				_usbConfiguration = setup.wValueL;
			} else
				ok = false;
     f84:	8c 85       	ldd	r24, Y+12	; 0x0c
     f86:	80 93 da 01 	sts	0x01DA, r24
     f8a:	14 c0       	rjmp	.+40     	; 0xfb4 <__vector_11+0x20c>
	}
	else
	{
		InitControl(setup.wLength);		//	Max length of transfer
		ok = ClassInterfaceRequest(setup);
	}
     f8c:	88 89       	ldd	r24, Y+16	; 0x10
     f8e:	99 89       	ldd	r25, Y+17	; 0x11
     f90:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <_Z11InitControli>
static
bool ClassInterfaceRequest(Setup& setup)
{
	u8 i = setup.wIndex;

#ifdef CDC_ENABLED
     f94:	8e 85       	ldd	r24, Y+14	; 0x0e
	if (CDC_ACM_INTERFACE == i)
		return CDC_Setup(setup);
#endif
     f96:	81 11       	cpse	r24, r1
     f98:	05 c0       	rjmp	.+10     	; 0xfa4 <__vector_11+0x1fc>

     f9a:	ce 01       	movw	r24, r28
     f9c:	0a 96       	adiw	r24, 0x0a	; 10
     f9e:	0e 94 3c 04 	call	0x878	; 0x878 <_Z9CDC_SetupR5Setup>
     fa2:	06 c0       	rjmp	.+12     	; 0xfb0 <__vector_11+0x208>
#ifdef HID_ENABLED
	if (HID_INTERFACE == i)
		return HID_Setup(setup);
#endif
     fa4:	82 30       	cpi	r24, 0x02	; 2
     fa6:	51 f4       	brne	.+20     	; 0xfbc <__vector_11+0x214>
	return false;
     fa8:	ce 01       	movw	r24, r28
     faa:	0a 96       	adiw	r24, 0x0a	; 10
     fac:	0e 94 ce 08 	call	0x119c	; 0x119c <_Z9HID_SetupR5Setup>
		ok = ClassInterfaceRequest(setup);
	}

	if (ok)
		ClearIN();
	else
     fb0:	88 23       	and	r24, r24
     fb2:	21 f0       	breq	.+8      	; 0xfbc <__vector_11+0x214>

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
}

     fb4:	8e ef       	ldi	r24, 0xFE	; 254
     fb6:	80 93 e8 00 	sts	0x00E8, r24
     fba:	03 c0       	rjmp	.+6      	; 0xfc2 <__vector_11+0x21a>

static inline void Stall()
{
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

     fbc:	81 e2       	ldi	r24, 0x21	; 33
     fbe:	80 93 eb 00 	sts	0x00EB, r24
	{
		Stall();
	}
}

void USB_Flush(u8 ep)
     fc2:	62 96       	adiw	r28, 0x12	; 18
     fc4:	0f b6       	in	r0, 0x3f	; 63
     fc6:	f8 94       	cli
     fc8:	de bf       	out	0x3e, r29	; 62
     fca:	0f be       	out	0x3f, r0	; 63
     fcc:	cd bf       	out	0x3d, r28	; 61
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	ff 91       	pop	r31
     fd4:	ef 91       	pop	r30
     fd6:	bf 91       	pop	r27
     fd8:	af 91       	pop	r26
     fda:	9f 91       	pop	r25
     fdc:	8f 91       	pop	r24
     fde:	7f 91       	pop	r23
     fe0:	6f 91       	pop	r22
     fe2:	5f 91       	pop	r21
     fe4:	4f 91       	pop	r20
     fe6:	3f 91       	pop	r19
     fe8:	2f 91       	pop	r18
     fea:	1f 91       	pop	r17
     fec:	0f 91       	pop	r16
     fee:	ff 90       	pop	r15
     ff0:	ef 90       	pop	r14
     ff2:	0f 90       	pop	r0
     ff4:	0f be       	out	0x3f, r0	; 63
     ff6:	0f 90       	pop	r0
     ff8:	1f 90       	pop	r1
     ffa:	18 95       	reti

00000ffc <_Z9USB_Flushh>:

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

     ffc:	80 93 e9 00 	sts	0x00E9, r24
static inline u8 FifoByteCount()
{
	return UEBCLX;
}

    1000:	80 91 f2 00 	lds	r24, 0x00F2
void USB_Flush(u8 ep)
{
	SetEP(ep);
	if (FifoByteCount())
		ReleaseTX();
}
    1004:	88 23       	and	r24, r24
    1006:	19 f0       	breq	.+6      	; 0x100e <_Z9USB_Flushh+0x12>

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
}

    1008:	8a e3       	ldi	r24, 0x3A	; 58
    100a:	80 93 e8 00 	sts	0x00E8, r24
    100e:	08 95       	ret

00001010 <__vector_10>:

//	General interrupt
ISR(USB_GEN_vect)
{
	u8 udint = UDINT;
	UDINT = 0;
    1010:	1f 92       	push	r1
    1012:	0f 92       	push	r0
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	0f 92       	push	r0
    1018:	11 24       	eor	r1, r1
    101a:	2f 93       	push	r18
    101c:	3f 93       	push	r19
    101e:	4f 93       	push	r20
    1020:	5f 93       	push	r21
    1022:	6f 93       	push	r22
    1024:	7f 93       	push	r23
    1026:	8f 93       	push	r24
    1028:	9f 93       	push	r25
    102a:	af 93       	push	r26
    102c:	bf 93       	push	r27
    102e:	ef 93       	push	r30
    1030:	ff 93       	push	r31

    1032:	80 91 e1 00 	lds	r24, 0x00E1
	//	End of Reset
    1036:	10 92 e1 00 	sts	0x00E1, r1
	if (udint & (1<<EORSTI))
	{
		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
    103a:	83 ff       	sbrs	r24, 3
    103c:	0f c0       	rjmp	.+30     	; 0x105c <__vector_10+0x4c>
static
void InitEP(u8 index, u8 type, u8 size)
{
	UENUM = index;
	UECONX = 1;
	UECFG0X = type;
    103e:	10 92 e9 00 	sts	0x00E9, r1
	UECFG1X = size;
    1042:	91 e0       	ldi	r25, 0x01	; 1
    1044:	90 93 eb 00 	sts	0x00EB, r25
}
    1048:	10 92 ec 00 	sts	0x00EC, r1

    104c:	92 e3       	ldi	r25, 0x32	; 50
    104e:	90 93 ed 00 	sts	0x00ED, r25
	if (udint & (1<<EORSTI))
	{
		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
		_usbConfiguration = 0;			// not configured yet
		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
	}
    1052:	10 92 da 01 	sts	0x01DA, r1

    1056:	98 e0       	ldi	r25, 0x08	; 8
    1058:	90 93 f0 00 	sts	0x00F0, r25
	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
	if (udint & (1<<SOFI))
	{
#ifdef CDC_ENABLED
    105c:	82 ff       	sbrs	r24, 2
    105e:	1d c0       	rjmp	.+58     	; 0x109a <__vector_10+0x8a>
		USB_Flush(CDC_TX);				// Send a tx frame if found
#endif
		
    1060:	83 e0       	ldi	r24, 0x03	; 3
    1062:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9USB_Flushh>
		// check whether the one-shot period has elapsed.  if so, turn off the LED
		if (TxLEDPulse && !(--TxLEDPulse))
			TXLED0;
		if (RxLEDPulse && !(--RxLEDPulse))
    1066:	80 91 dc 01 	lds	r24, 0x01DC
    106a:	88 23       	and	r24, r24
    106c:	39 f0       	breq	.+14     	; 0x107c <__vector_10+0x6c>
    106e:	80 91 dc 01 	lds	r24, 0x01DC
    1072:	81 50       	subi	r24, 0x01	; 1
    1074:	80 93 dc 01 	sts	0x01DC, r24
    1078:	88 23       	and	r24, r24
    107a:	69 f0       	breq	.+26     	; 0x1096 <__vector_10+0x86>
			RXLED0;
	}
    107c:	80 91 db 01 	lds	r24, 0x01DB
    1080:	88 23       	and	r24, r24
    1082:	59 f0       	breq	.+22     	; 0x109a <__vector_10+0x8a>
    1084:	80 91 db 01 	lds	r24, 0x01DB
    1088:	81 50       	subi	r24, 0x01	; 1
    108a:	80 93 db 01 	sts	0x01DB, r24
    108e:	81 11       	cpse	r24, r1
    1090:	04 c0       	rjmp	.+8      	; 0x109a <__vector_10+0x8a>
}
    1092:	28 9a       	sbi	0x05, 0	; 5
    1094:	02 c0       	rjmp	.+4      	; 0x109a <__vector_10+0x8a>
		
		// check whether the one-shot period has elapsed.  if so, turn off the LED
		if (TxLEDPulse && !(--TxLEDPulse))
			TXLED0;
		if (RxLEDPulse && !(--RxLEDPulse))
			RXLED0;
    1096:	5d 9a       	sbi	0x0b, 5	; 11
    1098:	f1 cf       	rjmp	.-30     	; 0x107c <__vector_10+0x6c>
	}
}

//	VBUS or counting frames
    109a:	ff 91       	pop	r31
    109c:	ef 91       	pop	r30
    109e:	bf 91       	pop	r27
    10a0:	af 91       	pop	r26
    10a2:	9f 91       	pop	r25
    10a4:	8f 91       	pop	r24
    10a6:	7f 91       	pop	r23
    10a8:	6f 91       	pop	r22
    10aa:	5f 91       	pop	r21
    10ac:	4f 91       	pop	r20
    10ae:	3f 91       	pop	r19
    10b0:	2f 91       	pop	r18
    10b2:	0f 90       	pop	r0
    10b4:	0f be       	out	0x3f, r0	; 63
    10b6:	0f 90       	pop	r0
    10b8:	1f 90       	pop	r1
    10ba:	18 95       	reti

000010bc <_ZN10USBDevice_6attachEv>:

void USBDevice_::attach()
{
	_usbConfiguration = 0;
	UHWCON = 0x01;						// power internal reg
	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
    10bc:	10 92 da 01 	sts	0x01DA, r1
#if F_CPU == 16000000UL
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	80 93 d7 00 	sts	0x00D7, r24
	PLLCSR = 0x12;						// Need 16 MHz xtal
    10c6:	80 ea       	ldi	r24, 0xA0	; 160
    10c8:	80 93 d8 00 	sts	0x00D8, r24
#elif F_CPU == 8000000UL
	PLLCSR = 0x02;						// Need 8 MHz xtal
    10cc:	82 e1       	ldi	r24, 0x12	; 18
    10ce:	89 bd       	out	0x29, r24	; 41
#endif
	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
		;

    10d0:	09 b4       	in	r0, 0x29	; 41
    10d2:	00 fe       	sbrs	r0, 0
    10d4:	fd cf       	rjmp	.-6      	; 0x10d0 <_ZN10USBDevice_6attachEv+0x14>
	// Some tests on specific versions of macosx (10.7.3), reported some
	// strange behaviuors when the board is reset using the serial
	// port touch at 1200 bps. This delay fixes this behaviour.
	delay(1);

	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
    10d6:	61 e0       	ldi	r22, 0x01	; 1
    10d8:	70 e0       	ldi	r23, 0x00	; 0
    10da:	80 e0       	ldi	r24, 0x00	; 0
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	0e 94 25 03 	call	0x64a	; 0x64a <delay>
	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
	UDCON = 0;							// enable attach resistor
    10e2:	80 e9       	ldi	r24, 0x90	; 144
    10e4:	80 93 d8 00 	sts	0x00D8, r24
	
    10e8:	8c e0       	ldi	r24, 0x0C	; 12
    10ea:	80 93 e2 00 	sts	0x00E2, r24
	TX_RX_LED_INIT;
    10ee:	10 92 e0 00 	sts	0x00E0, r1
}

    10f2:	55 9a       	sbi	0x0a, 5	; 10
    10f4:	20 9a       	sbi	0x04, 0	; 4
    10f6:	08 95       	ret

000010f8 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    10f8:	08 95       	ret

000010fa <_ZN9Keyboard_5writeEh>:
}

size_t Keyboard_::write(uint8_t c)
{	
	uint8_t p = press(c);  // Keydown
	release(c);            // Keyup
    10fa:	ff 92       	push	r15
    10fc:	0f 93       	push	r16
    10fe:	1f 93       	push	r17
    1100:	cf 93       	push	r28
    1102:	df 93       	push	r29
    1104:	ec 01       	movw	r28, r24
    1106:	f6 2e       	mov	r15, r22
	return p;              // just return the result of press() since release() almost always returns 1
    1108:	e8 81       	ld	r30, Y
    110a:	f9 81       	ldd	r31, Y+1	; 0x01
    110c:	04 80       	ldd	r0, Z+4	; 0x04
    110e:	f5 81       	ldd	r31, Z+5	; 0x05
    1110:	e0 2d       	mov	r30, r0
    1112:	09 95       	icall
    1114:	8c 01       	movw	r16, r24
}
    1116:	e8 81       	ld	r30, Y
    1118:	f9 81       	ldd	r31, Y+1	; 0x01
    111a:	06 80       	ldd	r0, Z+6	; 0x06
    111c:	f7 81       	ldd	r31, Z+7	; 0x07
    111e:	e0 2d       	mov	r30, r0
    1120:	6f 2d       	mov	r22, r15
    1122:	ce 01       	movw	r24, r28
    1124:	09 95       	icall

#endif
    1126:	c8 01       	movw	r24, r16
    1128:	99 27       	eor	r25, r25
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	1f 91       	pop	r17
    1130:	0f 91       	pop	r16
    1132:	ff 90       	pop	r15
    1134:	08 95       	ret

00001136 <_Z16HID_GetInterfacePh>:

int WEAK HID_GetInterface(u8* interfaceNum)
{
	interfaceNum[0] += 1;	// uses 1
	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
}
    1136:	fc 01       	movw	r30, r24
    1138:	20 81       	ld	r18, Z
    113a:	2f 5f       	subi	r18, 0xFF	; 255
    113c:	20 83       	st	Z, r18

    113e:	49 e1       	ldi	r20, 0x19	; 25
    1140:	50 e0       	ldi	r21, 0x00	; 0
    1142:	64 ec       	ldi	r22, 0xC4	; 196
    1144:	71 e0       	ldi	r23, 0x01	; 1
    1146:	80 e8       	ldi	r24, 0x80	; 128
    1148:	0c 94 75 06 	jmp	0xcea	; 0xcea <_Z15USB_SendControlhPKvi>

0000114c <_Z17HID_GetDescriptori>:
int WEAK HID_GetDescriptor(int /* i */)
{
	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
}

    114c:	45 e6       	ldi	r20, 0x65	; 101
    114e:	50 e0       	ldi	r21, 0x00	; 0
    1150:	6d ed       	ldi	r22, 0xDD	; 221
    1152:	71 e0       	ldi	r23, 0x01	; 1
    1154:	80 e8       	ldi	r24, 0x80	; 128
    1156:	0c 94 75 06 	jmp	0xcea	; 0xcea <_Z15USB_SendControlhPKvi>

0000115a <_Z14HID_SendReporthPKvi>:
void WEAK HID_SendReport(u8 id, const void* data, int len)
{
	USB_Send(HID_TX, &id, 1);
	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
    115a:	ef 92       	push	r14
    115c:	ff 92       	push	r15
    115e:	0f 93       	push	r16
    1160:	1f 93       	push	r17
    1162:	cf 93       	push	r28
    1164:	df 93       	push	r29
    1166:	1f 92       	push	r1
    1168:	cd b7       	in	r28, 0x3d	; 61
    116a:	de b7       	in	r29, 0x3e	; 62
    116c:	89 83       	std	Y+1, r24	; 0x01
    116e:	8b 01       	movw	r16, r22
    1170:	7a 01       	movw	r14, r20
}
    1172:	41 e0       	ldi	r20, 0x01	; 1
    1174:	50 e0       	ldi	r21, 0x00	; 0
    1176:	be 01       	movw	r22, r28
    1178:	6f 5f       	subi	r22, 0xFF	; 255
    117a:	7f 4f       	sbci	r23, 0xFF	; 255
    117c:	84 e0       	ldi	r24, 0x04	; 4
    117e:	0e 94 da 05 	call	0xbb4	; 0xbb4 <_Z8USB_SendhPKvi>

    1182:	a7 01       	movw	r20, r14
    1184:	b8 01       	movw	r22, r16
    1186:	84 e4       	ldi	r24, 0x44	; 68
    1188:	0e 94 da 05 	call	0xbb4	; 0xbb4 <_Z8USB_SendhPKvi>
bool WEAK HID_Setup(Setup& setup)
    118c:	0f 90       	pop	r0
    118e:	df 91       	pop	r29
    1190:	cf 91       	pop	r28
    1192:	1f 91       	pop	r17
    1194:	0f 91       	pop	r16
    1196:	ff 90       	pop	r15
    1198:	ef 90       	pop	r14
    119a:	08 95       	ret

0000119c <_Z9HID_SetupR5Setup>:
{
	u8 r = setup.bRequest;
	u8 requestType = setup.bmRequestType;
    119c:	fc 01       	movw	r30, r24
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
    119e:	91 81       	ldd	r25, Z+1	; 0x01
	{
    11a0:	80 81       	ld	r24, Z
		if (HID_GET_REPORT == r)
    11a2:	81 3a       	cpi	r24, 0xA1	; 161
    11a4:	31 f4       	brne	.+12     	; 0x11b2 <_Z9HID_SetupR5Setup+0x16>
		{
			//HID_GetReport();
			return true;
		}
		if (HID_GET_PROTOCOL == r)
    11a6:	81 e0       	ldi	r24, 0x01	; 1
	u8 requestType = setup.bmRequestType;
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
	{
		if (HID_GET_REPORT == r)
		{
			//HID_GetReport();
    11a8:	91 30       	cpi	r25, 0x01	; 1
    11aa:	91 f0       	breq	.+36     	; 0x11d0 <_Z9HID_SetupR5Setup+0x34>
			return true;
		}
		if (HID_GET_PROTOCOL == r)
		{
			//Send8(_hid_protocol);	// TODO
    11ac:	93 30       	cpi	r25, 0x03	; 3
    11ae:	89 f4       	brne	.+34     	; 0x11d2 <_Z9HID_SetupR5Setup+0x36>
    11b0:	11 c0       	rjmp	.+34     	; 0x11d4 <_Z9HID_SetupR5Setup+0x38>
		}
	}
	
	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
	{
		if (HID_SET_PROTOCOL == r)
    11b2:	81 32       	cpi	r24, 0x21	; 33
    11b4:	71 f4       	brne	.+28     	; 0x11d2 <_Z9HID_SetupR5Setup+0x36>
		{
			_hid_protocol = setup.wValueL;
    11b6:	9b 30       	cpi	r25, 0x0B	; 11
    11b8:	21 f4       	brne	.+8      	; 0x11c2 <_Z9HID_SetupR5Setup+0x26>
			return true;
		}
    11ba:	82 81       	ldd	r24, Z+2	; 0x02
    11bc:	80 93 0a 01 	sts	0x010A, r24
    11c0:	05 c0       	rjmp	.+10     	; 0x11cc <_Z9HID_SetupR5Setup+0x30>

		if (HID_SET_IDLE == r)
		{
			_hid_idle = setup.wValueL;
    11c2:	9a 30       	cpi	r25, 0x0A	; 10
    11c4:	31 f4       	brne	.+12     	; 0x11d2 <_Z9HID_SetupR5Setup+0x36>
			return true;
		}
    11c6:	82 81       	ldd	r24, Z+2	; 0x02
    11c8:	80 93 09 01 	sts	0x0109, r24
	}
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	08 95       	ret
    11d0:	08 95       	ret
	return false;
}

    11d2:	80 e0       	ldi	r24, 0x00	; 0
//================================================================================
    11d4:	08 95       	ret

000011d6 <_ZN9Keyboard_10sendReportEP9KeyReport>:

void Keyboard_::sendReport(KeyReport* keys)
{
	HID_SendReport(2,keys,sizeof(KeyReport));
}

    11d6:	48 e0       	ldi	r20, 0x08	; 8
    11d8:	50 e0       	ldi	r21, 0x00	; 0
    11da:	82 e0       	ldi	r24, 0x02	; 2
    11dc:	0c 94 ad 08 	jmp	0x115a	; 0x115a <_Z14HID_SendReporthPKvi>

000011e0 <_ZN9Keyboard_5pressEh>:
// USB HID works, the host acts like the key remains pressed until we 
// call release(), releaseAll(), or otherwise clear the report and resend.
size_t Keyboard_::press(uint8_t k) 
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
    11e0:	cf 93       	push	r28
    11e2:	df 93       	push	r29
    11e4:	dc 01       	movw	r26, r24
		k = k - 136;
	} else if (k >= 128) {	// it's a modifier key
    11e6:	68 38       	cpi	r22, 0x88	; 136
    11e8:	18 f0       	brcs	.+6      	; 0x11f0 <_ZN9Keyboard_5pressEh+0x10>
		_keyReport.modifiers |= (1<<(k-128));
    11ea:	e8 e7       	ldi	r30, 0x78	; 120
    11ec:	e6 0f       	add	r30, r22
    11ee:	25 c0       	rjmp	.+74     	; 0x123a <_ZN9Keyboard_5pressEh+0x5a>
    11f0:	e6 2f       	mov	r30, r22
    11f2:	f0 e0       	ldi	r31, 0x00	; 0
		k = 0;
    11f4:	67 ff       	sbrs	r22, 7
    11f6:	11 c0       	rjmp	.+34     	; 0x121a <_ZN9Keyboard_5pressEh+0x3a>
	} else {				// it's a printing key
    11f8:	e0 58       	subi	r30, 0x80	; 128
    11fa:	f1 09       	sbc	r31, r1
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	01 c0       	rjmp	.+2      	; 0x1204 <_ZN9Keyboard_5pressEh+0x24>
    1202:	88 0f       	add	r24, r24
    1204:	ea 95       	dec	r30
    1206:	ea f7       	brpl	.-6      	; 0x1202 <_ZN9Keyboard_5pressEh+0x22>
    1208:	14 96       	adiw	r26, 0x04	; 4
    120a:	9c 91       	ld	r25, X
    120c:	14 97       	sbiw	r26, 0x04	; 4
    120e:	98 2b       	or	r25, r24
    1210:	14 96       	adiw	r26, 0x04	; 4
    1212:	9c 93       	st	X, r25
    1214:	14 97       	sbiw	r26, 0x04	; 4
		k = pgm_read_byte(_asciimap + k);
    1216:	e0 e0       	ldi	r30, 0x00	; 0
    1218:	10 c0       	rjmp	.+32     	; 0x123a <_ZN9Keyboard_5pressEh+0x5a>
		if (!k) {
			setWriteError();
    121a:	ec 5b       	subi	r30, 0xBC	; 188
    121c:	fe 4f       	sbci	r31, 0xFE	; 254
    121e:	e4 91       	lpm	r30, Z
			return 0;
    1220:	ee 23       	and	r30, r30
    1222:	09 f4       	brne	.+2      	; 0x1226 <_ZN9Keyboard_5pressEh+0x46>
    1224:	40 c0       	rjmp	.+128    	; 0x12a6 <_ZN9Keyboard_5pressEh+0xc6>
		}
		if (k & 0x80) {						// it's a capital letter or other character reached with shift
			_keyReport.modifiers |= 0x02;	// the left shift modifier
			k &= 0x7F;
    1226:	e7 ff       	sbrs	r30, 7
    1228:	08 c0       	rjmp	.+16     	; 0x123a <_ZN9Keyboard_5pressEh+0x5a>
		}
    122a:	14 96       	adiw	r26, 0x04	; 4
    122c:	8c 91       	ld	r24, X
    122e:	14 97       	sbiw	r26, 0x04	; 4
    1230:	82 60       	ori	r24, 0x02	; 2
    1232:	14 96       	adiw	r26, 0x04	; 4
    1234:	8c 93       	st	X, r24
    1236:	14 97       	sbiw	r26, 0x04	; 4
	}
    1238:	ef 77       	andi	r30, 0x7F	; 127
	
	// Add k to the key report only if it's not already present
	// and if there is an empty slot.
	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
    123a:	16 96       	adiw	r26, 0x06	; 6
    123c:	8c 91       	ld	r24, X
    123e:	16 97       	sbiw	r26, 0x06	; 6
    1240:	8e 17       	cp	r24, r30
    1242:	41 f1       	breq	.+80     	; 0x1294 <_ZN9Keyboard_5pressEh+0xb4>
    1244:	17 96       	adiw	r26, 0x07	; 7
    1246:	8c 91       	ld	r24, X
    1248:	17 97       	sbiw	r26, 0x07	; 7
    124a:	8e 17       	cp	r24, r30
    124c:	19 f1       	breq	.+70     	; 0x1294 <_ZN9Keyboard_5pressEh+0xb4>
    124e:	18 96       	adiw	r26, 0x08	; 8
    1250:	8c 91       	ld	r24, X
    1252:	18 97       	sbiw	r26, 0x08	; 8
    1254:	8e 17       	cp	r24, r30
    1256:	f1 f0       	breq	.+60     	; 0x1294 <_ZN9Keyboard_5pressEh+0xb4>
		
    1258:	19 96       	adiw	r26, 0x09	; 9
    125a:	8c 91       	ld	r24, X
    125c:	19 97       	sbiw	r26, 0x09	; 9
    125e:	8e 17       	cp	r24, r30
    1260:	c9 f0       	breq	.+50     	; 0x1294 <_ZN9Keyboard_5pressEh+0xb4>
    1262:	1a 96       	adiw	r26, 0x0a	; 10
    1264:	8c 91       	ld	r24, X
    1266:	1a 97       	sbiw	r26, 0x0a	; 10
    1268:	8e 17       	cp	r24, r30
    126a:	a1 f0       	breq	.+40     	; 0x1294 <_ZN9Keyboard_5pressEh+0xb4>
		for (i=0; i<6; i++) {
    126c:	1b 96       	adiw	r26, 0x0b	; 11
    126e:	8c 91       	ld	r24, X
    1270:	1b 97       	sbiw	r26, 0x0b	; 11
    1272:	8e 17       	cp	r24, r30
    1274:	79 f0       	breq	.+30     	; 0x1294 <_ZN9Keyboard_5pressEh+0xb4>
    1276:	80 e0       	ldi	r24, 0x00	; 0
    1278:	90 e0       	ldi	r25, 0x00	; 0
    127a:	ed 01       	movw	r28, r26
    127c:	c8 0f       	add	r28, r24
    127e:	d9 1f       	adc	r29, r25
			if (_keyReport.keys[i] == 0x00) {
				_keyReport.keys[i] = k;
				break;
    1280:	2e 81       	ldd	r18, Y+6	; 0x06
    1282:	21 11       	cpse	r18, r1
    1284:	02 c0       	rjmp	.+4      	; 0x128a <_ZN9Keyboard_5pressEh+0xaa>
			}
    1286:	ee 83       	std	Y+6, r30	; 0x06
    1288:	05 c0       	rjmp	.+10     	; 0x1294 <_ZN9Keyboard_5pressEh+0xb4>
    128a:	01 96       	adiw	r24, 0x01	; 1
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
		
		for (i=0; i<6; i++) {
			if (_keyReport.keys[i] == 0x00) {
				_keyReport.keys[i] = k;
    128c:	86 30       	cpi	r24, 0x06	; 6
    128e:	91 05       	cpc	r25, r1
    1290:	a1 f7       	brne	.-24     	; 0x127a <_ZN9Keyboard_5pressEh+0x9a>
    1292:	09 c0       	rjmp	.+18     	; 0x12a6 <_ZN9Keyboard_5pressEh+0xc6>
			return 0;
		}	
	}
	sendReport(&_keyReport);
	return 1;
}
    1294:	bd 01       	movw	r22, r26
    1296:	6c 5f       	subi	r22, 0xFC	; 252
    1298:	7f 4f       	sbci	r23, 0xFF	; 255
    129a:	cd 01       	movw	r24, r26
    129c:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <_ZN9Keyboard_10sendReportEP9KeyReport>

    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	08 c0       	rjmp	.+16     	; 0x12b6 <_ZN9Keyboard_5pressEh+0xd6>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	90 e0       	ldi	r25, 0x00	; 0
    12aa:	13 96       	adiw	r26, 0x03	; 3
    12ac:	9c 93       	st	X, r25
    12ae:	8e 93       	st	-X, r24
    12b0:	12 97       	sbiw	r26, 0x02	; 2
		}
		if (i == 6) {
			setWriteError();
			return 0;
		}	
	}
    12b2:	80 e0       	ldi	r24, 0x00	; 0
    12b4:	90 e0       	ldi	r25, 0x00	; 0
	sendReport(&_keyReport);
	return 1;
}

// release() takes the specified key out of the persistent key report and
    12b6:	df 91       	pop	r29
    12b8:	cf 91       	pop	r28
    12ba:	08 95       	ret

000012bc <_ZN9Keyboard_7releaseEh>:
size_t Keyboard_::release(uint8_t k) 
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
		k = k - 136;
	} else if (k >= 128) {	// it's a modifier key
    12bc:	68 38       	cpi	r22, 0x88	; 136
    12be:	18 f0       	brcs	.+6      	; 0x12c6 <_ZN9Keyboard_7releaseEh+0xa>
		_keyReport.modifiers &= ~(1<<(k-128));
    12c0:	e8 e7       	ldi	r30, 0x78	; 120
    12c2:	e6 0f       	add	r30, r22
    12c4:	25 c0       	rjmp	.+74     	; 0x1310 <_ZN9Keyboard_7releaseEh+0x54>
    12c6:	e6 2f       	mov	r30, r22
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
		k = 0;
    12ca:	67 ff       	sbrs	r22, 7
    12cc:	12 c0       	rjmp	.+36     	; 0x12f2 <_ZN9Keyboard_7releaseEh+0x36>
	} else {				// it's a printing key
    12ce:	e0 58       	subi	r30, 0x80	; 128
    12d0:	f1 09       	sbc	r31, r1
    12d2:	21 e0       	ldi	r18, 0x01	; 1
    12d4:	30 e0       	ldi	r19, 0x00	; 0
    12d6:	01 c0       	rjmp	.+2      	; 0x12da <_ZN9Keyboard_7releaseEh+0x1e>
    12d8:	22 0f       	add	r18, r18
    12da:	ea 95       	dec	r30
    12dc:	ea f7       	brpl	.-6      	; 0x12d8 <_ZN9Keyboard_7releaseEh+0x1c>
    12de:	20 95       	com	r18
    12e0:	dc 01       	movw	r26, r24
    12e2:	14 96       	adiw	r26, 0x04	; 4
    12e4:	3c 91       	ld	r19, X
    12e6:	14 97       	sbiw	r26, 0x04	; 4
    12e8:	32 23       	and	r19, r18
    12ea:	14 96       	adiw	r26, 0x04	; 4
    12ec:	3c 93       	st	X, r19
		k = pgm_read_byte(_asciimap + k);
    12ee:	e0 e0       	ldi	r30, 0x00	; 0
    12f0:	0f c0       	rjmp	.+30     	; 0x1310 <_ZN9Keyboard_7releaseEh+0x54>
		if (!k) {
			return 0;
    12f2:	ec 5b       	subi	r30, 0xBC	; 188
    12f4:	fe 4f       	sbci	r31, 0xFE	; 254
    12f6:	e4 91       	lpm	r30, Z
		}
    12f8:	ee 23       	and	r30, r30
    12fa:	29 f1       	breq	.+74     	; 0x1346 <_ZN9Keyboard_7releaseEh+0x8a>
		if (k & 0x80) {							// it's a capital letter or other character reached with shift
			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
			k &= 0x7F;
    12fc:	e7 ff       	sbrs	r30, 7
    12fe:	08 c0       	rjmp	.+16     	; 0x1310 <_ZN9Keyboard_7releaseEh+0x54>
		}
    1300:	dc 01       	movw	r26, r24
    1302:	14 96       	adiw	r26, 0x04	; 4
    1304:	2c 91       	ld	r18, X
    1306:	14 97       	sbiw	r26, 0x04	; 4
    1308:	2d 7f       	andi	r18, 0xFD	; 253
    130a:	14 96       	adiw	r26, 0x04	; 4
    130c:	2c 93       	st	X, r18
	}
    130e:	ef 77       	andi	r30, 0x7F	; 127
		k = k - 136;
	} else if (k >= 128) {	// it's a modifier key
		_keyReport.modifiers &= ~(1<<(k-128));
		k = 0;
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
    1310:	20 e0       	ldi	r18, 0x00	; 0
    1312:	30 e0       	ldi	r19, 0x00	; 0
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
		if (0 != k && _keyReport.keys[i] == k) {
			_keyReport.keys[i] = 0x00;
		}
    1314:	ee 23       	and	r30, r30
    1316:	51 f0       	breq	.+20     	; 0x132c <_ZN9Keyboard_7releaseEh+0x70>
    1318:	dc 01       	movw	r26, r24
    131a:	a2 0f       	add	r26, r18
    131c:	b3 1f       	adc	r27, r19
    131e:	16 96       	adiw	r26, 0x06	; 6
    1320:	4c 91       	ld	r20, X
    1322:	16 97       	sbiw	r26, 0x06	; 6
    1324:	4e 13       	cpse	r20, r30
    1326:	02 c0       	rjmp	.+4      	; 0x132c <_ZN9Keyboard_7releaseEh+0x70>
	}
    1328:	16 96       	adiw	r26, 0x06	; 6
    132a:	1c 92       	st	X, r1
    132c:	2f 5f       	subi	r18, 0xFF	; 255
    132e:	3f 4f       	sbci	r19, 0xFF	; 255
	
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
		if (0 != k && _keyReport.keys[i] == k) {
			_keyReport.keys[i] = 0x00;
    1330:	26 30       	cpi	r18, 0x06	; 6
    1332:	31 05       	cpc	r19, r1
    1334:	79 f7       	brne	.-34     	; 0x1314 <_ZN9Keyboard_7releaseEh+0x58>
		}
	}

	sendReport(&_keyReport);
	return 1;
}
    1336:	bc 01       	movw	r22, r24
    1338:	6c 5f       	subi	r22, 0xFC	; 252
    133a:	7f 4f       	sbci	r23, 0xFF	; 255
    133c:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <_ZN9Keyboard_10sendReportEP9KeyReport>

    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	08 95       	ret
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
		if (!k) {
			return 0;
		}
		if (k & 0x80) {							// it's a capital letter or other character reached with shift
    1346:	80 e0       	ldi	r24, 0x00	; 0
    1348:	90 e0       	ldi	r25, 0x00	; 0

	sendReport(&_keyReport);
	return 1;
}

void Keyboard_::releaseAll(void)
    134a:	08 95       	ret

0000134c <_ZN9Keyboard_10releaseAllEv>:
{
	_keyReport.keys[0] = 0;
	_keyReport.keys[1] = 0;	
    134c:	fc 01       	movw	r30, r24
	_keyReport.keys[2] = 0;
    134e:	16 82       	std	Z+6, r1	; 0x06
	_keyReport.keys[3] = 0;	
    1350:	17 82       	std	Z+7, r1	; 0x07
	_keyReport.keys[4] = 0;
    1352:	10 86       	std	Z+8, r1	; 0x08
	_keyReport.keys[5] = 0;	
    1354:	11 86       	std	Z+9, r1	; 0x09
	_keyReport.modifiers = 0;
    1356:	12 86       	std	Z+10, r1	; 0x0a
	sendReport(&_keyReport);
    1358:	13 86       	std	Z+11, r1	; 0x0b
}
    135a:	14 82       	std	Z+4, r1	; 0x04

    135c:	bc 01       	movw	r22, r24
    135e:	6c 5f       	subi	r22, 0xFC	; 252
    1360:	7f 4f       	sbci	r23, 0xFF	; 255
    1362:	0c 94 eb 08 	jmp	0x11d6	; 0x11d6 <_ZN9Keyboard_10sendReportEP9KeyReport>

00001366 <_GLOBAL__sub_I_Mouse>:
//================================================================================
//	Mouse

Mouse_::Mouse_(void) : _buttons(0)
{
}
    1366:	10 92 e9 01 	sts	0x01E9, r1
  public:
    Print() : write_error(0) {}
    136a:	10 92 e0 01 	sts	0x01E0, r1
    136e:	10 92 df 01 	sts	0x01DF, r1
//================================================================================
//	Keyboard

Keyboard_::Keyboard_(void) 
{
}
    1372:	8b e3       	ldi	r24, 0x3B	; 59
    1374:	91 e0       	ldi	r25, 0x01	; 1
    1376:	90 93 de 01 	sts	0x01DE, r25
    137a:	80 93 dd 01 	sts	0x01DD, r24
    137e:	08 95       	ret

00001380 <__tablejump2__>:
    1380:	ee 0f       	add	r30, r30
    1382:	ff 1f       	adc	r31, r31

00001384 <__tablejump__>:
    1384:	05 90       	lpm	r0, Z+
    1386:	f4 91       	lpm	r31, Z
    1388:	e0 2d       	mov	r30, r0
    138a:	09 94       	ijmp

0000138c <_exit>:
    138c:	f8 94       	cli

0000138e <__stop_program>:
    138e:	ff cf       	rjmp	.-2      	; 0x138e <__stop_program>
