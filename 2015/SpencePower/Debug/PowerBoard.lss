
PowerBoard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000056  00800100  00001d80  00001e14  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d80  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000113  00800156  00800156  00001e6a  2**0
                  ALLOC
  3 .comment      00000041  00000000  00000000  00001e6a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000558  00000000  00000000  00001eab  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000c726  00000000  00000000  00002403  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002802  00000000  00000000  0000eb29  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000214d  00000000  00000000  0001132b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001008  00000000  00000000  00013478  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002f74  00000000  00000000  00014480  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000661f  00000000  00000000  000173f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000006b0  00000000  00000000  0001da13  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 76 01 	jmp	0x2ec	; 0x2ec <__dtors_end>
       4:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
       8:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
       c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      10:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      14:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      18:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      1c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      20:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      24:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__vector_9>
      28:	0c 94 ed 0c 	jmp	0x19da	; 0x19da <__vector_10>
      2c:	0c 94 b9 0b 	jmp	0x1772	; 0x1772 <__vector_11>
      30:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      34:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      38:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      3c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      40:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      44:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      48:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      4c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      50:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      54:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      58:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      5c:	0c 94 e5 06 	jmp	0xdca	; 0xdca <__vector_23>
      60:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      64:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      68:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      6c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      70:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      74:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      78:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      7c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      80:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      84:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      88:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      8c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      90:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      94:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      98:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      9c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      a0:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      a4:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      a8:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__bad_interrupt>
      ac:	25 08       	sbc	r2, r5
      ae:	28 08       	sbc	r2, r8
      b0:	17 08       	sbc	r1, r7
      b2:	1b 08       	sbc	r1, r11
      b4:	21 08       	sbc	r2, r1
      b6:	49 08       	sbc	r4, r9
      b8:	49 08       	sbc	r4, r9
      ba:	49 08       	sbc	r4, r9
      bc:	2c 08       	sbc	r2, r12
      be:	30 08       	sbc	r3, r0
      c0:	34 08       	sbc	r3, r4
      c2:	3a 08       	sbc	r3, r10
      c4:	3e 08       	sbc	r3, r14
      c6:	49 08       	sbc	r4, r9
      c8:	44 08       	sbc	r4, r4

000000ca <__trampolines_end>:
      ca:	07 06       	cpc	r0, r23
      cc:	05 04       	cpc	r0, r5
      ce:	01 00       	.word	0x0001	; ????
      d0:	08 0a       	sbc	r0, r24
      d2:	0b 0c       	add	r0, r11
      d4:	0d 09       	sbc	r16, r13

000000d6 <digital_pin_to_timer_PGM>:
      d6:	00 00 00 02 00 09 0f 00 00 03 04 01 00 0c 00 00     ................
	...

000000f4 <digital_pin_to_bit_mask_PGM>:
      f4:	04 08 02 01 10 40 80 40 10 20 40 80 40 80 08 02     .....@.@. @.@...
     104:	04 01 80 40 20 10 02 01 10 80 10 20 40 40           ...@ ...... @@

00000112 <digital_pin_to_port_PGM>:
     112:	04 04 04 04 04 03 04 05 02 02 02 02 04 03 02 02     ................
     122:	02 02 06 06 06 06 06 06 04 04 02 02 02 04           ..............

00000130 <port_to_input_PGM>:
     130:	00 00 00 00 23 00 26 00 29 00 2c 00 2f 00           ....#.&.).,./.

0000013e <port_to_output_PGM>:
     13e:	00 00 00 00 25 00 28 00 2b 00 2e 00 31 00           ....%.(.+...1.

0000014c <port_to_mode_PGM>:
     14c:	00 00 00 00 24 00 27 00 2a 00 2d 00 30 00           ....$.'.*.-.0.

0000015a <_cdcInterface>:
     15a:	08 0b 00 02 02 02 01 00 09 04 00 00 01 02 02 00     ................
     16a:	00 05 24 00 10 01 05 24 01 01 01 04 24 02 06 05     ..$....$....$...
     17a:	24 06 00 01 07 05 81 03 10 00 40 09 04 01 00 02     $.........@.....
     18a:	0a 00 00 00 07 05 02 02 40 00 00 07 05 83 02 40     ........@......@
	...

0000019c <_initEndpoints>:
     19c:	00 c1 80 81 c1                                      .....

000001a1 <USB_DeviceDescriptorA>:
     1a1:	12 01 00 02 02 00 00 40 41 23 36 80 00 01 01 02     .......@A#6.....
     1b1:	00 01                                               ..

000001b3 <USB_DeviceDescriptor>:
     1b3:	12 01 00 02 00 00 00 40 41 23 36 80 00 01 01 02     .......@A#6.....
     1c3:	00 01                                               ..

000001c5 <STRING_MANUFACTURER>:
     1c5:	41 72 64 75 69 6e 6f 20 4c 4c 43 00                 Arduino LLC.

000001d1 <STRING_PRODUCT>:
     1d1:	41 72 64 75 69 6e 6f 20 4c 65 6f 6e 61 72 64 6f     Arduino Leonardo
	...

000001e2 <STRING_LANGUAGE>:
     1e2:	04 03 09 04                                         ....

000001e6 <_asciimap>:
	...
     1ee:	2a 2b 28 00 00 00 00 00 00 00 00 00 00 00 00 00     *+(.............
	...
     206:	2c 9e b4 a0 a1 a2 a4 34 a6 a7 a5 ae 36 2d 37 38     ,......4....6-78
     216:	27 1e 1f 20 21 22 23 24 25 26 b3 33 b6 2e b7 b8     '.. !"#$%&.3....
     226:	9f 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92     ................
     236:	93 94 95 96 97 98 99 9a 9b 9c 9d 2f 31 30 a3 ad     .........../10..
     246:	35 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12     5...............
     256:	13 14 15 16 17 18 19 1a 1b 1c 1d af b1 b0 b5 00     ................

00000266 <_hidInterface>:
     266:	09 04 02 00 01 03 00 00 00 09 21 01 01 00 01 22     ..........!...."
     276:	65 00 07 05 84 03 40 00 01                          e.....@..

0000027f <_hidReportDescriptor>:
     27f:	05 01 09 02 a1 01 09 01 a1 00 85 01 05 09 19 01     ................
     28f:	29 03 15 00 25 01 95 03 75 01 81 02 95 01 75 05     )...%...u.....u.
     29f:	81 03 05 01 09 30 09 31 09 38 15 81 25 7f 75 08     .....0.1.8..%.u.
     2af:	95 03 81 06 c0 c0 05 01 09 06 a1 01 85 02 05 07     ................
     2bf:	19 e0 29 e7 15 00 25 01 75 01 95 08 81 02 95 01     ..)...%.u.......
     2cf:	75 08 81 03 95 06 75 08 15 00 25 65 05 07 19 00     u.....u...%e....
     2df:	29 65 81 00 c0                                      )e...

000002e4 <__ctors_start>:
     2e4:	80 03       	fmuls	r16, r16
     2e6:	78 09       	sbc	r23, r8
     2e8:	98 0e       	add	r9, r24

000002ea <__ctors_end>:
     2ea:	88 03       	fmulsu	r16, r16

000002ec <__dtors_end>:
     2ec:	11 24       	eor	r1, r1
     2ee:	1f be       	out	0x3f, r1	; 63
     2f0:	cf ef       	ldi	r28, 0xFF	; 255
     2f2:	da e0       	ldi	r29, 0x0A	; 10
     2f4:	de bf       	out	0x3e, r29	; 62
     2f6:	cd bf       	out	0x3d, r28	; 61

000002f8 <__do_copy_data>:
     2f8:	11 e0       	ldi	r17, 0x01	; 1
     2fa:	a0 e0       	ldi	r26, 0x00	; 0
     2fc:	b1 e0       	ldi	r27, 0x01	; 1
     2fe:	e0 e8       	ldi	r30, 0x80	; 128
     300:	fd e1       	ldi	r31, 0x1D	; 29
     302:	02 c0       	rjmp	.+4      	; 0x308 <__do_copy_data+0x10>
     304:	05 90       	lpm	r0, Z+
     306:	0d 92       	st	X+, r0
     308:	a6 35       	cpi	r26, 0x56	; 86
     30a:	b1 07       	cpc	r27, r17
     30c:	d9 f7       	brne	.-10     	; 0x304 <__do_copy_data+0xc>

0000030e <__do_clear_bss>:
     30e:	22 e0       	ldi	r18, 0x02	; 2
     310:	a6 e5       	ldi	r26, 0x56	; 86
     312:	b1 e0       	ldi	r27, 0x01	; 1
     314:	01 c0       	rjmp	.+2      	; 0x318 <.do_clear_bss_start>

00000316 <.do_clear_bss_loop>:
     316:	1d 92       	st	X+, r1

00000318 <.do_clear_bss_start>:
     318:	a9 36       	cpi	r26, 0x69	; 105
     31a:	b2 07       	cpc	r27, r18
     31c:	e1 f7       	brne	.-8      	; 0x316 <.do_clear_bss_loop>

0000031e <__do_global_ctors>:
     31e:	12 e0       	ldi	r17, 0x02	; 2
     320:	ca ee       	ldi	r28, 0xEA	; 234
     322:	d2 e0       	ldi	r29, 0x02	; 2
     324:	04 c0       	rjmp	.+8      	; 0x32e <__do_global_ctors+0x10>
     326:	22 97       	sbiw	r28, 0x02	; 2
     328:	fe 01       	movw	r30, r28
     32a:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <__tablejump__>
     32e:	c4 3e       	cpi	r28, 0xE4	; 228
     330:	d1 07       	cpc	r29, r17
     332:	c9 f7       	brne	.-14     	; 0x326 <__do_global_ctors+0x8>
     334:	0e 94 20 04 	call	0x840	; 0x840 <main>
     338:	0c 94 b3 0e 	jmp	0x1d66	; 0x1d66 <__do_global_dtors>

0000033c <__bad_interrupt>:
     33c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000340 <_ZN14SoftwareSerial4readEv>:


// Read data from buffer
int SoftwareSerial::read()
{
  if (!isListening())
     340:	20 91 98 01 	lds	r18, 0x0198
     344:	30 91 99 01 	lds	r19, 0x0199
     348:	28 17       	cp	r18, r24
     34a:	39 07       	cpc	r19, r25
     34c:	b9 f4       	brne	.+46     	; 0x37c <_ZN14SoftwareSerial4readEv+0x3c>
    return -1;

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
     34e:	90 91 56 01 	lds	r25, 0x0156
     352:	80 91 57 01 	lds	r24, 0x0157
     356:	98 17       	cp	r25, r24
     358:	a1 f0       	breq	.+40     	; 0x382 <_ZN14SoftwareSerial4readEv+0x42>
    return -1;

  // Read from "head"
  uint8_t d = _receive_buffer[_receive_buffer_head]; // grab next byte
     35a:	e0 91 56 01 	lds	r30, 0x0156
     35e:	f0 e0       	ldi	r31, 0x00	; 0
     360:	e8 5a       	subi	r30, 0xA8	; 168
     362:	fe 4f       	sbci	r31, 0xFE	; 254
     364:	80 81       	ld	r24, Z
  _receive_buffer_head = (_receive_buffer_head + 1) % _SS_MAX_RX_BUFF;
     366:	20 91 56 01 	lds	r18, 0x0156
     36a:	30 e0       	ldi	r19, 0x00	; 0
     36c:	2f 5f       	subi	r18, 0xFF	; 255
     36e:	3f 4f       	sbci	r19, 0xFF	; 255
     370:	2f 73       	andi	r18, 0x3F	; 63
     372:	30 78       	andi	r19, 0x80	; 128
     374:	20 93 56 01 	sts	0x0156, r18
  return d;
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	08 95       	ret

// Read data from buffer
int SoftwareSerial::read()
{
  if (!isListening())
    return -1;
     37c:	8f ef       	ldi	r24, 0xFF	; 255
     37e:	9f ef       	ldi	r25, 0xFF	; 255
     380:	08 95       	ret

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
    return -1;
     382:	8f ef       	ldi	r24, 0xFF	; 255
     384:	9f ef       	ldi	r25, 0xFF	; 255

  // Read from "head"
  uint8_t d = _receive_buffer[_receive_buffer_head]; // grab next byte
  _receive_buffer_head = (_receive_buffer_head + 1) % _SS_MAX_RX_BUFF;
  return d;
}
     386:	08 95       	ret

00000388 <_ZN14SoftwareSerial9availableEv>:

int SoftwareSerial::available()
{
  if (!isListening())
     388:	20 91 98 01 	lds	r18, 0x0198
     38c:	30 91 99 01 	lds	r19, 0x0199
     390:	28 17       	cp	r18, r24
     392:	39 07       	cpc	r19, r25
     394:	b1 f4       	brne	.+44     	; 0x3c2 <_ZN14SoftwareSerial9availableEv+0x3a>
    return 0;

  return (_receive_buffer_tail + _SS_MAX_RX_BUFF - _receive_buffer_head) % _SS_MAX_RX_BUFF;
     396:	20 91 57 01 	lds	r18, 0x0157
     39a:	80 91 56 01 	lds	r24, 0x0156
     39e:	30 e0       	ldi	r19, 0x00	; 0
     3a0:	20 5c       	subi	r18, 0xC0	; 192
     3a2:	3f 4f       	sbci	r19, 0xFF	; 255
     3a4:	28 1b       	sub	r18, r24
     3a6:	31 09       	sbc	r19, r1
     3a8:	2f 73       	andi	r18, 0x3F	; 63
     3aa:	30 78       	andi	r19, 0x80	; 128
     3ac:	33 23       	and	r19, r19
     3ae:	34 f4       	brge	.+12     	; 0x3bc <_ZN14SoftwareSerial9availableEv+0x34>
     3b0:	21 50       	subi	r18, 0x01	; 1
     3b2:	31 09       	sbc	r19, r1
     3b4:	20 6c       	ori	r18, 0xC0	; 192
     3b6:	3f 6f       	ori	r19, 0xFF	; 255
     3b8:	2f 5f       	subi	r18, 0xFF	; 255
     3ba:	3f 4f       	sbci	r19, 0xFF	; 255
     3bc:	82 2f       	mov	r24, r18
     3be:	93 2f       	mov	r25, r19
     3c0:	08 95       	ret
}

int SoftwareSerial::available()
{
  if (!isListening())
    return 0;
     3c2:	80 e0       	ldi	r24, 0x00	; 0
     3c4:	90 e0       	ldi	r25, 0x00	; 0

  return (_receive_buffer_tail + _SS_MAX_RX_BUFF - _receive_buffer_head) % _SS_MAX_RX_BUFF;
}
     3c6:	08 95       	ret

000003c8 <_ZN14SoftwareSerial5writeEh>:

size_t SoftwareSerial::write(uint8_t b)
{
     3c8:	1f 93       	push	r17
     3ca:	cf 93       	push	r28
     3cc:	df 93       	push	r29
     3ce:	ec 01       	movw	r28, r24
  if (_tx_delay == 0) {
     3d0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     3d2:	3d 8d       	ldd	r19, Y+29	; 0x1d
     3d4:	21 15       	cp	r18, r1
     3d6:	31 05       	cpc	r19, r1
     3d8:	39 f4       	brne	.+14     	; 0x3e8 <_ZN14SoftwareSerial5writeEh+0x20>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
     3da:	81 e0       	ldi	r24, 0x01	; 1
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	9b 83       	std	Y+3, r25	; 0x03
     3e0:	8a 83       	std	Y+2, r24	; 0x02
    setWriteError();
    return 0;
     3e2:	80 e0       	ldi	r24, 0x00	; 0
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	39 c0       	rjmp	.+114    	; 0x45a <_ZN14SoftwareSerial5writeEh+0x92>

  // By declaring these as local variables, the compiler will put them
  // in registers _before_ disabling interrupts and entering the
  // critical timing sections below, which makes it a lot easier to
  // verify the cycle timings
  volatile uint8_t *reg = _transmitPortRegister;
     3e8:	a9 89       	ldd	r26, Y+17	; 0x11
     3ea:	ba 89       	ldd	r27, Y+18	; 0x12
  uint8_t reg_mask = _transmitBitMask;
     3ec:	48 89       	ldd	r20, Y+16	; 0x10
  uint8_t inv_mask = ~_transmitBitMask;
     3ee:	54 2f       	mov	r21, r20
     3f0:	50 95       	com	r21
  uint8_t oldSREG = SREG;
     3f2:	1f b7       	in	r17, 0x3f	; 63
  bool inv = _inverse_logic;
     3f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
  uint16_t delay = _tx_delay;

  if (inv)
     3f6:	81 fb       	bst	r24, 1
     3f8:	77 27       	eor	r23, r23
     3fa:	70 f9       	bld	r23, 0
     3fc:	81 fd       	sbrc	r24, 1
    b = ~b;
     3fe:	60 95       	com	r22

  cli();  // turn off interrupts for a clean txmit
     400:	f8 94       	cli

  // Write the start bit
  if (inv)
     402:	77 23       	and	r23, r23
     404:	21 f0       	breq	.+8      	; 0x40e <_ZN14SoftwareSerial5writeEh+0x46>
    *reg |= reg_mask;
     406:	8c 91       	ld	r24, X
     408:	84 2b       	or	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	03 c0       	rjmp	.+6      	; 0x414 <_ZN14SoftwareSerial5writeEh+0x4c>
  else
    *reg &= inv_mask;
     40e:	8c 91       	ld	r24, X
     410:	85 23       	and	r24, r21
     412:	8c 93       	st	X, r24
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
     414:	c9 01       	movw	r24, r18
     416:	01 97       	sbiw	r24, 0x01	; 1
     418:	f1 f7       	brne	.-4      	; 0x416 <_ZN14SoftwareSerial5writeEh+0x4e>
     41a:	88 e0       	ldi	r24, 0x08	; 8
  tunedDelay(delay);

  // Write each of the 8 bits
  for (uint8_t i = 8; i > 0; --i)
  {
    if (b & 1) // choose bit
     41c:	60 ff       	sbrs	r22, 0
     41e:	04 c0       	rjmp	.+8      	; 0x428 <_ZN14SoftwareSerial5writeEh+0x60>
      *reg |= reg_mask; // send 1
     420:	9c 91       	ld	r25, X
     422:	94 2b       	or	r25, r20
     424:	9c 93       	st	X, r25
     426:	03 c0       	rjmp	.+6      	; 0x42e <_ZN14SoftwareSerial5writeEh+0x66>
    else
      *reg &= inv_mask; // send 0
     428:	9c 91       	ld	r25, X
     42a:	95 23       	and	r25, r21
     42c:	9c 93       	st	X, r25
     42e:	f9 01       	movw	r30, r18
     430:	31 97       	sbiw	r30, 0x01	; 1
     432:	f1 f7       	brne	.-4      	; 0x430 <_ZN14SoftwareSerial5writeEh+0x68>

    tunedDelay(delay);
    b >>= 1;
     434:	66 95       	lsr	r22
     436:	81 50       	subi	r24, 0x01	; 1
    *reg &= inv_mask;

  tunedDelay(delay);

  // Write each of the 8 bits
  for (uint8_t i = 8; i > 0; --i)
     438:	89 f7       	brne	.-30     	; 0x41c <_ZN14SoftwareSerial5writeEh+0x54>
    tunedDelay(delay);
    b >>= 1;
  }

  // restore pin to natural state
  if (inv)
     43a:	77 23       	and	r23, r23
     43c:	21 f0       	breq	.+8      	; 0x446 <_ZN14SoftwareSerial5writeEh+0x7e>
    *reg &= inv_mask;
     43e:	8c 91       	ld	r24, X
     440:	58 23       	and	r21, r24
     442:	5c 93       	st	X, r21
     444:	03 c0       	rjmp	.+6      	; 0x44c <_ZN14SoftwareSerial5writeEh+0x84>
  else
    *reg |= reg_mask;
     446:	8c 91       	ld	r24, X
     448:	48 2b       	or	r20, r24
     44a:	4c 93       	st	X, r20

  SREG = oldSREG; // turn interrupts back on
     44c:	1f bf       	out	0x3f, r17	; 63
     44e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     450:	9d 8d       	ldd	r25, Y+29	; 0x1d
     452:	01 97       	sbiw	r24, 0x01	; 1
     454:	f1 f7       	brne	.-4      	; 0x452 <_ZN14SoftwareSerial5writeEh+0x8a>
  tunedDelay(_tx_delay);
  
  return 1;
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	90 e0       	ldi	r25, 0x00	; 0
}
     45a:	df 91       	pop	r29
     45c:	cf 91       	pop	r28
     45e:	1f 91       	pop	r17
     460:	08 95       	ret

00000462 <_ZN14SoftwareSerial5flushEv>:

void SoftwareSerial::flush()
{
  if (!isListening())
     462:	20 91 98 01 	lds	r18, 0x0198
     466:	30 91 99 01 	lds	r19, 0x0199
     46a:	28 17       	cp	r18, r24
     46c:	39 07       	cpc	r19, r25
     46e:	39 f4       	brne	.+14     	; 0x47e <_ZN14SoftwareSerial5flushEv+0x1c>
    return;

  uint8_t oldSREG = SREG;
     470:	8f b7       	in	r24, 0x3f	; 63
  cli();
     472:	f8 94       	cli
  _receive_buffer_head = _receive_buffer_tail = 0;
     474:	10 92 57 01 	sts	0x0157, r1
     478:	10 92 56 01 	sts	0x0156, r1
  SREG = oldSREG;
     47c:	8f bf       	out	0x3f, r24	; 63
     47e:	08 95       	ret

00000480 <_ZN14SoftwareSerial4peekEv>:
}

int SoftwareSerial::peek()
{
  if (!isListening())
     480:	20 91 98 01 	lds	r18, 0x0198
     484:	30 91 99 01 	lds	r19, 0x0199
     488:	28 17       	cp	r18, r24
     48a:	39 07       	cpc	r19, r25
     48c:	71 f4       	brne	.+28     	; 0x4aa <_ZN14SoftwareSerial4peekEv+0x2a>
    return -1;

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
     48e:	90 91 56 01 	lds	r25, 0x0156
     492:	80 91 57 01 	lds	r24, 0x0157
     496:	98 17       	cp	r25, r24
     498:	59 f0       	breq	.+22     	; 0x4b0 <_ZN14SoftwareSerial4peekEv+0x30>
    return -1;

  // Read from "head"
  return _receive_buffer[_receive_buffer_head];
     49a:	e0 91 56 01 	lds	r30, 0x0156
     49e:	f0 e0       	ldi	r31, 0x00	; 0
     4a0:	e8 5a       	subi	r30, 0xA8	; 168
     4a2:	fe 4f       	sbci	r31, 0xFE	; 254
     4a4:	80 81       	ld	r24, Z
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	08 95       	ret
}

int SoftwareSerial::peek()
{
  if (!isListening())
    return -1;
     4aa:	8f ef       	ldi	r24, 0xFF	; 255
     4ac:	9f ef       	ldi	r25, 0xFF	; 255
     4ae:	08 95       	ret

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
    return -1;
     4b0:	8f ef       	ldi	r24, 0xFF	; 255
     4b2:	9f ef       	ldi	r25, 0xFF	; 255

  // Read from "head"
  return _receive_buffer[_receive_buffer_head];
}
     4b4:	08 95       	ret

000004b6 <_ZN14SoftwareSerial13stopListeningEv>:
}

// Stop listening. Returns true if we were actually listening.
bool SoftwareSerial::stopListening()
{
  if (active_object == this)
     4b6:	e0 91 98 01 	lds	r30, 0x0198
     4ba:	f0 91 99 01 	lds	r31, 0x0199
     4be:	e8 17       	cp	r30, r24
     4c0:	f9 07       	cpc	r31, r25
     4c2:	69 f4       	brne	.+26     	; 0x4de <_ZN14SoftwareSerial13stopListeningEv+0x28>
void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
    else
      *_pcint_maskreg &= ~_pcint_maskvalue;
     4c4:	a3 89       	ldd	r26, Z+19	; 0x13
     4c6:	b4 89       	ldd	r27, Z+20	; 0x14
     4c8:	9c 91       	ld	r25, X
     4ca:	85 89       	ldd	r24, Z+21	; 0x15
     4cc:	80 95       	com	r24
     4ce:	89 23       	and	r24, r25
     4d0:	8c 93       	st	X, r24
bool SoftwareSerial::stopListening()
{
  if (active_object == this)
  {
    setRxIntMsk(false);
    active_object = NULL;
     4d2:	10 92 99 01 	sts	0x0199, r1
     4d6:	10 92 98 01 	sts	0x0198, r1
    return true;
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	08 95       	ret
  }
  return false;
     4de:	80 e0       	ldi	r24, 0x00	; 0
}
     4e0:	08 95       	ret

000004e2 <__vector_9>:
  }
}

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
{
     4e2:	1f 92       	push	r1
     4e4:	0f 92       	push	r0
     4e6:	0f b6       	in	r0, 0x3f	; 63
     4e8:	0f 92       	push	r0
     4ea:	11 24       	eor	r1, r1
     4ec:	2f 93       	push	r18
     4ee:	3f 93       	push	r19
     4f0:	4f 93       	push	r20
     4f2:	5f 93       	push	r21
     4f4:	6f 93       	push	r22
     4f6:	7f 93       	push	r23
     4f8:	8f 93       	push	r24
     4fa:	9f 93       	push	r25
     4fc:	af 93       	push	r26
     4fe:	bf 93       	push	r27
     500:	ef 93       	push	r30
     502:	ff 93       	push	r31
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
     504:	e0 91 98 01 	lds	r30, 0x0198
     508:	f0 91 99 01 	lds	r31, 0x0199
     50c:	30 97       	sbiw	r30, 0x00	; 0
     50e:	09 f4       	brne	.+2      	; 0x512 <__vector_9+0x30>
     510:	5b c0       	rjmp	.+182    	; 0x5c8 <__vector_9+0xe6>

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
     512:	86 8d       	ldd	r24, Z+30	; 0x1e
     514:	81 ff       	sbrs	r24, 1
     516:	09 c0       	rjmp	.+18     	; 0x52a <__vector_9+0x48>
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     518:	a6 85       	ldd	r26, Z+14	; 0x0e
     51a:	b7 85       	ldd	r27, Z+15	; 0x0f
     51c:	9c 91       	ld	r25, X
     51e:	85 85       	ldd	r24, Z+13	; 0x0d
     520:	98 23       	and	r25, r24

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
     522:	81 e0       	ldi	r24, 0x01	; 1
     524:	51 f4       	brne	.+20     	; 0x53a <__vector_9+0x58>
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	08 c0       	rjmp	.+16     	; 0x53a <__vector_9+0x58>
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     52a:	a6 85       	ldd	r26, Z+14	; 0x0e
     52c:	b7 85       	ldd	r27, Z+15	; 0x0f
     52e:	9c 91       	ld	r25, X
     530:	85 85       	ldd	r24, Z+13	; 0x0d
     532:	98 23       	and	r25, r24

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
     534:	81 e0       	ldi	r24, 0x01	; 1
     536:	09 f0       	breq	.+2      	; 0x53a <__vector_9+0x58>
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	88 23       	and	r24, r24
     53c:	09 f4       	brne	.+2      	; 0x540 <__vector_9+0x5e>
     53e:	44 c0       	rjmp	.+136    	; 0x5c8 <__vector_9+0xe6>
void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
    else
      *_pcint_maskreg &= ~_pcint_maskvalue;
     540:	a3 89       	ldd	r26, Z+19	; 0x13
     542:	b4 89       	ldd	r27, Z+20	; 0x14
     544:	9c 91       	ld	r25, X
     546:	85 89       	ldd	r24, Z+21	; 0x15
     548:	80 95       	com	r24
     54a:	89 23       	and	r24, r25
     54c:	8c 93       	st	X, r24
     54e:	86 89       	ldd	r24, Z+22	; 0x16
     550:	97 89       	ldd	r25, Z+23	; 0x17
     552:	01 97       	sbiw	r24, 0x01	; 1
     554:	f1 f7       	brne	.-4      	; 0x552 <__vector_9+0x70>
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=8; i > 0; --i)
    {
      tunedDelay(_rx_delay_intrabit);
     556:	20 8d       	ldd	r18, Z+24	; 0x18
     558:	31 8d       	ldd	r19, Z+25	; 0x19
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     55a:	a6 85       	ldd	r26, Z+14	; 0x0e
     55c:	b7 85       	ldd	r27, Z+15	; 0x0f
     55e:	75 85       	ldd	r23, Z+13	; 0x0d
     560:	48 e0       	ldi	r20, 0x08	; 8
    "push r26 \n\t"
    "push r27 \n\t"
    ::);
#endif  

  uint8_t d = 0;
     562:	50 e0       	ldi	r21, 0x00	; 0
     564:	c9 01       	movw	r24, r18
     566:	01 97       	sbiw	r24, 0x01	; 1
     568:	f1 f7       	brne	.-4      	; 0x566 <__vector_9+0x84>

    // Read each of the 8 bits
    for (uint8_t i=8; i > 0; --i)
    {
      tunedDelay(_rx_delay_intrabit);
      d >>= 1;
     56a:	85 2f       	mov	r24, r21
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	95 95       	asr	r25
     570:	87 95       	ror	r24
     572:	58 2f       	mov	r21, r24
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     574:	6c 91       	ld	r22, X
     576:	67 23       	and	r22, r23
    for (uint8_t i=8; i > 0; --i)
    {
      tunedDelay(_rx_delay_intrabit);
      d >>= 1;
      DebugPulse(_DEBUG_PIN2, 1);
      if (rx_pin_read())
     578:	09 f0       	breq	.+2      	; 0x57c <__vector_9+0x9a>
        d |= 0x80;
     57a:	50 68       	ori	r21, 0x80	; 128
     57c:	41 50       	subi	r20, 0x01	; 1
    // Wait approximately 1/2 of a bit width to "center" the sample
    tunedDelay(_rx_delay_centering);
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=8; i > 0; --i)
     57e:	91 f7       	brne	.-28     	; 0x564 <__vector_9+0x82>
      DebugPulse(_DEBUG_PIN2, 1);
      if (rx_pin_read())
        d |= 0x80;
    }

    if (_inverse_logic)
     580:	86 8d       	ldd	r24, Z+30	; 0x1e
     582:	81 fd       	sbrc	r24, 1
      d = ~d;
     584:	50 95       	com	r21

    // if buffer full, set the overflow flag and return
    uint8_t next = (_receive_buffer_tail + 1) % _SS_MAX_RX_BUFF;
     586:	20 91 57 01 	lds	r18, 0x0157
     58a:	30 e0       	ldi	r19, 0x00	; 0
     58c:	2f 5f       	subi	r18, 0xFF	; 255
     58e:	3f 4f       	sbci	r19, 0xFF	; 255
     590:	2f 73       	andi	r18, 0x3F	; 63
     592:	30 78       	andi	r19, 0x80	; 128
    if (next != _receive_buffer_head)
     594:	80 91 56 01 	lds	r24, 0x0156
     598:	82 17       	cp	r24, r18
     59a:	49 f0       	breq	.+18     	; 0x5ae <__vector_9+0xcc>
    {
      // save new data in buffer: tail points to where byte goes
      _receive_buffer[_receive_buffer_tail] = d; // save new byte
     59c:	a0 91 57 01 	lds	r26, 0x0157
     5a0:	b0 e0       	ldi	r27, 0x00	; 0
     5a2:	a8 5a       	subi	r26, 0xA8	; 168
     5a4:	be 4f       	sbci	r27, 0xFE	; 254
     5a6:	5c 93       	st	X, r21
      _receive_buffer_tail = next;
     5a8:	20 93 57 01 	sts	0x0157, r18
     5ac:	03 c0       	rjmp	.+6      	; 0x5b4 <__vector_9+0xd2>
    } 
    else 
    {
      DebugPulse(_DEBUG_PIN1, 1);
      _buffer_overflow = true;
     5ae:	86 8d       	ldd	r24, Z+30	; 0x1e
     5b0:	81 60       	ori	r24, 0x01	; 1
     5b2:	86 8f       	std	Z+30, r24	; 0x1e
     5b4:	82 8d       	ldd	r24, Z+26	; 0x1a
     5b6:	93 8d       	ldd	r25, Z+27	; 0x1b
     5b8:	01 97       	sbiw	r24, 0x01	; 1
     5ba:	f1 f7       	brne	.-4      	; 0x5b8 <__vector_9+0xd6>
}

void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
     5bc:	a3 89       	ldd	r26, Z+19	; 0x13
     5be:	b4 89       	ldd	r27, Z+20	; 0x14
     5c0:	9c 91       	ld	r25, X
     5c2:	85 89       	ldd	r24, Z+21	; 0x15
     5c4:	89 2b       	or	r24, r25
     5c6:	8c 93       	st	X, r24

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
{
  SoftwareSerial::handle_interrupt();
}
     5c8:	ff 91       	pop	r31
     5ca:	ef 91       	pop	r30
     5cc:	bf 91       	pop	r27
     5ce:	af 91       	pop	r26
     5d0:	9f 91       	pop	r25
     5d2:	8f 91       	pop	r24
     5d4:	7f 91       	pop	r23
     5d6:	6f 91       	pop	r22
     5d8:	5f 91       	pop	r21
     5da:	4f 91       	pop	r20
     5dc:	3f 91       	pop	r19
     5de:	2f 91       	pop	r18
     5e0:	0f 90       	pop	r0
     5e2:	0f be       	out	0x3f, r0	; 63
     5e4:	0f 90       	pop	r0
     5e6:	1f 90       	pop	r1
     5e8:	18 95       	reti

000005ea <_ZN14SoftwareSerialD1Ev>:
}

//
// Destructor
//
SoftwareSerial::~SoftwareSerial()
     5ea:	2f e0       	ldi	r18, 0x0F	; 15
     5ec:	31 e0       	ldi	r19, 0x01	; 1
     5ee:	fc 01       	movw	r30, r24
     5f0:	31 83       	std	Z+1, r19	; 0x01
     5f2:	20 83       	st	Z, r18
      *_pcint_maskreg &= ~_pcint_maskvalue;
}

void SoftwareSerial::end()
{
  stopListening();
     5f4:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <_ZN14SoftwareSerial13stopListeningEv>
     5f8:	08 95       	ret

000005fa <_ZN14SoftwareSerial5setTXEh>:
{
  end();
}

void SoftwareSerial::setTX(uint8_t tx)
{
     5fa:	1f 93       	push	r17
     5fc:	cf 93       	push	r28
     5fe:	df 93       	push	r29
     600:	ec 01       	movw	r28, r24
     602:	16 2f       	mov	r17, r22
  // First write, then set output. If we do this the other way around,
  // the pin would be output low for a short while before switching to
  // output hihg. Now, it is input with pullup for a short while, which
  // is fine. With inverse logic, either order is fine.
  digitalWrite(tx, _inverse_logic ? LOW : HIGH);
     604:	6e 8d       	ldd	r22, Y+30	; 0x1e
     606:	66 95       	lsr	r22
     608:	61 70       	andi	r22, 0x01	; 1
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	68 27       	eor	r22, r24
     60e:	81 2f       	mov	r24, r17
     610:	0e 94 83 08 	call	0x1106	; 0x1106 <digitalWrite>
  pinMode(tx, OUTPUT);
     614:	61 e0       	ldi	r22, 0x01	; 1
     616:	81 2f       	mov	r24, r17
     618:	0e 94 4a 08 	call	0x1094	; 0x1094 <pinMode>
  _transmitBitMask = digitalPinToBitMask(tx);
     61c:	81 2f       	mov	r24, r17
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	fc 01       	movw	r30, r24
     622:	ec 50       	subi	r30, 0x0C	; 12
     624:	ff 4f       	sbci	r31, 0xFF	; 255
     626:	e4 91       	lpm	r30, Z
     628:	e8 8b       	std	Y+16, r30	; 0x10
  uint8_t port = digitalPinToPort(tx);
     62a:	fc 01       	movw	r30, r24
     62c:	ee 5e       	subi	r30, 0xEE	; 238
     62e:	fe 4f       	sbci	r31, 0xFE	; 254
     630:	e4 91       	lpm	r30, Z
  _transmitPortRegister = portOutputRegister(port);
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	ee 0f       	add	r30, r30
     636:	ff 1f       	adc	r31, r31
     638:	e2 5c       	subi	r30, 0xC2	; 194
     63a:	fe 4f       	sbci	r31, 0xFE	; 254
     63c:	85 91       	lpm	r24, Z+
     63e:	94 91       	lpm	r25, Z
     640:	9a 8b       	std	Y+18, r25	; 0x12
     642:	89 8b       	std	Y+17, r24	; 0x11
}
     644:	df 91       	pop	r29
     646:	cf 91       	pop	r28
     648:	1f 91       	pop	r17
     64a:	08 95       	ret

0000064c <_ZN14SoftwareSerial5setRXEh>:

void SoftwareSerial::setRX(uint8_t rx)
{
     64c:	1f 93       	push	r17
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	ec 01       	movw	r28, r24
     654:	16 2f       	mov	r17, r22
  pinMode(rx, INPUT);
     656:	60 e0       	ldi	r22, 0x00	; 0
     658:	81 2f       	mov	r24, r17
     65a:	0e 94 4a 08 	call	0x1094	; 0x1094 <pinMode>
  if (!_inverse_logic)
     65e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     660:	81 fd       	sbrc	r24, 1
     662:	04 c0       	rjmp	.+8      	; 0x66c <_ZN14SoftwareSerial5setRXEh+0x20>
    digitalWrite(rx, HIGH);  // pullup for normal logic!
     664:	61 e0       	ldi	r22, 0x01	; 1
     666:	81 2f       	mov	r24, r17
     668:	0e 94 83 08 	call	0x1106	; 0x1106 <digitalWrite>
  _receivePin = rx;
     66c:	1c 87       	std	Y+12, r17	; 0x0c
  _receiveBitMask = digitalPinToBitMask(rx);
     66e:	61 2f       	mov	r22, r17
     670:	70 e0       	ldi	r23, 0x00	; 0
     672:	fb 01       	movw	r30, r22
     674:	ec 50       	subi	r30, 0x0C	; 12
     676:	ff 4f       	sbci	r31, 0xFF	; 255
     678:	e4 91       	lpm	r30, Z
     67a:	ed 87       	std	Y+13, r30	; 0x0d
  uint8_t port = digitalPinToPort(rx);
     67c:	fb 01       	movw	r30, r22
     67e:	ee 5e       	subi	r30, 0xEE	; 238
     680:	fe 4f       	sbci	r31, 0xFE	; 254
     682:	e4 91       	lpm	r30, Z
  _receivePortRegister = portInputRegister(port);
     684:	f0 e0       	ldi	r31, 0x00	; 0
     686:	ee 0f       	add	r30, r30
     688:	ff 1f       	adc	r31, r31
     68a:	e0 5d       	subi	r30, 0xD0	; 208
     68c:	fe 4f       	sbci	r31, 0xFE	; 254
     68e:	85 91       	lpm	r24, Z+
     690:	94 91       	lpm	r25, Z
     692:	9f 87       	std	Y+15, r25	; 0x0f
     694:	8e 87       	std	Y+14, r24	; 0x0e
}
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	1f 91       	pop	r17
     69c:	08 95       	ret

0000069e <_ZN14SoftwareSerialC1Ehhb>:
#endif

//
// Constructor
//
SoftwareSerial::SoftwareSerial(uint8_t receivePin, uint8_t transmitPin, bool inverse_logic /* = false */) : 
     69e:	ff 92       	push	r15
     6a0:	0f 93       	push	r16
     6a2:	1f 93       	push	r17
     6a4:	cf 93       	push	r28
     6a6:	df 93       	push	r29
     6a8:	ec 01       	movw	r28, r24
     6aa:	f6 2e       	mov	r15, r22
     6ac:	52 2f       	mov	r21, r18
  public:
    Print() : write_error(0) {}
     6ae:	1b 82       	std	Y+3, r1	; 0x03
     6b0:	1a 82       	std	Y+2, r1	; 0x02
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
     6b2:	08 ee       	ldi	r16, 0xE8	; 232
     6b4:	13 e0       	ldi	r17, 0x03	; 3
     6b6:	20 e0       	ldi	r18, 0x00	; 0
     6b8:	30 e0       	ldi	r19, 0x00	; 0
     6ba:	0c 83       	std	Y+4, r16	; 0x04
     6bc:	1d 83       	std	Y+5, r17	; 0x05
     6be:	2e 83       	std	Y+6, r18	; 0x06
     6c0:	3f 83       	std	Y+7, r19	; 0x07
  _rx_delay_centering(0),
  _rx_delay_intrabit(0),
  _rx_delay_stopbit(0),
  _tx_delay(0),
  _buffer_overflow(false),
  _inverse_logic(inverse_logic)
     6c2:	8f e0       	ldi	r24, 0x0F	; 15
     6c4:	91 e0       	ldi	r25, 0x01	; 1
     6c6:	99 83       	std	Y+1, r25	; 0x01
     6c8:	88 83       	st	Y, r24
     6ca:	1f 8a       	std	Y+23, r1	; 0x17
     6cc:	1e 8a       	std	Y+22, r1	; 0x16
     6ce:	19 8e       	std	Y+25, r1	; 0x19
     6d0:	18 8e       	std	Y+24, r1	; 0x18
     6d2:	1b 8e       	std	Y+27, r1	; 0x1b
     6d4:	1a 8e       	std	Y+26, r1	; 0x1a
     6d6:	1d 8e       	std	Y+29, r1	; 0x1d
     6d8:	1c 8e       	std	Y+28, r1	; 0x1c
     6da:	8e 8d       	ldd	r24, Y+30	; 0x1e
     6dc:	8e 7f       	andi	r24, 0xFE	; 254
     6de:	50 fb       	bst	r21, 0
     6e0:	81 f9       	bld	r24, 1
     6e2:	8e 8f       	std	Y+30, r24	; 0x1e
{
  setTX(transmitPin);
     6e4:	64 2f       	mov	r22, r20
     6e6:	ce 01       	movw	r24, r28
     6e8:	0e 94 fd 02 	call	0x5fa	; 0x5fa <_ZN14SoftwareSerial5setTXEh>
  setRX(receivePin);
     6ec:	6f 2d       	mov	r22, r15
     6ee:	ce 01       	movw	r24, r28
     6f0:	0e 94 26 03 	call	0x64c	; 0x64c <_ZN14SoftwareSerial5setRXEh>
}
     6f4:	df 91       	pop	r29
     6f6:	cf 91       	pop	r28
     6f8:	1f 91       	pop	r17
     6fa:	0f 91       	pop	r16
     6fc:	ff 90       	pop	r15
     6fe:	08 95       	ret

00000700 <_GLOBAL__sub_I_int8Transfer>:
#include "telemetry.h"
#include "power_control.h"

TransferInt8   int8Transfer;
TransferFloat  floatTransfer;
SoftwareSerial mySerial(0,1);
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	41 e0       	ldi	r20, 0x01	; 1
     704:	60 e0       	ldi	r22, 0x00	; 0
     706:	8a e9       	ldi	r24, 0x9A	; 154
     708:	91 e0       	ldi	r25, 0x01	; 1
     70a:	0e 94 4f 03 	call	0x69e	; 0x69e <_ZN14SoftwareSerialC1Ehhb>
     70e:	08 95       	ret

00000710 <_GLOBAL__sub_D_int8Transfer>:
     710:	8a e9       	ldi	r24, 0x9A	; 154
     712:	91 e0       	ldi	r25, 0x01	; 1
     714:	0e 94 f5 02 	call	0x5ea	; 0x5ea <_ZN14SoftwareSerialD1Ev>
     718:	08 95       	ret

0000071a <_Z22readMotorConfigurationj>:
		writeLocation += sizeof(int);
	}
}

void readMotorConfiguration(uint16_t startReadLocation)
{
     71a:	ef 92       	push	r14
     71c:	ff 92       	push	r15
     71e:	0f 93       	push	r16
     720:	1f 93       	push	r17
     722:	cf 93       	push	r28
     724:	df 93       	push	r29
     726:	ec 01       	movw	r28, r24
     728:	06 ec       	ldi	r16, 0xC6	; 198
     72a:	11 e0       	ldi	r17, 0x01	; 1
     72c:	7c 01       	movw	r14, r24
     72e:	8e e0       	ldi	r24, 0x0E	; 14
     730:	e8 0e       	add	r14, r24
     732:	f1 1c       	adc	r15, r1

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     734:	ce 01       	movw	r24, r28
     736:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__eerd_byte_m32u4>
     73a:	f8 01       	movw	r30, r16
     73c:	31 97       	sbiw	r30, 0x01	; 1
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
     73e:	80 83       	st	Z, r24

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     740:	ce 01       	movw	r24, r28
     742:	01 96       	adiw	r24, 0x01	; 1
     744:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__eerd_byte_m32u4>
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
     748:	f8 01       	movw	r30, r16
     74a:	80 83       	st	Z, r24
	uint8_t i;
	// put code here to read data from thingy and enter it into array to use for read conversions
	for(i = 0; i < NUM_MOTORS; ++i)
	{
		EEPROM.get(startReadLocation, motorZeroValue[i]);
		startReadLocation += sizeof(uint16_t);
     74c:	22 96       	adiw	r28, 0x02	; 2
     74e:	0e 5f       	subi	r16, 0xFE	; 254
     750:	1f 4f       	sbci	r17, 0xFF	; 255

void readMotorConfiguration(uint16_t startReadLocation)
{
	uint8_t i;
	// put code here to read data from thingy and enter it into array to use for read conversions
	for(i = 0; i < NUM_MOTORS; ++i)
     752:	ce 15       	cp	r28, r14
     754:	df 05       	cpc	r29, r15
     756:	71 f7       	brne	.-36     	; 0x734 <_Z22readMotorConfigurationj+0x1a>
	{
		EEPROM.get(startReadLocation, motorZeroValue[i]);
		startReadLocation += sizeof(uint16_t);
	}
}
     758:	df 91       	pop	r29
     75a:	cf 91       	pop	r28
     75c:	1f 91       	pop	r17
     75e:	0f 91       	pop	r16
     760:	ff 90       	pop	r15
     762:	ef 90       	pop	r14
     764:	08 95       	ret

00000766 <initVariant>:
void loop();

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
     766:	08 95       	ret

00000768 <setup>:
uint32_t nextPowerReading;
uint32_t nextTelemUpdate;

void setup() 
{
	initializePowerBusses();
     768:	0e 94 5d 05 	call	0xaba	; 0xaba <_Z21initializePowerBussesv>
	turnOnAllMotors();
     76c:	0e 94 c6 04 	call	0x98c	; 0x98c <_Z15turnOnAllMotorsv>
	
	nextPowerReading = 0;
     770:	10 92 bd 01 	sts	0x01BD, r1
     774:	10 92 be 01 	sts	0x01BE, r1
     778:	10 92 bf 01 	sts	0x01BF, r1
     77c:	10 92 c0 01 	sts	0x01C0, r1
	nextTelemUpdate  = 5000;
     780:	88 e8       	ldi	r24, 0x88	; 136
     782:	93 e1       	ldi	r25, 0x13	; 19
     784:	a0 e0       	ldi	r26, 0x00	; 0
     786:	b0 e0       	ldi	r27, 0x00	; 0
     788:	80 93 b9 01 	sts	0x01B9, r24
     78c:	90 93 ba 01 	sts	0x01BA, r25
     790:	a0 93 bb 01 	sts	0x01BB, r26
     794:	b0 93 bc 01 	sts	0x01BC, r27
     798:	08 95       	ret

0000079a <loop>:
}

void loop()
{
     79a:	0f 93       	push	r16
     79c:	1f 93       	push	r17
	// put your main code here, to run repeatedly:
	time = millis();
     79e:	0e 94 2f 07 	call	0xe5e	; 0xe5e <millis>
     7a2:	60 93 c1 01 	sts	0x01C1, r22
     7a6:	70 93 c2 01 	sts	0x01C2, r23
     7aa:	80 93 c3 01 	sts	0x01C3, r24
     7ae:	90 93 c4 01 	sts	0x01C4, r25
	
	if( nextPowerReading < time )
     7b2:	00 91 bd 01 	lds	r16, 0x01BD
     7b6:	10 91 be 01 	lds	r17, 0x01BE
     7ba:	20 91 bf 01 	lds	r18, 0x01BF
     7be:	30 91 c0 01 	lds	r19, 0x01C0
     7c2:	06 17       	cp	r16, r22
     7c4:	17 07       	cpc	r17, r23
     7c6:	28 07       	cpc	r18, r24
     7c8:	39 07       	cpc	r19, r25
     7ca:	90 f4       	brcc	.+36     	; 0x7f0 <loop+0x56>
	{
		nextPowerReading = millis() + MILLIS_BETWEEN_POWER_UPDATE;
     7cc:	0e 94 2f 07 	call	0xe5e	; 0xe5e <millis>
     7d0:	dc 01       	movw	r26, r24
     7d2:	cb 01       	movw	r24, r22
     7d4:	8c 59       	subi	r24, 0x9C	; 156
     7d6:	9f 4f       	sbci	r25, 0xFF	; 255
     7d8:	af 4f       	sbci	r26, 0xFF	; 255
     7da:	bf 4f       	sbci	r27, 0xFF	; 255
     7dc:	80 93 bd 01 	sts	0x01BD, r24
     7e0:	90 93 be 01 	sts	0x01BE, r25
     7e4:	a0 93 bf 01 	sts	0x01BF, r26
     7e8:	b0 93 c0 01 	sts	0x01C0, r27
		readMotorCurrents();		
     7ec:	0e 94 38 04 	call	0x870	; 0x870 <_Z17readMotorCurrentsv>
	}
	
	if( nextTelemUpdate < time )
     7f0:	40 91 b9 01 	lds	r20, 0x01B9
     7f4:	50 91 ba 01 	lds	r21, 0x01BA
     7f8:	60 91 bb 01 	lds	r22, 0x01BB
     7fc:	70 91 bc 01 	lds	r23, 0x01BC
     800:	80 91 c1 01 	lds	r24, 0x01C1
     804:	90 91 c2 01 	lds	r25, 0x01C2
     808:	a0 91 c3 01 	lds	r26, 0x01C3
     80c:	b0 91 c4 01 	lds	r27, 0x01C4
     810:	48 17       	cp	r20, r24
     812:	59 07       	cpc	r21, r25
     814:	6a 07       	cpc	r22, r26
     816:	7b 07       	cpc	r23, r27
     818:	80 f4       	brcc	.+32     	; 0x83a <loop+0xa0>
	{
		nextTelemUpdate = millis() + MILLIS_BETWEEN_TELEM_UPDATE;
     81a:	0e 94 2f 07 	call	0xe5e	; 0xe5e <millis>
     81e:	dc 01       	movw	r26, r24
     820:	cb 01       	movw	r24, r22
     822:	88 51       	subi	r24, 0x18	; 24
     824:	9c 4f       	sbci	r25, 0xFC	; 252
     826:	af 4f       	sbci	r26, 0xFF	; 255
     828:	bf 4f       	sbci	r27, 0xFF	; 255
     82a:	80 93 b9 01 	sts	0x01B9, r24
     82e:	90 93 ba 01 	sts	0x01BA, r25
     832:	a0 93 bb 01 	sts	0x01BB, r26
     836:	b0 93 bc 01 	sts	0x01BC, r27
		/* update telemetry here */
	}
}
     83a:	1f 91       	pop	r17
     83c:	0f 91       	pop	r16
     83e:	08 95       	ret

00000840 <main>:
void ErrorMessage(const char *file, const int lineNumber);

int main(void)
{
	// Start the platform
	init();
     840:	0e 94 86 07 	call	0xf0c	; 0xf0c <init>
	initVariant();
     844:	0e 94 b3 03 	call	0x766	; 0x766 <initVariant>
	USBDevice.attach();
     848:	83 e5       	ldi	r24, 0x53	; 83
     84a:	92 e0       	ldi	r25, 0x02	; 2
     84c:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <_ZN10USBDevice_6attachEv>

	// Call setup
	setup();
     850:	0e 94 b4 03 	call	0x768	; 0x768 <setup>
	
	while (1)
	{
		// Main loop function
		loop();
     854:	0e 94 cd 03 	call	0x79a	; 0x79a <loop>
		
		// Check for USB serial events
		if (serialEventRun)
     858:	80 e0       	ldi	r24, 0x00	; 0
     85a:	90 e0       	ldi	r25, 0x00	; 0
     85c:	89 2b       	or	r24, r25
     85e:	29 f0       	breq	.+10     	; 0x86a <main+0x2a>
		{
			serialEventRun();
     860:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	setup();
	
	while (1)
	{
		// Main loop function
		loop();
     864:	0e 94 cd 03 	call	0x79a	; 0x79a <loop>
     868:	fb cf       	rjmp	.-10     	; 0x860 <main+0x20>
     86a:	0e 94 cd 03 	call	0x79a	; 0x79a <loop>
     86e:	fd cf       	rjmp	.-6      	; 0x86a <main+0x2a>

00000870 <_Z17readMotorCurrentsv>:
	
	turnOnAllMotors();
}

void readMotorCurrents()
{
     870:	2f 92       	push	r2
     872:	3f 92       	push	r3
     874:	4f 92       	push	r4
     876:	5f 92       	push	r5
     878:	6f 92       	push	r6
     87a:	7f 92       	push	r7
     87c:	8f 92       	push	r8
     87e:	9f 92       	push	r9
     880:	af 92       	push	r10
     882:	bf 92       	push	r11
     884:	cf 92       	push	r12
     886:	df 92       	push	r13
     888:	ef 92       	push	r14
     88a:	ff 92       	push	r15
     88c:	0f 93       	push	r16
     88e:	1f 93       	push	r17
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	0f 2e       	mov	r0, r31
     896:	fb e1       	ldi	r31, 0x1B	; 27
     898:	af 2e       	mov	r10, r31
     89a:	f1 e0       	ldi	r31, 0x01	; 1
     89c:	bf 2e       	mov	r11, r31
     89e:	f0 2d       	mov	r31, r0
     8a0:	0f 2e       	mov	r0, r31
     8a2:	f5 ec       	ldi	r31, 0xC5	; 197
     8a4:	8f 2e       	mov	r8, r31
     8a6:	f1 e0       	ldi	r31, 0x01	; 1
     8a8:	9f 2e       	mov	r9, r31
     8aa:	f0 2d       	mov	r31, r0
     8ac:	0f 2e       	mov	r0, r31
     8ae:	fa ed       	ldi	r31, 0xDA	; 218
     8b0:	2f 2e       	mov	r2, r31
     8b2:	f1 e0       	ldi	r31, 0x01	; 1
     8b4:	3f 2e       	mov	r3, r31
     8b6:	f0 2d       	mov	r31, r0
     8b8:	0f 2e       	mov	r0, r31
     8ba:	f9 e2       	ldi	r31, 0x29	; 41
     8bc:	cf 2e       	mov	r12, r31
     8be:	f1 e0       	ldi	r31, 0x01	; 1
     8c0:	df 2e       	mov	r13, r31
     8c2:	f0 2d       	mov	r31, r0
     8c4:	c3 ed       	ldi	r28, 0xD3	; 211
     8c6:	d1 e0       	ldi	r29, 0x01	; 1
     8c8:	00 e0       	ldi	r16, 0x00	; 0
     8ca:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t i;
	int tempRead;

	for(i = 0; i < NUM_MOTORS; ++i)
	{
		tempRead = analogRead(MOTOR_READ_PIN[i]);
     8cc:	d5 01       	movw	r26, r10
     8ce:	8d 91       	ld	r24, X+
     8d0:	5d 01       	movw	r10, r26
     8d2:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <analogRead>
		/* transforming a range of 0 - 1023 to a range of -50 to 50 */
		motorVoltageValues[i] = (tempRead - motorZeroValue[i]) * 50.0/motorZeroValue[i];
     8d6:	f4 01       	movw	r30, r8
     8d8:	e1 90       	ld	r14, Z+
     8da:	f1 90       	ld	r15, Z+
     8dc:	4f 01       	movw	r8, r30
     8de:	8e 19       	sub	r24, r14
     8e0:	9f 09       	sbc	r25, r15
     8e2:	bc 01       	movw	r22, r24
     8e4:	80 e0       	ldi	r24, 0x00	; 0
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	0e 94 cc 05 	call	0xb98	; 0xb98 <__floatunsisf>
     8ec:	20 e0       	ldi	r18, 0x00	; 0
     8ee:	30 e0       	ldi	r19, 0x00	; 0
     8f0:	48 e4       	ldi	r20, 0x48	; 72
     8f2:	52 e4       	ldi	r21, 0x42	; 66
     8f4:	0e 94 5e 06 	call	0xcbc	; 0xcbc <__mulsf3>
     8f8:	2b 01       	movw	r4, r22
     8fa:	3c 01       	movw	r6, r24
     8fc:	b7 01       	movw	r22, r14
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	0e 94 cc 05 	call	0xb98	; 0xb98 <__floatunsisf>
     906:	9b 01       	movw	r18, r22
     908:	ac 01       	movw	r20, r24
     90a:	c3 01       	movw	r24, r6
     90c:	b2 01       	movw	r22, r4
     90e:	0e 94 64 05 	call	0xac8	; 0xac8 <__divsf3>
     912:	d1 01       	movw	r26, r2
     914:	6d 93       	st	X+, r22
     916:	7d 93       	st	X+, r23
     918:	8d 93       	st	X+, r24
     91a:	9d 93       	st	X+, r25
     91c:	1d 01       	movw	r2, r26
		if( motorVoltageValues[i] > MAX_MOTOR_CURRENT )
     91e:	20 e0       	ldi	r18, 0x00	; 0
     920:	30 e0       	ldi	r19, 0x00	; 0
     922:	48 ec       	ldi	r20, 0xC8	; 200
     924:	51 e4       	ldi	r21, 0x41	; 65
     926:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <__gesf2>
     92a:	18 16       	cp	r1, r24
     92c:	8c f4       	brge	.+34     	; 0x950 <_Z17readMotorCurrentsv+0xe0>
		{
			numOverCurrentReads[i]++;
     92e:	88 81       	ld	r24, Y
     930:	8f 5f       	subi	r24, 0xFF	; 255
     932:	88 83       	st	Y, r24
			if (numOverCurrentReads[i] == NUM_CURRENT_READS_TRIGGER_FAULT )
     934:	85 30       	cpi	r24, 0x05	; 5
     936:	69 f4       	brne	.+26     	; 0x952 <_Z17readMotorCurrentsv+0xe2>
	}
}

inline void turnOffMotorController(const uint8_t motorNumber)
{
	*MOTOR_SIGNAL_PORT[motorNumber] &= ~(MOTOR_SIGNAL_PIN[motorNumber]);
     938:	d6 01       	movw	r26, r12
     93a:	ed 91       	ld	r30, X+
     93c:	fc 91       	ld	r31, X
     93e:	90 81       	ld	r25, Z
     940:	d8 01       	movw	r26, r16
     942:	ae 5d       	subi	r26, 0xDE	; 222
     944:	be 4f       	sbci	r27, 0xFE	; 254
     946:	8c 91       	ld	r24, X
     948:	80 95       	com	r24
     94a:	89 23       	and	r24, r25
     94c:	80 83       	st	Z, r24
     94e:	01 c0       	rjmp	.+2      	; 0x952 <_Z17readMotorCurrentsv+0xe2>
				turnOffMotorController(i);
			}
		}
		else
		{
			numOverCurrentReads[i] = 0;
     950:	18 82       	st	Y, r1
     952:	0f 5f       	subi	r16, 0xFF	; 255
     954:	1f 4f       	sbci	r17, 0xFF	; 255
     956:	b2 e0       	ldi	r27, 0x02	; 2
     958:	cb 0e       	add	r12, r27
     95a:	d1 1c       	adc	r13, r1
     95c:	21 96       	adiw	r28, 0x01	; 1
void readMotorCurrents()
{
	uint8_t i;
	int tempRead;

	for(i = 0; i < NUM_MOTORS; ++i)
     95e:	07 30       	cpi	r16, 0x07	; 7
     960:	11 05       	cpc	r17, r1
     962:	09 f0       	breq	.+2      	; 0x966 <_Z17readMotorCurrentsv+0xf6>
     964:	b3 cf       	rjmp	.-154    	; 0x8cc <_Z17readMotorCurrentsv+0x5c>
		else
		{
			numOverCurrentReads[i] = 0;
		}
	}
}
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	1f 91       	pop	r17
     96c:	0f 91       	pop	r16
     96e:	ff 90       	pop	r15
     970:	ef 90       	pop	r14
     972:	df 90       	pop	r13
     974:	cf 90       	pop	r12
     976:	bf 90       	pop	r11
     978:	af 90       	pop	r10
     97a:	9f 90       	pop	r9
     97c:	8f 90       	pop	r8
     97e:	7f 90       	pop	r7
     980:	6f 90       	pop	r6
     982:	5f 90       	pop	r5
     984:	4f 90       	pop	r4
     986:	3f 90       	pop	r3
     988:	2f 90       	pop	r2
     98a:	08 95       	ret

0000098c <_Z15turnOnAllMotorsv>:
	*MOTOR_SIGNAL_PORT[motorNumber] |= MOTOR_SIGNAL_PIN[motorNumber];
}

void turnOnAllMotors()
{
	PORTB |= motorSingalPorts[0];
     98c:	95 b1       	in	r25, 0x05	; 5
     98e:	80 91 f6 01 	lds	r24, 0x01F6
     992:	89 2b       	or	r24, r25
     994:	85 b9       	out	0x05, r24	; 5
	PORTC |= motorSingalPorts[1];
     996:	98 b1       	in	r25, 0x08	; 8
     998:	80 91 f7 01 	lds	r24, 0x01F7
     99c:	89 2b       	or	r24, r25
     99e:	88 b9       	out	0x08, r24	; 8
	PORTD |= motorSingalPorts[2];
     9a0:	9b b1       	in	r25, 0x0b	; 11
     9a2:	80 91 f8 01 	lds	r24, 0x01F8
     9a6:	89 2b       	or	r24, r25
     9a8:	8b b9       	out	0x0b, r24	; 11
	PORTE |= motorSingalPorts[3];
     9aa:	9e b1       	in	r25, 0x0e	; 14
     9ac:	80 91 f9 01 	lds	r24, 0x01F9
     9b0:	89 2b       	or	r24, r25
     9b2:	8e b9       	out	0x0e, r24	; 14
     9b4:	08 95       	ret

000009b6 <_Z25initializeMotorControllerv>:
	TWELVE_V_REG  |= TWELVE_V_PIN;
	TWELVE_V_PORT |= TWELVE_V_PIN;
}

void initializeMotorController()
{
     9b6:	ef 92       	push	r14
     9b8:	ff 92       	push	r15
     9ba:	0f 93       	push	r16
     9bc:	1f 93       	push	r17
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	00 d0       	rcall	.+0      	; 0x9c4 <_Z25initializeMotorControllerv+0xe>
     9c4:	cd b7       	in	r28, 0x3d	; 61
     9c6:	de b7       	in	r29, 0x3e	; 62
     9c8:	60 91 f6 01 	lds	r22, 0x01F6
     9cc:	70 91 f7 01 	lds	r23, 0x01F7
     9d0:	10 91 f8 01 	lds	r17, 0x01F8
     9d4:	00 91 f9 01 	lds	r16, 0x01F9
     9d8:	e9 e2       	ldi	r30, 0x29	; 41
     9da:	f1 e0       	ldi	r31, 0x01	; 1
     9dc:	23 ed       	ldi	r18, 0xD3	; 211
     9de:	31 e0       	ldi	r19, 0x01	; 1
     9e0:	0f 2e       	mov	r0, r31
     9e2:	f2 e2       	ldi	r31, 0x22	; 34
     9e4:	ef 2e       	mov	r14, r31
     9e6:	f1 e0       	ldi	r31, 0x01	; 1
     9e8:	ff 2e       	mov	r15, r31
     9ea:	f0 2d       	mov	r31, r0
     9ec:	47 e3       	ldi	r20, 0x37	; 55
     9ee:	51 e0       	ldi	r21, 0x01	; 1
	uint16_t temp16;         /* temp eeprom read value */
	extern uint8_t motorSingalPorts[NUM_IO_PORTS];

	for( i = 0; i < NUM_MOTORS; ++i ) /* iterate over the number of motors */
	{
		if( MOTOR_SIGNAL_PORT[i] == &PORTB )      /* get all motors signals of port B */
     9f0:	81 91       	ld	r24, Z+
     9f2:	91 91       	ld	r25, Z+
     9f4:	85 32       	cpi	r24, 0x25	; 37
     9f6:	91 05       	cpc	r25, r1
     9f8:	21 f4       	brne	.+8      	; 0xa02 <_Z25initializeMotorControllerv+0x4c>
		{
			motorSingalPorts[0] |= MOTOR_SIGNAL_PIN[i];
     9fa:	d7 01       	movw	r26, r14
     9fc:	8c 91       	ld	r24, X
     9fe:	68 2b       	or	r22, r24
     a00:	13 c0       	rjmp	.+38     	; 0xa28 <_Z25initializeMotorControllerv+0x72>
		}
		else if( MOTOR_SIGNAL_PORT[i] == &PORTC ) /* get all motors signals of port C */
     a02:	88 32       	cpi	r24, 0x28	; 40
     a04:	91 05       	cpc	r25, r1
     a06:	21 f4       	brne	.+8      	; 0xa10 <_Z25initializeMotorControllerv+0x5a>
		{
			motorSingalPorts[1] |= MOTOR_SIGNAL_PIN[i];
     a08:	d7 01       	movw	r26, r14
     a0a:	8c 91       	ld	r24, X
     a0c:	78 2b       	or	r23, r24
     a0e:	0c c0       	rjmp	.+24     	; 0xa28 <_Z25initializeMotorControllerv+0x72>
		}
		else if( MOTOR_SIGNAL_PORT[i] == &PORTD ) /* get all motors signals of port D */
     a10:	8b 32       	cpi	r24, 0x2B	; 43
     a12:	91 05       	cpc	r25, r1
     a14:	21 f4       	brne	.+8      	; 0xa1e <_Z25initializeMotorControllerv+0x68>
		{
			motorSingalPorts[2] |= MOTOR_SIGNAL_PIN[i];
     a16:	d7 01       	movw	r26, r14
     a18:	8c 91       	ld	r24, X
     a1a:	18 2b       	or	r17, r24
     a1c:	05 c0       	rjmp	.+10     	; 0xa28 <_Z25initializeMotorControllerv+0x72>
		}
		else if( MOTOR_SIGNAL_PORT[i] == &PORTE ) /* get all motors signals of port E */
     a1e:	8e 97       	sbiw	r24, 0x2e	; 46
     a20:	19 f4       	brne	.+6      	; 0xa28 <_Z25initializeMotorControllerv+0x72>
		{
			motorSingalPorts[3] |= MOTOR_SIGNAL_PIN[i];
     a22:	d7 01       	movw	r26, r14
     a24:	8c 91       	ld	r24, X
     a26:	08 2b       	or	r16, r24
		}
		numOverCurrentReads[i] = 0;
     a28:	d9 01       	movw	r26, r18
     a2a:	1d 92       	st	X+, r1
     a2c:	9d 01       	movw	r18, r26
     a2e:	bf ef       	ldi	r27, 0xFF	; 255
     a30:	eb 1a       	sub	r14, r27
     a32:	fb 0a       	sbc	r15, r27
{
	uint8_t i;               /* loop iterator */
	uint16_t temp16;         /* temp eeprom read value */
	extern uint8_t motorSingalPorts[NUM_IO_PORTS];

	for( i = 0; i < NUM_MOTORS; ++i ) /* iterate over the number of motors */
     a34:	e4 17       	cp	r30, r20
     a36:	f5 07       	cpc	r31, r21
     a38:	d9 f6       	brne	.-74     	; 0x9f0 <_Z25initializeMotorControllerv+0x3a>
     a3a:	60 93 f6 01 	sts	0x01F6, r22
     a3e:	70 93 f7 01 	sts	0x01F7, r23
     a42:	10 93 f8 01 	sts	0x01F8, r17
     a46:	00 93 f9 01 	sts	0x01F9, r16

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     a4a:	80 e0       	ldi	r24, 0x00	; 0
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__eerd_byte_m32u4>
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
     a52:	89 83       	std	Y+1, r24	; 0x01

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     a54:	81 e0       	ldi	r24, 0x01	; 1
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__eerd_byte_m32u4>
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
     a5c:	8a 83       	std	Y+2, r24	; 0x02

	/* read tell byte from eeprom */
	EEPROM.get(0, temp16);

	/* check if we should grab zero values from eeprom or predefined values */
	if(temp16 != 0)
     a5e:	89 81       	ldd	r24, Y+1	; 0x01
     a60:	9a 81       	ldd	r25, Y+2	; 0x02
     a62:	89 2b       	or	r24, r25
     a64:	29 f0       	breq	.+10     	; 0xa70 <_Z25initializeMotorControllerv+0xba>
	{
		i += sizeof(uint16_t);
		readMotorConfiguration(i); /* grab from eeprom */
     a66:	89 e0       	ldi	r24, 0x09	; 9
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	0e 94 8d 03 	call	0x71a	; 0x71a <_Z22readMotorConfigurationj>
     a6e:	06 c0       	rjmp	.+12     	; 0xa7c <_Z25initializeMotorControllerv+0xc6>
	}
	else
	{
		for(i = 0; i < NUM_MOTORS; ++ i);
		{
			motorZeroValue[i] = MID_ANALOG_READ_VALUE; /* predefine them */
     a70:	8f ef       	ldi	r24, 0xFF	; 255
     a72:	91 e0       	ldi	r25, 0x01	; 1
     a74:	90 93 d4 01 	sts	0x01D4, r25
     a78:	80 93 d3 01 	sts	0x01D3, r24
		}
	}

	DDRB |= motorSingalPorts[0]; /* set pins as output */
     a7c:	94 b1       	in	r25, 0x04	; 4
     a7e:	80 91 f6 01 	lds	r24, 0x01F6
     a82:	89 2b       	or	r24, r25
     a84:	84 b9       	out	0x04, r24	; 4
	DDRC |= motorSingalPorts[1]; /* set pins as output */
     a86:	97 b1       	in	r25, 0x07	; 7
     a88:	80 91 f7 01 	lds	r24, 0x01F7
     a8c:	89 2b       	or	r24, r25
     a8e:	87 b9       	out	0x07, r24	; 7
	DDRD |= motorSingalPorts[2]; /* set pins as output */
     a90:	9a b1       	in	r25, 0x0a	; 10
     a92:	80 91 f8 01 	lds	r24, 0x01F8
     a96:	89 2b       	or	r24, r25
     a98:	8a b9       	out	0x0a, r24	; 10
	DDRE |= motorSingalPorts[3]; /* set pins as output */
     a9a:	9d b1       	in	r25, 0x0d	; 13
     a9c:	80 91 f9 01 	lds	r24, 0x01F9
     aa0:	89 2b       	or	r24, r25
     aa2:	8d b9       	out	0x0d, r24	; 13
	
	turnOnAllMotors();
     aa4:	0e 94 c6 04 	call	0x98c	; 0x98c <_Z15turnOnAllMotorsv>
}
     aa8:	0f 90       	pop	r0
     aaa:	0f 90       	pop	r0
     aac:	df 91       	pop	r29
     aae:	cf 91       	pop	r28
     ab0:	1f 91       	pop	r17
     ab2:	0f 91       	pop	r16
     ab4:	ff 90       	pop	r15
     ab6:	ef 90       	pop	r14
     ab8:	08 95       	ret

00000aba <_Z21initializePowerBussesv>:
uint8_t numOverCurrentReads[NUM_MOTORS];
uint16_t motorZeroValue[NUM_MOTORS];

void initializePowerBusses()
{
	initializeMotorController();
     aba:	0e 94 db 04 	call	0x9b6	; 0x9b6 <_Z25initializeMotorControllerv>
	
	/* turn on all other busses */
	THIRTY_V_EX_REG  |= THIRTY_V_EX_PIN;
     abe:	6e 9a       	sbi	0x0d, 6	; 13
	THIRTY_V_EX_PORT |= THIRTY_V_EX_PIN;
     ac0:	76 9a       	sbi	0x0e, 6	; 14
	TWELVE_V_REG  |= TWELVE_V_PIN;
     ac2:	20 9a       	sbi	0x04, 0	; 4
	TWELVE_V_PORT |= TWELVE_V_PIN;
     ac4:	28 9a       	sbi	0x05, 0	; 5
     ac6:	08 95       	ret

00000ac8 <__divsf3>:
     ac8:	0c d0       	rcall	.+24     	; 0xae2 <__divsf3x>
     aca:	ba c0       	rjmp	.+372    	; 0xc40 <__fp_round>
     acc:	b2 d0       	rcall	.+356    	; 0xc32 <__fp_pscB>
     ace:	40 f0       	brcs	.+16     	; 0xae0 <__divsf3+0x18>
     ad0:	a9 d0       	rcall	.+338    	; 0xc24 <__fp_pscA>
     ad2:	30 f0       	brcs	.+12     	; 0xae0 <__divsf3+0x18>
     ad4:	21 f4       	brne	.+8      	; 0xade <__divsf3+0x16>
     ad6:	5f 3f       	cpi	r21, 0xFF	; 255
     ad8:	19 f0       	breq	.+6      	; 0xae0 <__divsf3+0x18>
     ada:	9b c0       	rjmp	.+310    	; 0xc12 <__fp_inf>
     adc:	51 11       	cpse	r21, r1
     ade:	e4 c0       	rjmp	.+456    	; 0xca8 <__fp_szero>
     ae0:	9e c0       	rjmp	.+316    	; 0xc1e <__fp_nan>

00000ae2 <__divsf3x>:
     ae2:	bf d0       	rcall	.+382    	; 0xc62 <__fp_split3>
     ae4:	98 f3       	brcs	.-26     	; 0xacc <__divsf3+0x4>

00000ae6 <__divsf3_pse>:
     ae6:	99 23       	and	r25, r25
     ae8:	c9 f3       	breq	.-14     	; 0xadc <__divsf3+0x14>
     aea:	55 23       	and	r21, r21
     aec:	b1 f3       	breq	.-20     	; 0xada <__divsf3+0x12>
     aee:	95 1b       	sub	r25, r21
     af0:	55 0b       	sbc	r21, r21
     af2:	bb 27       	eor	r27, r27
     af4:	aa 27       	eor	r26, r26
     af6:	62 17       	cp	r22, r18
     af8:	73 07       	cpc	r23, r19
     afa:	84 07       	cpc	r24, r20
     afc:	38 f0       	brcs	.+14     	; 0xb0c <__stack+0xd>
     afe:	9f 5f       	subi	r25, 0xFF	; 255
     b00:	5f 4f       	sbci	r21, 0xFF	; 255
     b02:	22 0f       	add	r18, r18
     b04:	33 1f       	adc	r19, r19
     b06:	44 1f       	adc	r20, r20
     b08:	aa 1f       	adc	r26, r26
     b0a:	a9 f3       	breq	.-22     	; 0xaf6 <__divsf3_pse+0x10>
     b0c:	33 d0       	rcall	.+102    	; 0xb74 <__stack+0x75>
     b0e:	0e 2e       	mov	r0, r30
     b10:	3a f0       	brmi	.+14     	; 0xb20 <__stack+0x21>
     b12:	e0 e8       	ldi	r30, 0x80	; 128
     b14:	30 d0       	rcall	.+96     	; 0xb76 <__stack+0x77>
     b16:	91 50       	subi	r25, 0x01	; 1
     b18:	50 40       	sbci	r21, 0x00	; 0
     b1a:	e6 95       	lsr	r30
     b1c:	00 1c       	adc	r0, r0
     b1e:	ca f7       	brpl	.-14     	; 0xb12 <__stack+0x13>
     b20:	29 d0       	rcall	.+82     	; 0xb74 <__stack+0x75>
     b22:	fe 2f       	mov	r31, r30
     b24:	27 d0       	rcall	.+78     	; 0xb74 <__stack+0x75>
     b26:	66 0f       	add	r22, r22
     b28:	77 1f       	adc	r23, r23
     b2a:	88 1f       	adc	r24, r24
     b2c:	bb 1f       	adc	r27, r27
     b2e:	26 17       	cp	r18, r22
     b30:	37 07       	cpc	r19, r23
     b32:	48 07       	cpc	r20, r24
     b34:	ab 07       	cpc	r26, r27
     b36:	b0 e8       	ldi	r27, 0x80	; 128
     b38:	09 f0       	breq	.+2      	; 0xb3c <__stack+0x3d>
     b3a:	bb 0b       	sbc	r27, r27
     b3c:	80 2d       	mov	r24, r0
     b3e:	bf 01       	movw	r22, r30
     b40:	ff 27       	eor	r31, r31
     b42:	93 58       	subi	r25, 0x83	; 131
     b44:	5f 4f       	sbci	r21, 0xFF	; 255
     b46:	2a f0       	brmi	.+10     	; 0xb52 <__stack+0x53>
     b48:	9e 3f       	cpi	r25, 0xFE	; 254
     b4a:	51 05       	cpc	r21, r1
     b4c:	68 f0       	brcs	.+26     	; 0xb68 <__stack+0x69>
     b4e:	61 c0       	rjmp	.+194    	; 0xc12 <__fp_inf>
     b50:	ab c0       	rjmp	.+342    	; 0xca8 <__fp_szero>
     b52:	5f 3f       	cpi	r21, 0xFF	; 255
     b54:	ec f3       	brlt	.-6      	; 0xb50 <__stack+0x51>
     b56:	98 3e       	cpi	r25, 0xE8	; 232
     b58:	dc f3       	brlt	.-10     	; 0xb50 <__stack+0x51>
     b5a:	86 95       	lsr	r24
     b5c:	77 95       	ror	r23
     b5e:	67 95       	ror	r22
     b60:	b7 95       	ror	r27
     b62:	f7 95       	ror	r31
     b64:	9f 5f       	subi	r25, 0xFF	; 255
     b66:	c9 f7       	brne	.-14     	; 0xb5a <__stack+0x5b>
     b68:	88 0f       	add	r24, r24
     b6a:	91 1d       	adc	r25, r1
     b6c:	96 95       	lsr	r25
     b6e:	87 95       	ror	r24
     b70:	97 f9       	bld	r25, 7
     b72:	08 95       	ret
     b74:	e1 e0       	ldi	r30, 0x01	; 1
     b76:	66 0f       	add	r22, r22
     b78:	77 1f       	adc	r23, r23
     b7a:	88 1f       	adc	r24, r24
     b7c:	bb 1f       	adc	r27, r27
     b7e:	62 17       	cp	r22, r18
     b80:	73 07       	cpc	r23, r19
     b82:	84 07       	cpc	r24, r20
     b84:	ba 07       	cpc	r27, r26
     b86:	20 f0       	brcs	.+8      	; 0xb90 <__stack+0x91>
     b88:	62 1b       	sub	r22, r18
     b8a:	73 0b       	sbc	r23, r19
     b8c:	84 0b       	sbc	r24, r20
     b8e:	ba 0b       	sbc	r27, r26
     b90:	ee 1f       	adc	r30, r30
     b92:	88 f7       	brcc	.-30     	; 0xb76 <__stack+0x77>
     b94:	e0 95       	com	r30
     b96:	08 95       	ret

00000b98 <__floatunsisf>:
     b98:	e8 94       	clt
     b9a:	09 c0       	rjmp	.+18     	; 0xbae <__floatsisf+0x12>

00000b9c <__floatsisf>:
     b9c:	97 fb       	bst	r25, 7
     b9e:	3e f4       	brtc	.+14     	; 0xbae <__floatsisf+0x12>
     ba0:	90 95       	com	r25
     ba2:	80 95       	com	r24
     ba4:	70 95       	com	r23
     ba6:	61 95       	neg	r22
     ba8:	7f 4f       	sbci	r23, 0xFF	; 255
     baa:	8f 4f       	sbci	r24, 0xFF	; 255
     bac:	9f 4f       	sbci	r25, 0xFF	; 255
     bae:	99 23       	and	r25, r25
     bb0:	a9 f0       	breq	.+42     	; 0xbdc <__floatsisf+0x40>
     bb2:	f9 2f       	mov	r31, r25
     bb4:	96 e9       	ldi	r25, 0x96	; 150
     bb6:	bb 27       	eor	r27, r27
     bb8:	93 95       	inc	r25
     bba:	f6 95       	lsr	r31
     bbc:	87 95       	ror	r24
     bbe:	77 95       	ror	r23
     bc0:	67 95       	ror	r22
     bc2:	b7 95       	ror	r27
     bc4:	f1 11       	cpse	r31, r1
     bc6:	f8 cf       	rjmp	.-16     	; 0xbb8 <__floatsisf+0x1c>
     bc8:	fa f4       	brpl	.+62     	; 0xc08 <__floatsisf+0x6c>
     bca:	bb 0f       	add	r27, r27
     bcc:	11 f4       	brne	.+4      	; 0xbd2 <__floatsisf+0x36>
     bce:	60 ff       	sbrs	r22, 0
     bd0:	1b c0       	rjmp	.+54     	; 0xc08 <__floatsisf+0x6c>
     bd2:	6f 5f       	subi	r22, 0xFF	; 255
     bd4:	7f 4f       	sbci	r23, 0xFF	; 255
     bd6:	8f 4f       	sbci	r24, 0xFF	; 255
     bd8:	9f 4f       	sbci	r25, 0xFF	; 255
     bda:	16 c0       	rjmp	.+44     	; 0xc08 <__floatsisf+0x6c>
     bdc:	88 23       	and	r24, r24
     bde:	11 f0       	breq	.+4      	; 0xbe4 <__floatsisf+0x48>
     be0:	96 e9       	ldi	r25, 0x96	; 150
     be2:	11 c0       	rjmp	.+34     	; 0xc06 <__floatsisf+0x6a>
     be4:	77 23       	and	r23, r23
     be6:	21 f0       	breq	.+8      	; 0xbf0 <__floatsisf+0x54>
     be8:	9e e8       	ldi	r25, 0x8E	; 142
     bea:	87 2f       	mov	r24, r23
     bec:	76 2f       	mov	r23, r22
     bee:	05 c0       	rjmp	.+10     	; 0xbfa <__floatsisf+0x5e>
     bf0:	66 23       	and	r22, r22
     bf2:	71 f0       	breq	.+28     	; 0xc10 <__floatsisf+0x74>
     bf4:	96 e8       	ldi	r25, 0x86	; 134
     bf6:	86 2f       	mov	r24, r22
     bf8:	70 e0       	ldi	r23, 0x00	; 0
     bfa:	60 e0       	ldi	r22, 0x00	; 0
     bfc:	2a f0       	brmi	.+10     	; 0xc08 <__floatsisf+0x6c>
     bfe:	9a 95       	dec	r25
     c00:	66 0f       	add	r22, r22
     c02:	77 1f       	adc	r23, r23
     c04:	88 1f       	adc	r24, r24
     c06:	da f7       	brpl	.-10     	; 0xbfe <__floatsisf+0x62>
     c08:	88 0f       	add	r24, r24
     c0a:	96 95       	lsr	r25
     c0c:	87 95       	ror	r24
     c0e:	97 f9       	bld	r25, 7
     c10:	08 95       	ret

00000c12 <__fp_inf>:
     c12:	97 f9       	bld	r25, 7
     c14:	9f 67       	ori	r25, 0x7F	; 127
     c16:	80 e8       	ldi	r24, 0x80	; 128
     c18:	70 e0       	ldi	r23, 0x00	; 0
     c1a:	60 e0       	ldi	r22, 0x00	; 0
     c1c:	08 95       	ret

00000c1e <__fp_nan>:
     c1e:	9f ef       	ldi	r25, 0xFF	; 255
     c20:	80 ec       	ldi	r24, 0xC0	; 192
     c22:	08 95       	ret

00000c24 <__fp_pscA>:
     c24:	00 24       	eor	r0, r0
     c26:	0a 94       	dec	r0
     c28:	16 16       	cp	r1, r22
     c2a:	17 06       	cpc	r1, r23
     c2c:	18 06       	cpc	r1, r24
     c2e:	09 06       	cpc	r0, r25
     c30:	08 95       	ret

00000c32 <__fp_pscB>:
     c32:	00 24       	eor	r0, r0
     c34:	0a 94       	dec	r0
     c36:	12 16       	cp	r1, r18
     c38:	13 06       	cpc	r1, r19
     c3a:	14 06       	cpc	r1, r20
     c3c:	05 06       	cpc	r0, r21
     c3e:	08 95       	ret

00000c40 <__fp_round>:
     c40:	09 2e       	mov	r0, r25
     c42:	03 94       	inc	r0
     c44:	00 0c       	add	r0, r0
     c46:	11 f4       	brne	.+4      	; 0xc4c <__fp_round+0xc>
     c48:	88 23       	and	r24, r24
     c4a:	52 f0       	brmi	.+20     	; 0xc60 <__fp_round+0x20>
     c4c:	bb 0f       	add	r27, r27
     c4e:	40 f4       	brcc	.+16     	; 0xc60 <__fp_round+0x20>
     c50:	bf 2b       	or	r27, r31
     c52:	11 f4       	brne	.+4      	; 0xc58 <__fp_round+0x18>
     c54:	60 ff       	sbrs	r22, 0
     c56:	04 c0       	rjmp	.+8      	; 0xc60 <__fp_round+0x20>
     c58:	6f 5f       	subi	r22, 0xFF	; 255
     c5a:	7f 4f       	sbci	r23, 0xFF	; 255
     c5c:	8f 4f       	sbci	r24, 0xFF	; 255
     c5e:	9f 4f       	sbci	r25, 0xFF	; 255
     c60:	08 95       	ret

00000c62 <__fp_split3>:
     c62:	57 fd       	sbrc	r21, 7
     c64:	90 58       	subi	r25, 0x80	; 128
     c66:	44 0f       	add	r20, r20
     c68:	55 1f       	adc	r21, r21
     c6a:	59 f0       	breq	.+22     	; 0xc82 <__fp_splitA+0x10>
     c6c:	5f 3f       	cpi	r21, 0xFF	; 255
     c6e:	71 f0       	breq	.+28     	; 0xc8c <__fp_splitA+0x1a>
     c70:	47 95       	ror	r20

00000c72 <__fp_splitA>:
     c72:	88 0f       	add	r24, r24
     c74:	97 fb       	bst	r25, 7
     c76:	99 1f       	adc	r25, r25
     c78:	61 f0       	breq	.+24     	; 0xc92 <__fp_splitA+0x20>
     c7a:	9f 3f       	cpi	r25, 0xFF	; 255
     c7c:	79 f0       	breq	.+30     	; 0xc9c <__fp_splitA+0x2a>
     c7e:	87 95       	ror	r24
     c80:	08 95       	ret
     c82:	12 16       	cp	r1, r18
     c84:	13 06       	cpc	r1, r19
     c86:	14 06       	cpc	r1, r20
     c88:	55 1f       	adc	r21, r21
     c8a:	f2 cf       	rjmp	.-28     	; 0xc70 <__fp_split3+0xe>
     c8c:	46 95       	lsr	r20
     c8e:	f1 df       	rcall	.-30     	; 0xc72 <__fp_splitA>
     c90:	08 c0       	rjmp	.+16     	; 0xca2 <__fp_splitA+0x30>
     c92:	16 16       	cp	r1, r22
     c94:	17 06       	cpc	r1, r23
     c96:	18 06       	cpc	r1, r24
     c98:	99 1f       	adc	r25, r25
     c9a:	f1 cf       	rjmp	.-30     	; 0xc7e <__fp_splitA+0xc>
     c9c:	86 95       	lsr	r24
     c9e:	71 05       	cpc	r23, r1
     ca0:	61 05       	cpc	r22, r1
     ca2:	08 94       	sec
     ca4:	08 95       	ret

00000ca6 <__fp_zero>:
     ca6:	e8 94       	clt

00000ca8 <__fp_szero>:
     ca8:	bb 27       	eor	r27, r27
     caa:	66 27       	eor	r22, r22
     cac:	77 27       	eor	r23, r23
     cae:	cb 01       	movw	r24, r22
     cb0:	97 f9       	bld	r25, 7
     cb2:	08 95       	ret

00000cb4 <__gesf2>:
     cb4:	66 d0       	rcall	.+204    	; 0xd82 <__fp_cmp>
     cb6:	08 f4       	brcc	.+2      	; 0xcba <__gesf2+0x6>
     cb8:	8f ef       	ldi	r24, 0xFF	; 255
     cba:	08 95       	ret

00000cbc <__mulsf3>:
     cbc:	0b d0       	rcall	.+22     	; 0xcd4 <__mulsf3x>
     cbe:	c0 cf       	rjmp	.-128    	; 0xc40 <__fp_round>
     cc0:	b1 df       	rcall	.-158    	; 0xc24 <__fp_pscA>
     cc2:	28 f0       	brcs	.+10     	; 0xcce <__mulsf3+0x12>
     cc4:	b6 df       	rcall	.-148    	; 0xc32 <__fp_pscB>
     cc6:	18 f0       	brcs	.+6      	; 0xcce <__mulsf3+0x12>
     cc8:	95 23       	and	r25, r21
     cca:	09 f0       	breq	.+2      	; 0xcce <__mulsf3+0x12>
     ccc:	a2 cf       	rjmp	.-188    	; 0xc12 <__fp_inf>
     cce:	a7 cf       	rjmp	.-178    	; 0xc1e <__fp_nan>
     cd0:	11 24       	eor	r1, r1
     cd2:	ea cf       	rjmp	.-44     	; 0xca8 <__fp_szero>

00000cd4 <__mulsf3x>:
     cd4:	c6 df       	rcall	.-116    	; 0xc62 <__fp_split3>
     cd6:	a0 f3       	brcs	.-24     	; 0xcc0 <__mulsf3+0x4>

00000cd8 <__mulsf3_pse>:
     cd8:	95 9f       	mul	r25, r21
     cda:	d1 f3       	breq	.-12     	; 0xcd0 <__mulsf3+0x14>
     cdc:	95 0f       	add	r25, r21
     cde:	50 e0       	ldi	r21, 0x00	; 0
     ce0:	55 1f       	adc	r21, r21
     ce2:	62 9f       	mul	r22, r18
     ce4:	f0 01       	movw	r30, r0
     ce6:	72 9f       	mul	r23, r18
     ce8:	bb 27       	eor	r27, r27
     cea:	f0 0d       	add	r31, r0
     cec:	b1 1d       	adc	r27, r1
     cee:	63 9f       	mul	r22, r19
     cf0:	aa 27       	eor	r26, r26
     cf2:	f0 0d       	add	r31, r0
     cf4:	b1 1d       	adc	r27, r1
     cf6:	aa 1f       	adc	r26, r26
     cf8:	64 9f       	mul	r22, r20
     cfa:	66 27       	eor	r22, r22
     cfc:	b0 0d       	add	r27, r0
     cfe:	a1 1d       	adc	r26, r1
     d00:	66 1f       	adc	r22, r22
     d02:	82 9f       	mul	r24, r18
     d04:	22 27       	eor	r18, r18
     d06:	b0 0d       	add	r27, r0
     d08:	a1 1d       	adc	r26, r1
     d0a:	62 1f       	adc	r22, r18
     d0c:	73 9f       	mul	r23, r19
     d0e:	b0 0d       	add	r27, r0
     d10:	a1 1d       	adc	r26, r1
     d12:	62 1f       	adc	r22, r18
     d14:	83 9f       	mul	r24, r19
     d16:	a0 0d       	add	r26, r0
     d18:	61 1d       	adc	r22, r1
     d1a:	22 1f       	adc	r18, r18
     d1c:	74 9f       	mul	r23, r20
     d1e:	33 27       	eor	r19, r19
     d20:	a0 0d       	add	r26, r0
     d22:	61 1d       	adc	r22, r1
     d24:	23 1f       	adc	r18, r19
     d26:	84 9f       	mul	r24, r20
     d28:	60 0d       	add	r22, r0
     d2a:	21 1d       	adc	r18, r1
     d2c:	82 2f       	mov	r24, r18
     d2e:	76 2f       	mov	r23, r22
     d30:	6a 2f       	mov	r22, r26
     d32:	11 24       	eor	r1, r1
     d34:	9f 57       	subi	r25, 0x7F	; 127
     d36:	50 40       	sbci	r21, 0x00	; 0
     d38:	8a f0       	brmi	.+34     	; 0xd5c <__mulsf3_pse+0x84>
     d3a:	e1 f0       	breq	.+56     	; 0xd74 <__mulsf3_pse+0x9c>
     d3c:	88 23       	and	r24, r24
     d3e:	4a f0       	brmi	.+18     	; 0xd52 <__mulsf3_pse+0x7a>
     d40:	ee 0f       	add	r30, r30
     d42:	ff 1f       	adc	r31, r31
     d44:	bb 1f       	adc	r27, r27
     d46:	66 1f       	adc	r22, r22
     d48:	77 1f       	adc	r23, r23
     d4a:	88 1f       	adc	r24, r24
     d4c:	91 50       	subi	r25, 0x01	; 1
     d4e:	50 40       	sbci	r21, 0x00	; 0
     d50:	a9 f7       	brne	.-22     	; 0xd3c <__mulsf3_pse+0x64>
     d52:	9e 3f       	cpi	r25, 0xFE	; 254
     d54:	51 05       	cpc	r21, r1
     d56:	70 f0       	brcs	.+28     	; 0xd74 <__mulsf3_pse+0x9c>
     d58:	5c cf       	rjmp	.-328    	; 0xc12 <__fp_inf>
     d5a:	a6 cf       	rjmp	.-180    	; 0xca8 <__fp_szero>
     d5c:	5f 3f       	cpi	r21, 0xFF	; 255
     d5e:	ec f3       	brlt	.-6      	; 0xd5a <__mulsf3_pse+0x82>
     d60:	98 3e       	cpi	r25, 0xE8	; 232
     d62:	dc f3       	brlt	.-10     	; 0xd5a <__mulsf3_pse+0x82>
     d64:	86 95       	lsr	r24
     d66:	77 95       	ror	r23
     d68:	67 95       	ror	r22
     d6a:	b7 95       	ror	r27
     d6c:	f7 95       	ror	r31
     d6e:	e7 95       	ror	r30
     d70:	9f 5f       	subi	r25, 0xFF	; 255
     d72:	c1 f7       	brne	.-16     	; 0xd64 <__mulsf3_pse+0x8c>
     d74:	fe 2b       	or	r31, r30
     d76:	88 0f       	add	r24, r24
     d78:	91 1d       	adc	r25, r1
     d7a:	96 95       	lsr	r25
     d7c:	87 95       	ror	r24
     d7e:	97 f9       	bld	r25, 7
     d80:	08 95       	ret

00000d82 <__fp_cmp>:
     d82:	99 0f       	add	r25, r25
     d84:	00 08       	sbc	r0, r0
     d86:	55 0f       	add	r21, r21
     d88:	aa 0b       	sbc	r26, r26
     d8a:	e0 e8       	ldi	r30, 0x80	; 128
     d8c:	fe ef       	ldi	r31, 0xFE	; 254
     d8e:	16 16       	cp	r1, r22
     d90:	17 06       	cpc	r1, r23
     d92:	e8 07       	cpc	r30, r24
     d94:	f9 07       	cpc	r31, r25
     d96:	c0 f0       	brcs	.+48     	; 0xdc8 <__fp_cmp+0x46>
     d98:	12 16       	cp	r1, r18
     d9a:	13 06       	cpc	r1, r19
     d9c:	e4 07       	cpc	r30, r20
     d9e:	f5 07       	cpc	r31, r21
     da0:	98 f0       	brcs	.+38     	; 0xdc8 <__fp_cmp+0x46>
     da2:	62 1b       	sub	r22, r18
     da4:	73 0b       	sbc	r23, r19
     da6:	84 0b       	sbc	r24, r20
     da8:	95 0b       	sbc	r25, r21
     daa:	39 f4       	brne	.+14     	; 0xdba <__fp_cmp+0x38>
     dac:	0a 26       	eor	r0, r26
     dae:	61 f0       	breq	.+24     	; 0xdc8 <__fp_cmp+0x46>
     db0:	23 2b       	or	r18, r19
     db2:	24 2b       	or	r18, r20
     db4:	25 2b       	or	r18, r21
     db6:	21 f4       	brne	.+8      	; 0xdc0 <__fp_cmp+0x3e>
     db8:	08 95       	ret
     dba:	0a 26       	eor	r0, r26
     dbc:	09 f4       	brne	.+2      	; 0xdc0 <__fp_cmp+0x3e>
     dbe:	a1 40       	sbci	r26, 0x01	; 1
     dc0:	a6 95       	lsr	r26
     dc2:	8f ef       	ldi	r24, 0xFF	; 255
     dc4:	81 1d       	adc	r24, r1
     dc6:	81 1d       	adc	r24, r1
     dc8:	08 95       	ret

00000dca <__vector_23>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     dca:	1f 92       	push	r1
     dcc:	0f 92       	push	r0
     dce:	0f b6       	in	r0, 0x3f	; 63
     dd0:	0f 92       	push	r0
     dd2:	11 24       	eor	r1, r1
     dd4:	2f 93       	push	r18
     dd6:	3f 93       	push	r19
     dd8:	8f 93       	push	r24
     dda:	9f 93       	push	r25
     ddc:	af 93       	push	r26
     dde:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     de0:	80 91 fb 01 	lds	r24, 0x01FB
     de4:	90 91 fc 01 	lds	r25, 0x01FC
     de8:	a0 91 fd 01 	lds	r26, 0x01FD
     dec:	b0 91 fe 01 	lds	r27, 0x01FE
	unsigned char f = timer0_fract;
     df0:	30 91 fa 01 	lds	r19, 0x01FA

	m += MILLIS_INC;
	f += FRACT_INC;
     df4:	23 e0       	ldi	r18, 0x03	; 3
     df6:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
     df8:	2d 37       	cpi	r18, 0x7D	; 125
     dfa:	20 f4       	brcc	.+8      	; 0xe04 <__vector_23+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
     dfc:	01 96       	adiw	r24, 0x01	; 1
     dfe:	a1 1d       	adc	r26, r1
     e00:	b1 1d       	adc	r27, r1
     e02:	05 c0       	rjmp	.+10     	; 0xe0e <__vector_23+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     e04:	26 e8       	ldi	r18, 0x86	; 134
     e06:	23 0f       	add	r18, r19
		m += 1;
     e08:	02 96       	adiw	r24, 0x02	; 2
     e0a:	a1 1d       	adc	r26, r1
     e0c:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
     e0e:	20 93 fa 01 	sts	0x01FA, r18
	timer0_millis = m;
     e12:	80 93 fb 01 	sts	0x01FB, r24
     e16:	90 93 fc 01 	sts	0x01FC, r25
     e1a:	a0 93 fd 01 	sts	0x01FD, r26
     e1e:	b0 93 fe 01 	sts	0x01FE, r27
	timer0_overflow_count++;
     e22:	80 91 ff 01 	lds	r24, 0x01FF
     e26:	90 91 00 02 	lds	r25, 0x0200
     e2a:	a0 91 01 02 	lds	r26, 0x0201
     e2e:	b0 91 02 02 	lds	r27, 0x0202
     e32:	01 96       	adiw	r24, 0x01	; 1
     e34:	a1 1d       	adc	r26, r1
     e36:	b1 1d       	adc	r27, r1
     e38:	80 93 ff 01 	sts	0x01FF, r24
     e3c:	90 93 00 02 	sts	0x0200, r25
     e40:	a0 93 01 02 	sts	0x0201, r26
     e44:	b0 93 02 02 	sts	0x0202, r27
}
     e48:	bf 91       	pop	r27
     e4a:	af 91       	pop	r26
     e4c:	9f 91       	pop	r25
     e4e:	8f 91       	pop	r24
     e50:	3f 91       	pop	r19
     e52:	2f 91       	pop	r18
     e54:	0f 90       	pop	r0
     e56:	0f be       	out	0x3f, r0	; 63
     e58:	0f 90       	pop	r0
     e5a:	1f 90       	pop	r1
     e5c:	18 95       	reti

00000e5e <millis>:

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     e5e:	2f b7       	in	r18, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     e60:	f8 94       	cli
	m = timer0_millis;
     e62:	60 91 fb 01 	lds	r22, 0x01FB
     e66:	70 91 fc 01 	lds	r23, 0x01FC
     e6a:	80 91 fd 01 	lds	r24, 0x01FD
     e6e:	90 91 fe 01 	lds	r25, 0x01FE
	SREG = oldSREG;
     e72:	2f bf       	out	0x3f, r18	; 63

	return m;
}
     e74:	08 95       	ret

00000e76 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     e76:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
     e78:	f8 94       	cli
	m = timer0_overflow_count;
     e7a:	80 91 ff 01 	lds	r24, 0x01FF
     e7e:	90 91 00 02 	lds	r25, 0x0200
     e82:	a0 91 01 02 	lds	r26, 0x0201
     e86:	b0 91 02 02 	lds	r27, 0x0202
#if defined(TCNT0)
	t = TCNT0;
     e8a:	26 b5       	in	r18, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     e8c:	a8 9b       	sbis	0x15, 0	; 21
     e8e:	05 c0       	rjmp	.+10     	; 0xe9a <micros+0x24>
     e90:	2f 3f       	cpi	r18, 0xFF	; 255
     e92:	19 f0       	breq	.+6      	; 0xe9a <micros+0x24>
		m++;
     e94:	01 96       	adiw	r24, 0x01	; 1
     e96:	a1 1d       	adc	r26, r1
     e98:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     e9a:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     e9c:	66 27       	eor	r22, r22
     e9e:	78 2f       	mov	r23, r24
     ea0:	89 2f       	mov	r24, r25
     ea2:	9a 2f       	mov	r25, r26
     ea4:	62 0f       	add	r22, r18
     ea6:	71 1d       	adc	r23, r1
     ea8:	81 1d       	adc	r24, r1
     eaa:	91 1d       	adc	r25, r1
     eac:	42 e0       	ldi	r20, 0x02	; 2
     eae:	66 0f       	add	r22, r22
     eb0:	77 1f       	adc	r23, r23
     eb2:	88 1f       	adc	r24, r24
     eb4:	99 1f       	adc	r25, r25
     eb6:	4a 95       	dec	r20
     eb8:	d1 f7       	brne	.-12     	; 0xeae <micros+0x38>
}
     eba:	08 95       	ret

00000ebc <delay>:

void delay(unsigned long ms)
{
     ebc:	cf 92       	push	r12
     ebe:	df 92       	push	r13
     ec0:	ef 92       	push	r14
     ec2:	ff 92       	push	r15
     ec4:	cf 93       	push	r28
     ec6:	df 93       	push	r29
     ec8:	6b 01       	movw	r12, r22
     eca:	7c 01       	movw	r14, r24
	uint16_t start = (uint16_t)micros();
     ecc:	0e 94 3b 07 	call	0xe76	; 0xe76 <micros>
     ed0:	eb 01       	movw	r28, r22

	while (ms > 0) {
     ed2:	c1 14       	cp	r12, r1
     ed4:	d1 04       	cpc	r13, r1
     ed6:	e1 04       	cpc	r14, r1
     ed8:	f1 04       	cpc	r15, r1
     eda:	89 f0       	breq	.+34     	; 0xefe <delay+0x42>
		yield();
     edc:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <yield>
		if (((uint16_t)micros() - start) >= 1000) {
     ee0:	0e 94 3b 07 	call	0xe76	; 0xe76 <micros>
     ee4:	6c 1b       	sub	r22, r28
     ee6:	7d 0b       	sbc	r23, r29
     ee8:	68 3e       	cpi	r22, 0xE8	; 232
     eea:	73 40       	sbci	r23, 0x03	; 3
     eec:	90 f3       	brcs	.-28     	; 0xed2 <delay+0x16>
			ms--;
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	c8 1a       	sub	r12, r24
     ef2:	d1 08       	sbc	r13, r1
     ef4:	e1 08       	sbc	r14, r1
     ef6:	f1 08       	sbc	r15, r1
			start += 1000;
     ef8:	c8 51       	subi	r28, 0x18	; 24
     efa:	dc 4f       	sbci	r29, 0xFC	; 252
     efc:	ea cf       	rjmp	.-44     	; 0xed2 <delay+0x16>
		}
	}
}
     efe:	df 91       	pop	r29
     f00:	cf 91       	pop	r28
     f02:	ff 90       	pop	r15
     f04:	ef 90       	pop	r14
     f06:	df 90       	pop	r13
     f08:	cf 90       	pop	r12
     f0a:	08 95       	ret

00000f0c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     f0c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     f0e:	84 b5       	in	r24, 0x24	; 36
     f10:	82 60       	ori	r24, 0x02	; 2
     f12:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     f14:	84 b5       	in	r24, 0x24	; 36
     f16:	81 60       	ori	r24, 0x01	; 1
     f18:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     f1a:	85 b5       	in	r24, 0x25	; 37
     f1c:	82 60       	ori	r24, 0x02	; 2
     f1e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     f20:	85 b5       	in	r24, 0x25	; 37
     f22:	81 60       	ori	r24, 0x01	; 1
     f24:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     f26:	ee e6       	ldi	r30, 0x6E	; 110
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	80 81       	ld	r24, Z
     f2c:	81 60       	ori	r24, 0x01	; 1
     f2e:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     f30:	e1 e8       	ldi	r30, 0x81	; 129
     f32:	f0 e0       	ldi	r31, 0x00	; 0
     f34:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     f36:	80 81       	ld	r24, Z
     f38:	82 60       	ori	r24, 0x02	; 2
     f3a:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     f3c:	80 81       	ld	r24, Z
     f3e:	81 60       	ori	r24, 0x01	; 1
     f40:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     f42:	e0 e8       	ldi	r30, 0x80	; 128
     f44:	f0 e0       	ldi	r31, 0x00	; 0
     f46:	80 81       	ld	r24, Z
     f48:	81 60       	ori	r24, 0x01	; 1
     f4a:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
     f4c:	e1 e9       	ldi	r30, 0x91	; 145
     f4e:	f0 e0       	ldi	r31, 0x00	; 0
     f50:	80 81       	ld	r24, Z
     f52:	82 60       	ori	r24, 0x02	; 2
     f54:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
     f56:	80 81       	ld	r24, Z
     f58:	81 60       	ori	r24, 0x01	; 1
     f5a:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
     f5c:	e0 e9       	ldi	r30, 0x90	; 144
     f5e:	f0 e0       	ldi	r31, 0x00	; 0
     f60:	80 81       	ld	r24, Z
     f62:	81 60       	ori	r24, 0x01	; 1
     f64:	80 83       	st	Z, r24
#endif

#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
     f66:	e1 ec       	ldi	r30, 0xC1	; 193
     f68:	f0 e0       	ldi	r31, 0x00	; 0
     f6a:	80 81       	ld	r24, Z
     f6c:	84 60       	ori	r24, 0x04	; 4
     f6e:	80 83       	st	Z, r24
	sbi(TCCR4B, CS41);
     f70:	80 81       	ld	r24, Z
     f72:	82 60       	ori	r24, 0x02	; 2
     f74:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
     f76:	80 81       	ld	r24, Z
     f78:	81 60       	ori	r24, 0x01	; 1
     f7a:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
     f7c:	e3 ec       	ldi	r30, 0xC3	; 195
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	80 81       	ld	r24, Z
     f82:	81 60       	ori	r24, 0x01	; 1
     f84:	80 83       	st	Z, r24
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
     f86:	e0 ec       	ldi	r30, 0xC0	; 192
     f88:	f0 e0       	ldi	r31, 0x00	; 0
     f8a:	80 81       	ld	r24, Z
     f8c:	82 60       	ori	r24, 0x02	; 2
     f8e:	80 83       	st	Z, r24
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
     f90:	e2 ec       	ldi	r30, 0xC2	; 194
     f92:	f0 e0       	ldi	r31, 0x00	; 0
     f94:	80 81       	ld	r24, Z
     f96:	81 60       	ori	r24, 0x01	; 1
     f98:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
     f9a:	ea e7       	ldi	r30, 0x7A	; 122
     f9c:	f0 e0       	ldi	r31, 0x00	; 0
     f9e:	80 81       	ld	r24, Z
     fa0:	84 60       	ori	r24, 0x04	; 4
     fa2:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
     fa4:	80 81       	ld	r24, Z
     fa6:	82 60       	ori	r24, 0x02	; 2
     fa8:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
     faa:	80 81       	ld	r24, Z
     fac:	81 60       	ori	r24, 0x01	; 1
     fae:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     fb0:	80 81       	ld	r24, Z
     fb2:	80 68       	ori	r24, 0x80	; 128
     fb4:	80 83       	st	Z, r24
     fb6:	08 95       	ret

00000fb8 <analogRead>:
{
	uint8_t low, high;

#if defined(analogPinToChannel)
#if defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
     fb8:	82 31       	cpi	r24, 0x12	; 18
     fba:	08 f0       	brcs	.+2      	; 0xfbe <analogRead+0x6>
     fbc:	82 51       	subi	r24, 0x12	; 18
#endif
	pin = analogPinToChannel(pin);
     fbe:	e8 2f       	mov	r30, r24
     fc0:	f0 e0       	ldi	r31, 0x00	; 0
     fc2:	e6 53       	subi	r30, 0x36	; 54
     fc4:	ff 4f       	sbci	r31, 0xFF	; 255
     fc6:	e4 91       	lpm	r30, Z
#endif

#if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
     fc8:	80 91 7b 00 	lds	r24, 0x007B
     fcc:	e3 fb       	bst	r30, 3
     fce:	22 27       	eor	r18, r18
     fd0:	20 f9       	bld	r18, 0
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	95 e0       	ldi	r25, 0x05	; 5
     fd6:	22 0f       	add	r18, r18
     fd8:	33 1f       	adc	r19, r19
     fda:	9a 95       	dec	r25
     fdc:	e1 f7       	brne	.-8      	; 0xfd6 <analogRead+0x1e>
     fde:	8f 7d       	andi	r24, 0xDF	; 223
     fe0:	82 2b       	or	r24, r18
     fe2:	80 93 7b 00 	sts	0x007B, r24
  
	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
#if defined(ADMUX)
	ADMUX = (analog_reference << 6) | (pin & 0x07);
     fe6:	e7 70       	andi	r30, 0x07	; 7
     fe8:	80 91 00 01 	lds	r24, 0x0100
     fec:	20 e4       	ldi	r18, 0x40	; 64
     fee:	82 9f       	mul	r24, r18
     ff0:	c0 01       	movw	r24, r0
     ff2:	11 24       	eor	r1, r1
     ff4:	e8 2b       	or	r30, r24
     ff6:	e0 93 7c 00 	sts	0x007C, r30
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
     ffa:	80 91 7a 00 	lds	r24, 0x007A
     ffe:	80 64       	ori	r24, 0x40	; 64
    1000:	80 93 7a 00 	sts	0x007A, r24

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    1004:	80 91 7a 00 	lds	r24, 0x007A
    1008:	86 fd       	sbrc	r24, 6
    100a:	fc cf       	rjmp	.-8      	; 0x1004 <analogRead+0x4c>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    100c:	80 91 78 00 	lds	r24, 0x0078
	high = ADCH;
    1010:	20 91 79 00 	lds	r18, 0x0079
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    1014:	90 e0       	ldi	r25, 0x00	; 0
}
    1016:	92 2b       	or	r25, r18
    1018:	08 95       	ret

0000101a <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	fc 01       	movw	r30, r24
    101e:	31 97       	sbiw	r30, 0x01	; 1
    1020:	ef 30       	cpi	r30, 0x0F	; 15
    1022:	f1 05       	cpc	r31, r1
    1024:	b0 f5       	brcc	.+108    	; 0x1092 <turnOffPWM+0x78>
    1026:	ea 5a       	subi	r30, 0xAA	; 170
    1028:	ff 4f       	sbci	r31, 0xFF	; 255
    102a:	0c 94 a5 0e 	jmp	0x1d4a	; 0x1d4a <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    102e:	80 91 80 00 	lds	r24, 0x0080
    1032:	8f 77       	andi	r24, 0x7F	; 127
    1034:	03 c0       	rjmp	.+6      	; 0x103c <turnOffPWM+0x22>
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    1036:	80 91 80 00 	lds	r24, 0x0080
    103a:	8f 7d       	andi	r24, 0xDF	; 223
    103c:	80 93 80 00 	sts	0x0080, r24
    1040:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    1042:	80 91 80 00 	lds	r24, 0x0080
    1046:	87 7f       	andi	r24, 0xF7	; 247
    1048:	f9 cf       	rjmp	.-14     	; 0x103c <turnOffPWM+0x22>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    104a:	84 b5       	in	r24, 0x24	; 36
    104c:	8f 77       	andi	r24, 0x7F	; 127
    104e:	02 c0       	rjmp	.+4      	; 0x1054 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    1050:	84 b5       	in	r24, 0x24	; 36
    1052:	8f 7d       	andi	r24, 0xDF	; 223
    1054:	84 bd       	out	0x24, r24	; 36
    1056:	08 95       	ret
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    1058:	80 91 90 00 	lds	r24, 0x0090
    105c:	8f 77       	andi	r24, 0x7F	; 127
    105e:	07 c0       	rjmp	.+14     	; 0x106e <turnOffPWM+0x54>
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    1060:	80 91 90 00 	lds	r24, 0x0090
    1064:	8f 7d       	andi	r24, 0xDF	; 223
    1066:	03 c0       	rjmp	.+6      	; 0x106e <turnOffPWM+0x54>
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    1068:	80 91 90 00 	lds	r24, 0x0090
    106c:	87 7f       	andi	r24, 0xF7	; 247
    106e:	80 93 90 00 	sts	0x0090, r24
    1072:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    1074:	80 91 c0 00 	lds	r24, 0x00C0
    1078:	8f 77       	andi	r24, 0x7F	; 127
    107a:	03 c0       	rjmp	.+6      	; 0x1082 <turnOffPWM+0x68>
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    107c:	80 91 c0 00 	lds	r24, 0x00C0
    1080:	8f 7d       	andi	r24, 0xDF	; 223
    1082:	80 93 c0 00 	sts	0x00C0, r24
    1086:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
		#endif			
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
    1088:	80 91 c2 00 	lds	r24, 0x00C2
    108c:	87 7f       	andi	r24, 0xF7	; 247
    108e:	80 93 c2 00 	sts	0x00C2, r24
    1092:	08 95       	ret

00001094 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	fc 01       	movw	r30, r24
    109c:	ec 50       	subi	r30, 0x0C	; 12
    109e:	ff 4f       	sbci	r31, 0xFF	; 255
    10a0:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    10a2:	fc 01       	movw	r30, r24
    10a4:	ee 5e       	subi	r30, 0xEE	; 238
    10a6:	fe 4f       	sbci	r31, 0xFE	; 254
    10a8:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    10aa:	88 23       	and	r24, r24
    10ac:	49 f1       	breq	.+82     	; 0x1100 <pinMode+0x6c>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	88 0f       	add	r24, r24
    10b2:	99 1f       	adc	r25, r25
    10b4:	fc 01       	movw	r30, r24
    10b6:	e4 5b       	subi	r30, 0xB4	; 180
    10b8:	fe 4f       	sbci	r31, 0xFE	; 254
    10ba:	a5 91       	lpm	r26, Z+
    10bc:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    10be:	82 5c       	subi	r24, 0xC2	; 194
    10c0:	9e 4f       	sbci	r25, 0xFE	; 254
    10c2:	fc 01       	movw	r30, r24
    10c4:	c5 91       	lpm	r28, Z+
    10c6:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
		uint8_t oldSREG = SREG;
    10c8:	9f b7       	in	r25, 0x3f	; 63

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
	out = portOutputRegister(port);

	if (mode == INPUT) { 
    10ca:	61 11       	cpse	r22, r1
    10cc:	08 c0       	rjmp	.+16     	; 0x10de <pinMode+0x4a>
		uint8_t oldSREG = SREG;
                cli();
    10ce:	f8 94       	cli
		*reg &= ~bit;
    10d0:	8c 91       	ld	r24, X
    10d2:	20 95       	com	r18
    10d4:	82 23       	and	r24, r18
    10d6:	8c 93       	st	X, r24
		*out &= ~bit;
    10d8:	88 81       	ld	r24, Y
    10da:	82 23       	and	r24, r18
    10dc:	0a c0       	rjmp	.+20     	; 0x10f2 <pinMode+0x5e>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    10de:	62 30       	cpi	r22, 0x02	; 2
    10e0:	51 f4       	brne	.+20     	; 0x10f6 <pinMode+0x62>
		uint8_t oldSREG = SREG;
                cli();
    10e2:	f8 94       	cli
		*reg &= ~bit;
    10e4:	8c 91       	ld	r24, X
    10e6:	32 2f       	mov	r19, r18
    10e8:	30 95       	com	r19
    10ea:	83 23       	and	r24, r19
    10ec:	8c 93       	st	X, r24
		*out |= bit;
    10ee:	88 81       	ld	r24, Y
    10f0:	82 2b       	or	r24, r18
    10f2:	88 83       	st	Y, r24
    10f4:	04 c0       	rjmp	.+8      	; 0x10fe <pinMode+0x6a>
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
                cli();
    10f6:	f8 94       	cli
		*reg |= bit;
    10f8:	8c 91       	ld	r24, X
    10fa:	82 2b       	or	r24, r18
    10fc:	8c 93       	st	X, r24
		SREG = oldSREG;
    10fe:	9f bf       	out	0x3f, r25	; 63
	}
}
    1100:	df 91       	pop	r29
    1102:	cf 91       	pop	r28
    1104:	08 95       	ret

00001106 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    1106:	0f 93       	push	r16
    1108:	1f 93       	push	r17
    110a:	cf 93       	push	r28
    110c:	df 93       	push	r29
    110e:	1f 92       	push	r1
    1110:	cd b7       	in	r28, 0x3d	; 61
    1112:	de b7       	in	r29, 0x3e	; 62
	uint8_t timer = digitalPinToTimer(pin);
    1114:	28 2f       	mov	r18, r24
    1116:	30 e0       	ldi	r19, 0x00	; 0
    1118:	f9 01       	movw	r30, r18
    111a:	ea 52       	subi	r30, 0x2A	; 42
    111c:	ff 4f       	sbci	r31, 0xFF	; 255
    111e:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    1120:	f9 01       	movw	r30, r18
    1122:	ec 50       	subi	r30, 0x0C	; 12
    1124:	ff 4f       	sbci	r31, 0xFF	; 255
    1126:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    1128:	f9 01       	movw	r30, r18
    112a:	ee 5e       	subi	r30, 0xEE	; 238
    112c:	fe 4f       	sbci	r31, 0xFE	; 254
    112e:	04 91       	lpm	r16, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    1130:	00 23       	and	r16, r16
    1132:	c9 f0       	breq	.+50     	; 0x1166 <digitalWrite+0x60>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    1134:	88 23       	and	r24, r24
    1136:	21 f0       	breq	.+8      	; 0x1140 <digitalWrite+0x3a>
    1138:	69 83       	std	Y+1, r22	; 0x01
    113a:	0e 94 0d 08 	call	0x101a	; 0x101a <turnOffPWM>
    113e:	69 81       	ldd	r22, Y+1	; 0x01

	out = portOutputRegister(port);
    1140:	e0 2f       	mov	r30, r16
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	ee 0f       	add	r30, r30
    1146:	ff 1f       	adc	r31, r31
    1148:	e2 5c       	subi	r30, 0xC2	; 194
    114a:	fe 4f       	sbci	r31, 0xFE	; 254
    114c:	a5 91       	lpm	r26, Z+
    114e:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    1150:	9f b7       	in	r25, 0x3f	; 63
	cli();
    1152:	f8 94       	cli

	if (val == LOW) {
		*out &= ~bit;
    1154:	8c 91       	ld	r24, X
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
    1156:	61 11       	cpse	r22, r1
    1158:	03 c0       	rjmp	.+6      	; 0x1160 <digitalWrite+0x5a>
		*out &= ~bit;
    115a:	10 95       	com	r17
    115c:	81 23       	and	r24, r17
    115e:	01 c0       	rjmp	.+2      	; 0x1162 <digitalWrite+0x5c>
	} else {
		*out |= bit;
    1160:	81 2b       	or	r24, r17
    1162:	8c 93       	st	X, r24
	}

	SREG = oldSREG;
    1164:	9f bf       	out	0x3f, r25	; 63
}
    1166:	0f 90       	pop	r0
    1168:	df 91       	pop	r29
    116a:	cf 91       	pop	r28
    116c:	1f 91       	pop	r17
    116e:	0f 91       	pop	r16
    1170:	08 95       	ret

00001172 <_ZN7Serial_5writeEh>:
}

void Serial_::flush(void)
{
	USB_Flush(CDC_TX);
}
    1172:	cf 93       	push	r28
    1174:	df 93       	push	r29
    1176:	1f 92       	push	r1
    1178:	cd b7       	in	r28, 0x3d	; 61
    117a:	de b7       	in	r29, 0x3e	; 62
    117c:	69 83       	std	Y+1, r22	; 0x01

    117e:	dc 01       	movw	r26, r24
    1180:	ed 91       	ld	r30, X+
    1182:	fc 91       	ld	r31, X
    1184:	02 80       	ldd	r0, Z+2	; 0x02
    1186:	f3 81       	ldd	r31, Z+3	; 0x03
    1188:	e0 2d       	mov	r30, r0
    118a:	41 e0       	ldi	r20, 0x01	; 1
    118c:	50 e0       	ldi	r21, 0x00	; 0
    118e:	be 01       	movw	r22, r28
    1190:	6f 5f       	subi	r22, 0xFF	; 255
    1192:	7f 4f       	sbci	r23, 0xFF	; 255
    1194:	09 95       	icall
size_t Serial_::write(uint8_t c)
    1196:	0f 90       	pop	r0
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	08 95       	ret

0000119e <_ZN7Serial_4peekEv>:
{
	if (peek_buffer >= 0) {
		return 1 + USB_Available(CDC_RX);
	}
	return USB_Available(CDC_RX);
}
    119e:	cf 93       	push	r28
    11a0:	df 93       	push	r29
    11a2:	ec 01       	movw	r28, r24

    11a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    11a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    11a8:	97 ff       	sbrs	r25, 7
    11aa:	05 c0       	rjmp	.+10     	; 0x11b6 <_ZN7Serial_4peekEv+0x18>
int Serial_::peek(void)
    11ac:	82 e0       	ldi	r24, 0x02	; 2
    11ae:	0e 94 8e 0a 	call	0x151c	; 0x151c <_Z8USB_Recvh>
    11b2:	9d 87       	std	Y+13, r25	; 0x0d
    11b4:	8c 87       	std	Y+12, r24	; 0x0c
{
	if (peek_buffer < 0)
    11b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    11b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    11ba:	df 91       	pop	r29
    11bc:	cf 91       	pop	r28
    11be:	08 95       	ret

000011c0 <_ZN7Serial_5flushEv>:
		peek_buffer = -1;
		return c;
	}
	return USB_Recv(CDC_RX);
}

    11c0:	83 e0       	ldi	r24, 0x03	; 3
    11c2:	0c 94 e3 0c 	jmp	0x19c6	; 0x19c6 <_Z9USB_Flushh>

000011c6 <_ZN7Serial_9availableEv>:
}

void Serial_::end(void)
{
}

    11c6:	fc 01       	movw	r30, r24
    11c8:	84 85       	ldd	r24, Z+12	; 0x0c
    11ca:	95 85       	ldd	r25, Z+13	; 0x0d
    11cc:	97 fd       	sbrc	r25, 7
    11ce:	06 c0       	rjmp	.+12     	; 0x11dc <_ZN7Serial_9availableEv+0x16>
int Serial_::available(void)
    11d0:	82 e0       	ldi	r24, 0x02	; 2
    11d2:	0e 94 36 0a 	call	0x146c	; 0x146c <_Z13USB_Availableh>
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	01 96       	adiw	r24, 0x01	; 1
    11da:	08 95       	ret
{
	if (peek_buffer >= 0) {
    11dc:	82 e0       	ldi	r24, 0x02	; 2
    11de:	0e 94 36 0a 	call	0x146c	; 0x146c <_Z13USB_Availableh>
    11e2:	90 e0       	ldi	r25, 0x00	; 0
		return 1 + USB_Available(CDC_RX);
    11e4:	08 95       	ret

000011e6 <_ZN7Serial_4readEv>:
int Serial_::peek(void)
{
	if (peek_buffer < 0)
		peek_buffer = USB_Recv(CDC_RX);
	return peek_buffer;
}
    11e6:	fc 01       	movw	r30, r24

    11e8:	84 85       	ldd	r24, Z+12	; 0x0c
    11ea:	95 85       	ldd	r25, Z+13	; 0x0d
    11ec:	97 fd       	sbrc	r25, 7
    11ee:	05 c0       	rjmp	.+10     	; 0x11fa <_ZN7Serial_4readEv+0x14>
int Serial_::read(void)
{
    11f0:	2f ef       	ldi	r18, 0xFF	; 255
    11f2:	3f ef       	ldi	r19, 0xFF	; 255
    11f4:	35 87       	std	Z+13, r19	; 0x0d
    11f6:	24 87       	std	Z+12, r18	; 0x0c
	if (peek_buffer >= 0) {
    11f8:	08 95       	ret
		int c = peek_buffer;
		peek_buffer = -1;
    11fa:	82 e0       	ldi	r24, 0x02	; 2
    11fc:	0c 94 8e 0a 	jmp	0x151c	; 0x151c <_Z8USB_Recvh>

00001200 <_ZN7Serial_5writeEPKhj>:
}

size_t Serial_::write(uint8_t c)
{
	return write(&c, 1);
}
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	ec 01       	movw	r28, r24
	 is open (not just the pipe) - the OS should set lineState when the port
	 is opened and clear lineState when the port is closed.
	 bytes sent before the user opens the connection or after
	 the connection is closed are lost - just like with a UART. */
	
	// TODO - ZE - check behavior on different OSes and test what happens if an
    1206:	80 91 08 01 	lds	r24, 0x0108
    120a:	88 23       	and	r24, r24
    120c:	31 f0       	breq	.+12     	; 0x121a <_ZN7Serial_5writeEPKhj+0x1a>
	// open connection isn't broken cleanly (cable is yanked out, host dies
    120e:	83 e0       	ldi	r24, 0x03	; 3
    1210:	0e 94 bf 0a 	call	0x157e	; 0x157e <_Z8USB_SendhPKvi>
	// or locks up, or host virtual serial port hangs)
    1214:	18 16       	cp	r1, r24
    1216:	19 06       	cpc	r1, r25
    1218:	34 f0       	brlt	.+12     	; 0x1226 <_ZN7Serial_5writeEPKhj+0x26>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    121a:	81 e0       	ldi	r24, 0x01	; 1
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	9b 83       	std	Y+3, r25	; 0x03
    1220:	8a 83       	std	Y+2, r24	; 0x02
		if (r > 0) {
			return r;
		} else {
			setWriteError();
			return 0;
		}
    1222:	80 e0       	ldi	r24, 0x00	; 0
    1224:	90 e0       	ldi	r25, 0x00	; 0
	}
    1226:	df 91       	pop	r29
    1228:	cf 91       	pop	r28
    122a:	08 95       	ret

0000122c <_Z16CDC_GetInterfacePh>:
};

int WEAK CDC_GetInterface(u8* interfaceNum)
{
	interfaceNum[0] += 2;	// uses 2
	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
    122c:	fc 01       	movw	r30, r24
    122e:	20 81       	ld	r18, Z
    1230:	2e 5f       	subi	r18, 0xFE	; 254
    1232:	20 83       	st	Z, r18
}
    1234:	42 e4       	ldi	r20, 0x42	; 66
    1236:	50 e0       	ldi	r21, 0x00	; 0
    1238:	6a e5       	ldi	r22, 0x5A	; 90
    123a:	71 e0       	ldi	r23, 0x01	; 1
    123c:	80 e8       	ldi	r24, 0x80	; 128
    123e:	0c 94 5a 0b 	jmp	0x16b4	; 0x16b4 <_Z15USB_SendControlhPKvi>

00001242 <_Z9CDC_SetupR5Setup>:

bool WEAK CDC_Setup(Setup& setup)
{
	u8 r = setup.bRequest;
    1242:	fc 01       	movw	r30, r24
	u8 requestType = setup.bmRequestType;
    1244:	81 81       	ldd	r24, Z+1	; 0x01

    1246:	90 81       	ld	r25, Z
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
	{
    1248:	91 3a       	cpi	r25, 0xA1	; 161
    124a:	59 f4       	brne	.+22     	; 0x1262 <_Z9CDC_SetupR5Setup+0x20>
		if (CDC_GET_LINE_CODING == r)
		{
    124c:	81 32       	cpi	r24, 0x21	; 33
    124e:	09 f0       	breq	.+2      	; 0x1252 <_Z9CDC_SetupR5Setup+0x10>
    1250:	4b c0       	rjmp	.+150    	; 0x12e8 <_Z9CDC_SetupR5Setup+0xa6>
			USB_SendControl(0,(void*)&_usbLineInfo,7);
			return true;
    1252:	47 e0       	ldi	r20, 0x07	; 7
    1254:	50 e0       	ldi	r21, 0x00	; 0
    1256:	61 e0       	ldi	r22, 0x01	; 1
    1258:	71 e0       	ldi	r23, 0x01	; 1
    125a:	80 e0       	ldi	r24, 0x00	; 0
    125c:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <_Z15USB_SendControlhPKvi>
    1260:	45 c0       	rjmp	.+138    	; 0x12ec <_Z9CDC_SetupR5Setup+0xaa>
		}
	}

	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
	{
    1262:	91 32       	cpi	r25, 0x21	; 33
    1264:	09 f0       	breq	.+2      	; 0x1268 <_Z9CDC_SetupR5Setup+0x26>
    1266:	40 c0       	rjmp	.+128    	; 0x12e8 <_Z9CDC_SetupR5Setup+0xa6>
		if (CDC_SET_LINE_CODING == r)
		{
    1268:	80 32       	cpi	r24, 0x20	; 32
    126a:	39 f4       	brne	.+14     	; 0x127a <_Z9CDC_SetupR5Setup+0x38>
			USB_RecvControl((void*)&_usbLineInfo,7);
		}
    126c:	67 e0       	ldi	r22, 0x07	; 7
    126e:	70 e0       	ldi	r23, 0x00	; 0
    1270:	81 e0       	ldi	r24, 0x01	; 1
    1272:	91 e0       	ldi	r25, 0x01	; 1
    1274:	0e 94 8b 0b 	call	0x1716	; 0x1716 <_Z15USB_RecvControlPvi>
    1278:	39 c0       	rjmp	.+114    	; 0x12ec <_Z9CDC_SetupR5Setup+0xaa>

		if (CDC_SET_CONTROL_LINE_STATE == r)
		{
			_usbLineInfo.lineState = setup.wValueL;
    127a:	82 32       	cpi	r24, 0x22	; 34
    127c:	09 f0       	breq	.+2      	; 0x1280 <_Z9CDC_SetupR5Setup+0x3e>
    127e:	34 c0       	rjmp	.+104    	; 0x12e8 <_Z9CDC_SetupR5Setup+0xa6>
		}

    1280:	82 81       	ldd	r24, Z+2	; 0x02
    1282:	80 93 08 01 	sts	0x0108, r24
		if (CDC_SET_LINE_CODING == r || CDC_SET_CONTROL_LINE_STATE == r)
		{
			// auto-reset into the bootloader is triggered when the port, already 
			// open at 1200 bps, is closed.  this is the signal to start the watchdog
			// with a relatively long period so it can finish housekeeping tasks
			// like servicing endpoints before the sketch ends
    1286:	80 91 01 01 	lds	r24, 0x0101
    128a:	90 91 02 01 	lds	r25, 0x0102
    128e:	a0 91 03 01 	lds	r26, 0x0103
    1292:	b0 91 04 01 	lds	r27, 0x0104
    1296:	80 3b       	cpi	r24, 0xB0	; 176
    1298:	94 40       	sbci	r25, 0x04	; 4
    129a:	a1 05       	cpc	r26, r1
    129c:	b1 05       	cpc	r27, r1
    129e:	31 f5       	brne	.+76     	; 0x12ec <_Z9CDC_SetupR5Setup+0xaa>

			// We check DTR state to determine if host port is open (bit 0 of lineState).
    12a0:	80 91 08 01 	lds	r24, 0x0108
    12a4:	80 fd       	sbrc	r24, 0
    12a6:	12 c0       	rjmp	.+36     	; 0x12cc <_Z9CDC_SetupR5Setup+0x8a>
			if (1200 == _usbLineInfo.dwDTERate && (_usbLineInfo.lineState & 0x01) == 0)
    12a8:	87 e7       	ldi	r24, 0x77	; 119
    12aa:	97 e7       	ldi	r25, 0x77	; 119
    12ac:	90 93 01 08 	sts	0x0801, r25
    12b0:	80 93 00 08 	sts	0x0800, r24
			{
    12b4:	2b e0       	ldi	r18, 0x0B	; 11
    12b6:	88 e1       	ldi	r24, 0x18	; 24
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	a8 95       	wdr
    12c0:	80 93 60 00 	sts	0x0060, r24
    12c4:	0f be       	out	0x3f, r0	; 63
    12c6:	20 93 60 00 	sts	0x0060, r18
    12ca:	10 c0       	rjmp	.+32     	; 0x12ec <_Z9CDC_SetupR5Setup+0xaa>
				wdt_enable(WDTO_120MS);
			}
			else
			{
				// Most OSs do some intermediate steps when configuring ports and DTR can
				// twiggle more than once before stabilizing.
    12cc:	88 e1       	ldi	r24, 0x18	; 24
    12ce:	0f b6       	in	r0, 0x3f	; 63
    12d0:	f8 94       	cli
    12d2:	80 93 60 00 	sts	0x0060, r24
    12d6:	10 92 60 00 	sts	0x0060, r1
    12da:	0f be       	out	0x3f, r0	; 63
				// To avoid spurious resets we set the watchdog to 250ms and eventually
    12dc:	a8 95       	wdr
				// cancel if DTR goes back high.
    12de:	10 92 01 08 	sts	0x0801, r1
    12e2:	10 92 00 08 	sts	0x0800, r1
    12e6:	02 c0       	rjmp	.+4      	; 0x12ec <_Z9CDC_SetupR5Setup+0xaa>

				wdt_disable();
				wdt_reset();
				*(uint16_t *)0x0800 = 0x0;
			}
		}
    12e8:	80 e0       	ldi	r24, 0x00	; 0
    12ea:	08 95       	ret
				// twiggle more than once before stabilizing.
				// To avoid spurious resets we set the watchdog to 250ms and eventually
				// cancel if DTR goes back high.

				wdt_disable();
				wdt_reset();
    12ec:	81 e0       	ldi	r24, 0x01	; 1
				*(uint16_t *)0x0800 = 0x0;
			}
		}
		return true;
    12ee:	08 95       	ret

000012f0 <_GLOBAL__sub_I__cdcInterface>:
  public:
    Print() : write_error(0) {}
    12f0:	10 92 06 02 	sts	0x0206, r1
    12f4:	10 92 05 02 	sts	0x0205, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    12f8:	88 ee       	ldi	r24, 0xE8	; 232
    12fa:	93 e0       	ldi	r25, 0x03	; 3
    12fc:	a0 e0       	ldi	r26, 0x00	; 0
    12fe:	b0 e0       	ldi	r27, 0x00	; 0
    1300:	80 93 07 02 	sts	0x0207, r24
    1304:	90 93 08 02 	sts	0x0208, r25
    1308:	a0 93 09 02 	sts	0x0209, r26
    130c:	b0 93 0a 02 	sts	0x020A, r27

#include "USBDesc.h"
#include "USBCore.h"

//================================================================================
//================================================================================
    1310:	8b e3       	ldi	r24, 0x3B	; 59
    1312:	91 e0       	ldi	r25, 0x01	; 1
    1314:	90 93 04 02 	sts	0x0204, r25
    1318:	80 93 03 02 	sts	0x0203, r24
    131c:	8f ef       	ldi	r24, 0xFF	; 255
    131e:	9f ef       	ldi	r25, 0xFF	; 255
    1320:	90 93 10 02 	sts	0x0210, r25
    1324:	80 93 0f 02 	sts	0x020F, r24
    1328:	08 95       	ret

0000132a <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
    132a:	cf 92       	push	r12
    132c:	df 92       	push	r13
    132e:	ef 92       	push	r14
    1330:	ff 92       	push	r15
    1332:	0f 93       	push	r16
    1334:	1f 93       	push	r17
    1336:	cf 93       	push	r28
    1338:	df 93       	push	r29
    133a:	6c 01       	movw	r12, r24
    133c:	7a 01       	movw	r14, r20
    133e:	eb 01       	movw	r28, r22
    1340:	e6 0e       	add	r14, r22
    1342:	f7 1e       	adc	r15, r23
  size_t n = 0;
    1344:	00 e0       	ldi	r16, 0x00	; 0
    1346:	10 e0       	ldi	r17, 0x00	; 0
  while (size--) {
    1348:	ce 15       	cp	r28, r14
    134a:	df 05       	cpc	r29, r15
    134c:	61 f0       	breq	.+24     	; 0x1366 <_ZN5Print5writeEPKhj+0x3c>
    n += write(*buffer++);
    134e:	69 91       	ld	r22, Y+
    1350:	d6 01       	movw	r26, r12
    1352:	ed 91       	ld	r30, X+
    1354:	fc 91       	ld	r31, X
    1356:	01 90       	ld	r0, Z+
    1358:	f0 81       	ld	r31, Z
    135a:	e0 2d       	mov	r30, r0
    135c:	c6 01       	movw	r24, r12
    135e:	09 95       	icall
    1360:	08 0f       	add	r16, r24
    1362:	19 1f       	adc	r17, r25
    1364:	f1 cf       	rjmp	.-30     	; 0x1348 <_ZN5Print5writeEPKhj+0x1e>
  }
  return n;
}
    1366:	c8 01       	movw	r24, r16
    1368:	df 91       	pop	r29
    136a:	cf 91       	pop	r28
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	ff 90       	pop	r15
    1372:	ef 90       	pop	r14
    1374:	df 90       	pop	r13
    1376:	cf 90       	pop	r12
    1378:	08 95       	ret

0000137a <_ZL11SendControlh>:
static
bool SendControl(u8 d)
{
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
    137a:	40 91 57 02 	lds	r20, 0x0257
    137e:	50 91 58 02 	lds	r21, 0x0258
    1382:	20 91 55 02 	lds	r18, 0x0255
    1386:	30 91 56 02 	lds	r19, 0x0256
    138a:	42 17       	cp	r20, r18
    138c:	53 07       	cpc	r21, r19
    138e:	b4 f4       	brge	.+44     	; 0x13bc <_ZL11SendControlh+0x42>

static inline u8 WaitForINOrOUT()
{
	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
		;
	return (UEINTX & (1<<RXOUTI)) == 0;
    1390:	90 91 e8 00 	lds	r25, 0x00E8
    1394:	95 70       	andi	r25, 0x05	; 5
    1396:	e1 f3       	breq	.-8      	; 0x1390 <_ZL11SendControlh+0x16>
}

    1398:	90 91 e8 00 	lds	r25, 0x00E8
{
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
    139c:	92 fd       	sbrc	r25, 2
    139e:	19 c0       	rjmp	.+50     	; 0x13d2 <_ZL11SendControlh+0x58>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

    13a0:	80 93 f1 00 	sts	0x00F1, r24
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
			ClearIN();	// Fifo is full, release this packet
	}
    13a4:	80 91 57 02 	lds	r24, 0x0257
    13a8:	90 91 58 02 	lds	r25, 0x0258
    13ac:	01 96       	adiw	r24, 0x01	; 1
    13ae:	8f 73       	andi	r24, 0x3F	; 63
    13b0:	99 27       	eor	r25, r25
    13b2:	89 2b       	or	r24, r25
    13b4:	19 f4       	brne	.+6      	; 0x13bc <_ZL11SendControlh+0x42>

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
}

    13b6:	8e ef       	ldi	r24, 0xFE	; 254
    13b8:	80 93 e8 00 	sts	0x00E8, r24
		if (!((_cmark + 1) & 0x3F))
			ClearIN();	// Fifo is full, release this packet
	}
	_cmark++;
	return true;
};
    13bc:	80 91 57 02 	lds	r24, 0x0257
    13c0:	90 91 58 02 	lds	r25, 0x0258
    13c4:	01 96       	adiw	r24, 0x01	; 1
    13c6:	90 93 58 02 	sts	0x0258, r25
    13ca:	80 93 57 02 	sts	0x0257, r24

    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	08 95       	ret
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
    13d2:	80 e0       	ldi	r24, 0x00	; 0
	}
	_cmark++;
	return true;
};

//	Clipped by _cmark/_cend
    13d4:	08 95       	ret

000013d6 <_ZL24USB_SendStringDescriptorPKhh>:
// Send a USB descriptor string. The string is stored in PROGMEM as a
// plain ASCII string but is sent out as UTF-16 with the correct 2-byte
// prefix
static bool USB_SendStringDescriptor(const u8*string_P, u8 string_len) {
        SendControl(2 + string_len * 2);
        SendControl(3);
    13d6:	cf 92       	push	r12
    13d8:	df 92       	push	r13
    13da:	ff 92       	push	r15
    13dc:	0f 93       	push	r16
    13de:	1f 93       	push	r17
    13e0:	cf 93       	push	r28
    13e2:	df 93       	push	r29
    13e4:	1f 92       	push	r1
    13e6:	cd b7       	in	r28, 0x3d	; 61
    13e8:	de b7       	in	r29, 0x3e	; 62
    13ea:	08 2f       	mov	r16, r24
    13ec:	16 2f       	mov	r17, r22
        for(u8 i = 0; i < string_len; i++) {
    13ee:	86 2f       	mov	r24, r22
    13f0:	88 0f       	add	r24, r24
    13f2:	8e 5f       	subi	r24, 0xFE	; 254
    13f4:	99 83       	std	Y+1, r25	; 0x01
    13f6:	0e 94 bd 09 	call	0x137a	; 0x137a <_ZL11SendControlh>
                bool r = SendControl(pgm_read_byte(&string_P[i]));
    13fa:	83 e0       	ldi	r24, 0x03	; 3
    13fc:	0e 94 bd 09 	call	0x137a	; 0x137a <_ZL11SendControlh>
    1400:	f0 2e       	mov	r15, r16
                r &= SendControl(0); // high byte
    1402:	c0 2e       	mov	r12, r16
    1404:	99 81       	ldd	r25, Y+1	; 0x01
    1406:	d9 2e       	mov	r13, r25
    1408:	8c 2d       	mov	r24, r12
    140a:	8f 19       	sub	r24, r15
    140c:	81 17       	cp	r24, r17
    140e:	78 f4       	brcc	.+30     	; 0x142e <_ZL24USB_SendStringDescriptorPKhh+0x58>
                if(!r) {
    1410:	f6 01       	movw	r30, r12
    1412:	84 91       	lpm	r24, Z
    1414:	0e 94 bd 09 	call	0x137a	; 0x137a <_ZL11SendControlh>
    1418:	08 2f       	mov	r16, r24
                        return false;
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	0e 94 bd 09 	call	0x137a	; 0x137a <_ZL11SendControlh>
    1420:	80 23       	and	r24, r16
    1422:	ff ef       	ldi	r31, 0xFF	; 255
    1424:	cf 1a       	sub	r12, r31
    1426:	df 0a       	sbc	r13, r31
                }
    1428:	81 11       	cpse	r24, r1
    142a:	ee cf       	rjmp	.-36     	; 0x1408 <_ZL24USB_SendStringDescriptorPKhh+0x32>
    142c:	01 c0       	rjmp	.+2      	; 0x1430 <_ZL24USB_SendStringDescriptorPKhh+0x5a>
        }
        return true;
}

    142e:	81 e0       	ldi	r24, 0x01	; 1
//	Does not timeout or cross fifo boundaries
    1430:	0f 90       	pop	r0
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	1f 91       	pop	r17
    1438:	0f 91       	pop	r16
    143a:	ff 90       	pop	r15
    143c:	df 90       	pop	r13
    143e:	cf 90       	pop	r12
    1440:	08 95       	ret

00001442 <_Z4RecvPVhh>:

void Recv(volatile u8* data, u8 count)
{
	while (count--)
		*data++ = UEDATX;
	
    1442:	61 50       	subi	r22, 0x01	; 1
    1444:	30 f0       	brcs	.+12     	; 0x1452 <_Z4RecvPVhh+0x10>
	RXLED1;					// light the RX LED
    1446:	20 91 f1 00 	lds	r18, 0x00F1
    144a:	fc 01       	movw	r30, r24
    144c:	20 83       	st	Z, r18
    144e:	01 96       	adiw	r24, 0x01	; 1
    1450:	f8 cf       	rjmp	.-16     	; 0x1442 <_Z4RecvPVhh>
	RxLEDPulse = TX_RX_LED_PULSE_MS;	
}
    1452:	28 98       	cbi	0x05, 0	; 5

    1454:	84 e6       	ldi	r24, 0x64	; 100
    1456:	80 93 5a 02 	sts	0x025A, r24
    145a:	08 95       	ret

0000145c <_ZN6LockEPC1Eh>:
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
	{
		cli();
    145c:	2f b7       	in	r18, 0x3f	; 63
    145e:	fc 01       	movw	r30, r24
    1460:	20 83       	st	Z, r18
		SetEP(ep & 7);
	}
    1462:	f8 94       	cli
	~LockEP()
    1464:	67 70       	andi	r22, 0x07	; 7

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

    1466:	60 93 e9 00 	sts	0x00E9, r22
    146a:	08 95       	ret

0000146c <_Z13USB_Availableh>:

//	Number of bytes, assumes a rx endpoint
u8 USB_Available(u8 ep)
{
	LockEP lock(ep);
	return FifoByteCount();
    146c:	cf 93       	push	r28
    146e:	df 93       	push	r29
    1470:	1f 92       	push	r1
    1472:	cd b7       	in	r28, 0x3d	; 61
    1474:	de b7       	in	r29, 0x3e	; 62
}
    1476:	68 2f       	mov	r22, r24
    1478:	ce 01       	movw	r24, r28
    147a:	01 96       	adiw	r24, 0x01	; 1
    147c:	0e 94 2e 0a 	call	0x145c	; 0x145c <_ZN6LockEPC1Eh>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

    1480:	80 91 f2 00 	lds	r24, 0x00F2
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
    1484:	99 81       	ldd	r25, Y+1	; 0x01
    1486:	9f bf       	out	0x3f, r25	; 63
{
	LockEP lock(ep);
	return FifoByteCount();
}

//	Non Blocking receive
    1488:	0f 90       	pop	r0
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	08 95       	ret

00001490 <_Z8USB_RecvhPvi>:
//	Return number of bytes read
int USB_Recv(u8 ep, void* d, int len)
{
	if (!_usbConfiguration || len < 0)
		return -1;
    1490:	ff 92       	push	r15
    1492:	0f 93       	push	r16
    1494:	1f 93       	push	r17
    1496:	cf 93       	push	r28
    1498:	df 93       	push	r29
    149a:	00 d0       	rcall	.+0      	; 0x149c <_Z8USB_RecvhPvi+0xc>
    149c:	cd b7       	in	r28, 0x3d	; 61
    149e:	de b7       	in	r29, 0x3e	; 62
    14a0:	f6 2e       	mov	r15, r22
    14a2:	8a 01       	movw	r16, r20
	
    14a4:	90 91 59 02 	lds	r25, 0x0259
    14a8:	99 23       	and	r25, r25
    14aa:	11 f0       	breq	.+4      	; 0x14b0 <_Z8USB_RecvhPvi+0x20>
    14ac:	57 ff       	sbrs	r21, 7
    14ae:	03 c0       	rjmp	.+6      	; 0x14b6 <_Z8USB_RecvhPvi+0x26>
	LockEP lock(ep);
    14b0:	8f ef       	ldi	r24, 0xFF	; 255
    14b2:	9f ef       	ldi	r25, 0xFF	; 255
    14b4:	2b c0       	rjmp	.+86     	; 0x150c <_Z8USB_RecvhPvi+0x7c>
	u8 n = FifoByteCount();
	len = min(n,len);
    14b6:	68 2f       	mov	r22, r24
    14b8:	ce 01       	movw	r24, r28
    14ba:	01 96       	adiw	r24, 0x01	; 1
    14bc:	7a 83       	std	Y+2, r23	; 0x02
    14be:	0e 94 2e 0a 	call	0x145c	; 0x145c <_ZN6LockEPC1Eh>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

    14c2:	80 91 f2 00 	lds	r24, 0x00F2
	
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
    14c6:	90 e0       	ldi	r25, 0x00	; 0
    14c8:	a8 01       	movw	r20, r16
    14ca:	7a 81       	ldd	r23, Y+2	; 0x02
    14cc:	80 17       	cp	r24, r16
    14ce:	91 07       	cpc	r25, r17
    14d0:	0c f4       	brge	.+2      	; 0x14d4 <_Z8USB_RecvhPvi+0x44>
    14d2:	ac 01       	movw	r20, r24
    14d4:	ef 2d       	mov	r30, r15
    14d6:	f7 2f       	mov	r31, r23
    14d8:	f4 0e       	add	r15, r20
static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;

	return UEDATX;	
    14da:	84 e6       	ldi	r24, 0x64	; 100
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
    14dc:	fe 16       	cp	r15, r30
    14de:	39 f0       	breq	.+14     	; 0x14ee <_Z8USB_RecvhPvi+0x5e>

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;

    14e0:	28 98       	cbi	0x05, 0	; 5
	return UEDATX;	
    14e2:	80 93 5a 02 	sts	0x025A, r24
}

    14e6:	90 91 f1 00 	lds	r25, 0x00F1
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
		ReleaseRX();
    14ea:	91 93       	st	Z+, r25
    14ec:	f7 cf       	rjmp	.-18     	; 0x14dc <_Z8USB_RecvhPvi+0x4c>
	
    14ee:	41 15       	cp	r20, r1
    14f0:	51 05       	cpc	r21, r1
    14f2:	21 f0       	breq	.+8      	; 0x14fc <_Z8USB_RecvhPvi+0x6c>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

    14f4:	80 91 f2 00 	lds	r24, 0x00F2
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
		ReleaseRX();
	
    14f8:	88 23       	and	r24, r24
    14fa:	21 f0       	breq	.+8      	; 0x1504 <_Z8USB_RecvhPvi+0x74>
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
    14fc:	89 81       	ldd	r24, Y+1	; 0x01
    14fe:	8f bf       	out	0x3f, r24	; 63
	
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
    1500:	ca 01       	movw	r24, r20
    1502:	04 c0       	rjmp	.+8      	; 0x150c <_Z8USB_RecvhPvi+0x7c>

static inline void ReleaseRX()
{
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

    1504:	8b e6       	ldi	r24, 0x6B	; 107
    1506:	80 93 e8 00 	sts	0x00E8, r24
    150a:	f8 cf       	rjmp	.-16     	; 0x14fc <_Z8USB_RecvhPvi+0x6c>
		ReleaseRX();
	
	return len;
}

//	Recv 1 byte if ready
    150c:	0f 90       	pop	r0
    150e:	0f 90       	pop	r0
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	ff 90       	pop	r15
    151a:	08 95       	ret

0000151c <_Z8USB_Recvh>:
int USB_Recv(u8 ep)
{
	u8 c;
	if (USB_Recv(ep,&c,1) != 1)
    151c:	cf 93       	push	r28
    151e:	df 93       	push	r29
    1520:	1f 92       	push	r1
    1522:	cd b7       	in	r28, 0x3d	; 61
    1524:	de b7       	in	r29, 0x3e	; 62
		return -1;
	return c;
    1526:	41 e0       	ldi	r20, 0x01	; 1
    1528:	50 e0       	ldi	r21, 0x00	; 0
    152a:	be 01       	movw	r22, r28
    152c:	6f 5f       	subi	r22, 0xFF	; 255
    152e:	7f 4f       	sbci	r23, 0xFF	; 255
    1530:	0e 94 48 0a 	call	0x1490	; 0x1490 <_Z8USB_RecvhPvi>
    1534:	01 97       	sbiw	r24, 0x01	; 1
    1536:	19 f4       	brne	.+6      	; 0x153e <_Z8USB_Recvh+0x22>
}

    1538:	89 81       	ldd	r24, Y+1	; 0x01
    153a:	90 e0       	ldi	r25, 0x00	; 0
    153c:	02 c0       	rjmp	.+4      	; 0x1542 <_Z8USB_Recvh+0x26>
{
	u8 c;
	if (USB_Recv(ep,&c,1) != 1)
		return -1;
	return c;
}
    153e:	8f ef       	ldi	r24, 0xFF	; 255
    1540:	9f ef       	ldi	r25, 0xFF	; 255

//	Space in send EP
    1542:	0f 90       	pop	r0
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	08 95       	ret

0000154a <_Z13USB_SendSpaceh>:
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
    154a:	cf 93       	push	r28
    154c:	df 93       	push	r29
    154e:	1f 92       	push	r1
    1550:	cd b7       	in	r28, 0x3d	; 61
    1552:	de b7       	in	r29, 0x3e	; 62
		return 0;
    1554:	68 2f       	mov	r22, r24
    1556:	ce 01       	movw	r24, r28
    1558:	01 96       	adiw	r24, 0x01	; 1
    155a:	0e 94 2e 0a 	call	0x145c	; 0x145c <_ZN6LockEPC1Eh>

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
}

    155e:	90 91 e8 00 	lds	r25, 0x00E8
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
    1562:	89 2f       	mov	r24, r25
    1564:	80 72       	andi	r24, 0x20	; 32
    1566:	95 ff       	sbrs	r25, 5
    1568:	04 c0       	rjmp	.+8      	; 0x1572 <_Z13USB_SendSpaceh+0x28>

static inline u8 FifoByteCount()
{
	return UEBCLX;
}

    156a:	90 91 f2 00 	lds	r25, 0x00F2
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
}

    156e:	80 e4       	ldi	r24, 0x40	; 64
    1570:	89 1b       	sub	r24, r25
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
    1572:	99 81       	ldd	r25, Y+1	; 0x01
    1574:	9f bf       	out	0x3f, r25	; 63
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
}

//	Blocking Send of data to an endpoint
    1576:	0f 90       	pop	r0
    1578:	df 91       	pop	r29
    157a:	cf 91       	pop	r28
    157c:	08 95       	ret

0000157e <_Z8USB_SendhPKvi>:
int USB_Send(u8 ep, const void* d, int len)
{
	if (!_usbConfiguration)
		return -1;
    157e:	6f 92       	push	r6
    1580:	7f 92       	push	r7
    1582:	8f 92       	push	r8
    1584:	9f 92       	push	r9
    1586:	af 92       	push	r10
    1588:	bf 92       	push	r11
    158a:	cf 92       	push	r12
    158c:	df 92       	push	r13
    158e:	ef 92       	push	r14
    1590:	ff 92       	push	r15
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	1f 92       	push	r1
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
    15a0:	78 2e       	mov	r7, r24
    15a2:	7b 01       	movw	r14, r22
    15a4:	c4 2e       	mov	r12, r20
    15a6:	b5 2e       	mov	r11, r21

    15a8:	80 91 59 02 	lds	r24, 0x0259
    15ac:	88 23       	and	r24, r24
    15ae:	69 f0       	breq	.+26     	; 0x15ca <_Z8USB_SendhPKvi+0x4c>
    15b0:	04 2f       	mov	r16, r20
    15b2:	15 2f       	mov	r17, r21
    15b4:	8a ef       	ldi	r24, 0xFA	; 250
    15b6:	d8 2e       	mov	r13, r24
			if (!ReadWriteAllowed())
				continue;
			len -= n;
			if (ep & TRANSFER_ZERO)
			{
				while (n--)
    15b8:	87 2d       	mov	r24, r7
    15ba:	80 72       	andi	r24, 0x20	; 32
    15bc:	98 2e       	mov	r9, r24

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
}

    15be:	9a e3       	ldi	r25, 0x3A	; 58
    15c0:	a9 2e       	mov	r10, r25
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
				ReleaseTX();
		}
    15c2:	87 2d       	mov	r24, r7
    15c4:	80 74       	andi	r24, 0x40	; 64
    15c6:	88 2e       	mov	r8, r24
    15c8:	11 c0       	rjmp	.+34     	; 0x15ec <_Z8USB_SendhPKvi+0x6e>
int USB_Send(u8 ep, const void* d, int len)
{
	if (!_usbConfiguration)
		return -1;

	int r = len;
    15ca:	8f ef       	ldi	r24, 0xFF	; 255
    15cc:	9f ef       	ldi	r25, 0xFF	; 255
    15ce:	57 c0       	rjmp	.+174    	; 0x167e <_Z8USB_SendhPKvi+0x100>
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
	{
		u8 n = USB_SendSpace(ep);
		if (n == 0)
		{
    15d0:	87 2d       	mov	r24, r7
    15d2:	0e 94 a5 0a 	call	0x154a	; 0x154a <_Z13USB_SendSpaceh>
    15d6:	68 2e       	mov	r6, r24
			if (!(--timeout))
    15d8:	81 11       	cpse	r24, r1
    15da:	0c c0       	rjmp	.+24     	; 0x15f4 <_Z8USB_SendhPKvi+0x76>
				return -1;
			delay(1);
    15dc:	da 94       	dec	r13
    15de:	a9 f3       	breq	.-22     	; 0x15ca <_Z8USB_SendhPKvi+0x4c>
			continue;
		}
    15e0:	61 e0       	ldi	r22, 0x01	; 1
    15e2:	70 e0       	ldi	r23, 0x00	; 0
    15e4:	80 e0       	ldi	r24, 0x00	; 0
    15e6:	90 e0       	ldi	r25, 0x00	; 0
    15e8:	0e 94 5e 07 	call	0xebc	; 0xebc <delay>
	int r = len;
	const u8* data = (const u8*)d;
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
	{
		u8 n = USB_SendSpace(ep);
    15ec:	01 15       	cp	r16, r1
    15ee:	11 05       	cpc	r17, r1
    15f0:	79 f7       	brne	.-34     	; 0x15d0 <_Z8USB_SendhPKvi+0x52>
    15f2:	3b c0       	rjmp	.+118    	; 0x166a <_Z8USB_SendhPKvi+0xec>
			continue;
		}

		if (n > len)
			n = len;
		{
    15f4:	28 2f       	mov	r18, r24
    15f6:	30 e0       	ldi	r19, 0x00	; 0
    15f8:	02 17       	cp	r16, r18
    15fa:	13 07       	cpc	r17, r19
    15fc:	0c f4       	brge	.+2      	; 0x1600 <_Z8USB_SendhPKvi+0x82>
			LockEP lock(ep);
    15fe:	60 2e       	mov	r6, r16
			// Frame may have been released by the SOF interrupt handler
			if (!ReadWriteAllowed())
    1600:	67 2d       	mov	r22, r7
    1602:	ce 01       	movw	r24, r28
    1604:	01 96       	adiw	r24, 0x01	; 1
    1606:	0e 94 2e 0a 	call	0x145c	; 0x145c <_ZN6LockEPC1Eh>

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
}

    160a:	80 91 e8 00 	lds	r24, 0x00E8
		{
			LockEP lock(ep);
			// Frame may have been released by the SOF interrupt handler
			if (!ReadWriteAllowed())
				continue;
			len -= n;
    160e:	85 ff       	sbrs	r24, 5
    1610:	29 c0       	rjmp	.+82     	; 0x1664 <_Z8USB_SendhPKvi+0xe6>
			if (ep & TRANSFER_ZERO)
			{
    1612:	26 2d       	mov	r18, r6
    1614:	30 e0       	ldi	r19, 0x00	; 0
    1616:	02 1b       	sub	r16, r18
    1618:	13 0b       	sbc	r17, r19
				while (n--)
    161a:	99 20       	and	r9, r9
    161c:	39 f0       	breq	.+14     	; 0x162c <_Z8USB_SendhPKvi+0xae>
					Send8(0);
			}
    161e:	6a 94       	dec	r6
    1620:	8f ef       	ldi	r24, 0xFF	; 255
    1622:	68 16       	cp	r6, r24
    1624:	b1 f0       	breq	.+44     	; 0x1652 <_Z8USB_SendhPKvi+0xd4>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

    1626:	10 92 f1 00 	sts	0x00F1, r1
    162a:	f9 cf       	rjmp	.-14     	; 0x161e <_Z8USB_SendhPKvi+0xa0>
				while (n--)
					Send8(0);
			}
			else if (ep & TRANSFER_PGM)
			{
				while (n--)
    162c:	f7 01       	movw	r30, r14
    162e:	86 2d       	mov	r24, r6
    1630:	77 fe       	sbrs	r7, 7
    1632:	07 c0       	rjmp	.+14     	; 0x1642 <_Z8USB_SendhPKvi+0xc4>
					Send8(pgm_read_byte(data++));
			}
    1634:	81 50       	subi	r24, 0x01	; 1
    1636:	58 f0       	brcs	.+22     	; 0x164e <_Z8USB_SendhPKvi+0xd0>
			else
    1638:	94 91       	lpm	r25, Z

static inline void Send8(u8 d)
{
	UEDATX = d;
}

    163a:	90 93 f1 00 	sts	0x00F1, r25
    163e:	31 96       	adiw	r30, 0x01	; 1
    1640:	f9 cf       	rjmp	.-14     	; 0x1634 <_Z8USB_SendhPKvi+0xb6>
			}
			else
			{
				while (n--)
					Send8(*data++);
			}
    1642:	81 50       	subi	r24, 0x01	; 1
    1644:	20 f0       	brcs	.+8      	; 0x164e <_Z8USB_SendhPKvi+0xd0>
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
    1646:	91 91       	ld	r25, Z+

static inline void Send8(u8 d)
{
	UEDATX = d;
}

    1648:	90 93 f1 00 	sts	0x00F1, r25
    164c:	fa cf       	rjmp	.-12     	; 0x1642 <_Z8USB_SendhPKvi+0xc4>
    164e:	e2 0e       	add	r14, r18
    1650:	f3 1e       	adc	r15, r19

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
}

    1652:	80 91 e8 00 	lds	r24, 0x00E8
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
				ReleaseTX();
		}
    1656:	85 ff       	sbrs	r24, 5
    1658:	0f c0       	rjmp	.+30     	; 0x1678 <_Z8USB_SendhPKvi+0xfa>
    165a:	01 15       	cp	r16, r1
    165c:	11 05       	cpc	r17, r1
    165e:	11 f4       	brne	.+4      	; 0x1664 <_Z8USB_SendhPKvi+0xe6>
    1660:	81 10       	cpse	r8, r1
    1662:	0a c0       	rjmp	.+20     	; 0x1678 <_Z8USB_SendhPKvi+0xfa>
	}
	~LockEP()
	{
		SREG = _sreg;
	}
};
    1664:	89 81       	ldd	r24, Y+1	; 0x01
    1666:	8f bf       	out	0x3f, r24	; 63
    1668:	c1 cf       	rjmp	.-126    	; 0x15ec <_Z8USB_SendhPKvi+0x6e>
				ReleaseTX();
		}
	}
	TXLED1;					// light the TX LED
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	return r;
    166a:	5d 98       	cbi	0x0b, 5	; 11
}
    166c:	84 e6       	ldi	r24, 0x64	; 100
    166e:	80 93 5b 02 	sts	0x025B, r24

    1672:	8c 2d       	mov	r24, r12
    1674:	9b 2d       	mov	r25, r11
    1676:	03 c0       	rjmp	.+6      	; 0x167e <_Z8USB_SendhPKvi+0x100>

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
}

    1678:	a0 92 e8 00 	sts	0x00E8, r10
    167c:	f3 cf       	rjmp	.-26     	; 0x1664 <_Z8USB_SendhPKvi+0xe6>
	TXLED1;					// light the TX LED
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	return r;
}

extern const u8 _initEndpoints[] PROGMEM;
    167e:	0f 90       	pop	r0
    1680:	df 91       	pop	r29
    1682:	cf 91       	pop	r28
    1684:	1f 91       	pop	r17
    1686:	0f 91       	pop	r16
    1688:	ff 90       	pop	r15
    168a:	ef 90       	pop	r14
    168c:	df 90       	pop	r13
    168e:	cf 90       	pop	r12
    1690:	bf 90       	pop	r11
    1692:	af 90       	pop	r10
    1694:	9f 90       	pop	r9
    1696:	8f 90       	pop	r8
    1698:	7f 90       	pop	r7
    169a:	6f 90       	pop	r6
    169c:	08 95       	ret

0000169e <_Z11InitControli>:

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

    169e:	10 92 e9 00 	sts	0x00E9, r1
void InitControl(int end)
{
	SetEP(0);
	_cmark = 0;
	_cend = end;
}
    16a2:	10 92 58 02 	sts	0x0258, r1
    16a6:	10 92 57 02 	sts	0x0257, r1

    16aa:	90 93 56 02 	sts	0x0256, r25
    16ae:	80 93 55 02 	sts	0x0255, r24
    16b2:	08 95       	ret

000016b4 <_Z15USB_SendControlhPKvi>:

//	Clipped by _cmark/_cend
int USB_SendControl(u8 flags, const void* d, int len)
{
	int sent = len;
	const u8* data = (const u8*)d;
    16b4:	cf 92       	push	r12
    16b6:	df 92       	push	r13
    16b8:	ff 92       	push	r15
    16ba:	0f 93       	push	r16
    16bc:	1f 93       	push	r17
    16be:	cf 93       	push	r28
    16c0:	df 93       	push	r29
    16c2:	00 d0       	rcall	.+0      	; 0x16c4 <_Z15USB_SendControlhPKvi+0x10>
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
    16c8:	f8 2e       	mov	r15, r24
    16ca:	8a 01       	movw	r16, r20
	bool pgm = flags & TRANSFER_PGM;
	while (len--)
	{
		u8 c = pgm ? pgm_read_byte(data++) : *data++;
    16cc:	6b 01       	movw	r12, r22
    16ce:	01 15       	cp	r16, r1
    16d0:	11 05       	cpc	r17, r1
    16d2:	b1 f0       	breq	.+44     	; 0x1700 <_Z15USB_SendControlhPKvi+0x4c>
		if (!SendControl(c))
			return -1;
    16d4:	f6 01       	movw	r30, r12
    16d6:	f7 fe       	sbrs	r15, 7
    16d8:	02 c0       	rjmp	.+4      	; 0x16de <_Z15USB_SendControlhPKvi+0x2a>
    16da:	84 91       	lpm	r24, Z
    16dc:	01 c0       	rjmp	.+2      	; 0x16e0 <_Z15USB_SendControlhPKvi+0x2c>
    16de:	80 81       	ld	r24, Z
	}
    16e0:	49 83       	std	Y+1, r20	; 0x01
    16e2:	5a 83       	std	Y+2, r21	; 0x02
    16e4:	0e 94 bd 09 	call	0x137a	; 0x137a <_ZL11SendControlh>
    16e8:	01 50       	subi	r16, 0x01	; 1
    16ea:	11 09       	sbc	r17, r1
    16ec:	ff ef       	ldi	r31, 0xFF	; 255
    16ee:	cf 1a       	sub	r12, r31
    16f0:	df 0a       	sbc	r13, r31
    16f2:	49 81       	ldd	r20, Y+1	; 0x01
    16f4:	5a 81       	ldd	r21, Y+2	; 0x02
    16f6:	81 11       	cpse	r24, r1
    16f8:	ea cf       	rjmp	.-44     	; 0x16ce <_Z15USB_SendControlhPKvi+0x1a>
	return sent;
    16fa:	8f ef       	ldi	r24, 0xFF	; 255
    16fc:	9f ef       	ldi	r25, 0xFF	; 255
    16fe:	01 c0       	rjmp	.+2      	; 0x1702 <_Z15USB_SendControlhPKvi+0x4e>
}

    1700:	ca 01       	movw	r24, r20
// Send a USB descriptor string. The string is stored in PROGMEM as a
    1702:	0f 90       	pop	r0
    1704:	0f 90       	pop	r0
    1706:	df 91       	pop	r29
    1708:	cf 91       	pop	r28
    170a:	1f 91       	pop	r17
    170c:	0f 91       	pop	r16
    170e:	ff 90       	pop	r15
    1710:	df 90       	pop	r13
    1712:	cf 90       	pop	r12
    1714:	08 95       	ret

00001716 <_Z15USB_RecvControlPvi>:
//	Will only work for transfers <= 64 bytes
//	TODO
int USB_RecvControl(void* d, int len)
{
	WaitOUT();
	Recv((u8*)d,len);
    1716:	1f 93       	push	r17
    1718:	cf 93       	push	r28
    171a:	df 93       	push	r29
    171c:	1f 92       	push	r1
    171e:	cd b7       	in	r28, 0x3d	; 61
    1720:	de b7       	in	r29, 0x3e	; 62
    1722:	16 2f       	mov	r17, r22

static inline void WaitOUT(void)
{
	while (!(UEINTX & (1<<RXOUTI)))
		;
}
    1724:	20 91 e8 00 	lds	r18, 0x00E8
    1728:	22 ff       	sbrs	r18, 2
    172a:	fc cf       	rjmp	.-8      	; 0x1724 <_Z15USB_RecvControlPvi+0xe>
int USB_RecvControl(void* d, int len)
{
	WaitOUT();
	Recv((u8*)d,len);
	ClearOUT();
	return len;
    172c:	61 2f       	mov	r22, r17
    172e:	79 83       	std	Y+1, r23	; 0x01
    1730:	0e 94 21 0a 	call	0x1442	; 0x1442 <_Z4RecvPVhh>

static inline void ClearOUT(void)
{
	UEINTX = ~(1<<RXOUTI);
}

    1734:	8b ef       	ldi	r24, 0xFB	; 251
    1736:	80 93 e8 00 	sts	0x00E8, r24
	Recv((u8*)d,len);
	ClearOUT();
	return len;
}

int SendInterfaces()
    173a:	81 2f       	mov	r24, r17
    173c:	79 81       	ldd	r23, Y+1	; 0x01
    173e:	97 2f       	mov	r25, r23
    1740:	0f 90       	pop	r0
    1742:	df 91       	pop	r29
    1744:	cf 91       	pop	r28
    1746:	1f 91       	pop	r17
    1748:	08 95       	ret

0000174a <_Z14SendInterfacesv>:
{
	int total = 0;
	u8 interfaces = 0;
    174a:	cf 93       	push	r28
    174c:	df 93       	push	r29
    174e:	1f 92       	push	r1
    1750:	cd b7       	in	r28, 0x3d	; 61
    1752:	de b7       	in	r29, 0x3e	; 62

#ifdef CDC_ENABLED
    1754:	19 82       	std	Y+1, r1	; 0x01
	total = CDC_GetInterface(&interfaces);
#endif

    1756:	ce 01       	movw	r24, r28
    1758:	01 96       	adiw	r24, 0x01	; 1
    175a:	0e 94 16 09 	call	0x122c	; 0x122c <_Z16CDC_GetInterfacePh>
#ifdef HID_ENABLED
	total += HID_GetInterface(&interfaces);
#endif

    175e:	ce 01       	movw	r24, r28
    1760:	01 96       	adiw	r24, 0x01	; 1
    1762:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <_Z16HID_GetInterfacePh>
	return interfaces;
}

    1766:	89 81       	ldd	r24, Y+1	; 0x01
//	Construct a dynamic configuration descriptor
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	0f 90       	pop	r0
    176c:	df 91       	pop	r29
    176e:	cf 91       	pop	r28
    1770:	08 95       	ret

00001772 <__vector_11>:

//	Endpoint 0 interrupt
ISR(USB_COM_vect)
{
    SetEP(0);
	if (!ReceivedSetupInt())
    1772:	1f 92       	push	r1
    1774:	0f 92       	push	r0
    1776:	0f b6       	in	r0, 0x3f	; 63
    1778:	0f 92       	push	r0
    177a:	11 24       	eor	r1, r1
    177c:	ef 92       	push	r14
    177e:	ff 92       	push	r15
    1780:	0f 93       	push	r16
    1782:	1f 93       	push	r17
    1784:	2f 93       	push	r18
    1786:	3f 93       	push	r19
    1788:	4f 93       	push	r20
    178a:	5f 93       	push	r21
    178c:	6f 93       	push	r22
    178e:	7f 93       	push	r23
    1790:	8f 93       	push	r24
    1792:	9f 93       	push	r25
    1794:	af 93       	push	r26
    1796:	bf 93       	push	r27
    1798:	ef 93       	push	r30
    179a:	ff 93       	push	r31
    179c:	cf 93       	push	r28
    179e:	df 93       	push	r29
    17a0:	cd b7       	in	r28, 0x3d	; 61
    17a2:	de b7       	in	r29, 0x3e	; 62
    17a4:	62 97       	sbiw	r28, 0x12	; 18
    17a6:	de bf       	out	0x3e, r29	; 62
    17a8:	cd bf       	out	0x3d, r28	; 61

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

    17aa:	10 92 e9 00 	sts	0x00E9, r1

static inline u8 ReceivedSetupInt()
{
	return UEINTX & (1<<RXSTPI);
}

    17ae:	80 91 e8 00 	lds	r24, 0x00E8
ISR(USB_COM_vect)
{
    SetEP(0);
	if (!ReceivedSetupInt())
		return;

    17b2:	83 ff       	sbrs	r24, 3
    17b4:	eb c0       	rjmp	.+470    	; 0x198c <__vector_11+0x21a>
	Setup setup;
	Recv((u8*)&setup,8);
	ClearSetupInt();

    17b6:	68 e0       	ldi	r22, 0x08	; 8
    17b8:	ce 01       	movw	r24, r28
    17ba:	0a 96       	adiw	r24, 0x0a	; 10
    17bc:	0e 94 21 0a 	call	0x1442	; 0x1442 <_Z4RecvPVhh>

static inline void ClearSetupInt()
{
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
}

    17c0:	82 ef       	ldi	r24, 0xF2	; 242
    17c2:	80 93 e8 00 	sts	0x00E8, r24
	Recv((u8*)&setup,8);
	ClearSetupInt();

	u8 requestType = setup.bmRequestType;
	if (requestType & REQUEST_DEVICETOHOST)
		WaitIN();
    17c6:	9a 85       	ldd	r25, Y+10	; 0x0a
	else
    17c8:	97 ff       	sbrs	r25, 7
    17ca:	05 c0       	rjmp	.+10     	; 0x17d6 <__vector_11+0x64>

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)))
		;
}
    17cc:	80 91 e8 00 	lds	r24, 0x00E8
    17d0:	80 ff       	sbrs	r24, 0
    17d2:	fc cf       	rjmp	.-8      	; 0x17cc <__vector_11+0x5a>
    17d4:	03 c0       	rjmp	.+6      	; 0x17dc <__vector_11+0x6a>

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
}

    17d6:	8e ef       	ldi	r24, 0xFE	; 254
    17d8:	80 93 e8 00 	sts	0x00E8, r24
		ClearIN();

    bool ok = true;
	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
	{
		//	Standard Requests
    17dc:	89 2f       	mov	r24, r25
    17de:	80 76       	andi	r24, 0x60	; 96
    17e0:	09 f0       	breq	.+2      	; 0x17e4 <__vector_11+0x72>
    17e2:	b9 c0       	rjmp	.+370    	; 0x1956 <__vector_11+0x1e4>
		u8 r = setup.bRequest;
		if (GET_STATUS == r)
		{
    17e4:	8b 85       	ldd	r24, Y+11	; 0x0b
			Send8(0);		// TODO
    17e6:	81 11       	cpse	r24, r1
    17e8:	05 c0       	rjmp	.+10     	; 0x17f4 <__vector_11+0x82>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

    17ea:	10 92 f1 00 	sts	0x00F1, r1
    17ee:	10 92 f1 00 	sts	0x00F1, r1
    17f2:	c5 c0       	rjmp	.+394    	; 0x197e <__vector_11+0x20c>
			Send8(0);		// TODO
			Send8(0);
		}
		else if (CLEAR_FEATURE == r)
		{
		}
    17f4:	28 2f       	mov	r18, r24
    17f6:	2d 7f       	andi	r18, 0xFD	; 253
    17f8:	21 30       	cpi	r18, 0x01	; 1
    17fa:	09 f4       	brne	.+2      	; 0x17fe <__vector_11+0x8c>
    17fc:	c0 c0       	rjmp	.+384    	; 0x197e <__vector_11+0x20c>
		else if (SET_FEATURE == r)
		{
		}
		else if (SET_ADDRESS == r)
		{
			WaitIN();
    17fe:	85 30       	cpi	r24, 0x05	; 5
    1800:	49 f4       	brne	.+18     	; 0x1814 <__vector_11+0xa2>

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)))
		;
}
    1802:	80 91 e8 00 	lds	r24, 0x00E8
    1806:	80 ff       	sbrs	r24, 0
    1808:	fc cf       	rjmp	.-8      	; 0x1802 <__vector_11+0x90>
		else if (SET_ADDRESS == r)
		{
			WaitIN();
			UDADDR = setup.wValueL | (1<<ADDEN);
		}
		else if (GET_DESCRIPTOR == r)
    180a:	8c 85       	ldd	r24, Y+12	; 0x0c
    180c:	80 68       	ori	r24, 0x80	; 128
    180e:	80 93 e3 00 	sts	0x00E3, r24
    1812:	b5 c0       	rjmp	.+362    	; 0x197e <__vector_11+0x20c>
		{
			ok = SendDescriptor(setup);
    1814:	86 30       	cpi	r24, 0x06	; 6
    1816:	09 f0       	breq	.+2      	; 0x181a <__vector_11+0xa8>
    1818:	76 c0       	rjmp	.+236    	; 0x1906 <__vector_11+0x194>
static
bool SendDescriptor(Setup& setup)
{
	u8 t = setup.wValueH;
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
		return SendConfiguration(setup.wLength);
    181a:	2d 85       	ldd	r18, Y+13	; 0x0d
    181c:	e8 88       	ldd	r14, Y+16	; 0x10
    181e:	f9 88       	ldd	r15, Y+17	; 0x11

    1820:	22 30       	cpi	r18, 0x02	; 2
    1822:	71 f5       	brne	.+92     	; 0x1880 <__vector_11+0x10e>
bool SendConfiguration(int maxlen)
{
	//	Count and measure interfaces
	InitControl(0);	
	int interfaces = SendInterfaces();
	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
    1824:	80 e0       	ldi	r24, 0x00	; 0
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	2a 8b       	std	Y+18, r18	; 0x12
    182a:	0e 94 4f 0b 	call	0x169e	; 0x169e <_Z11InitControli>

    182e:	0e 94 a5 0b 	call	0x174a	; 0x174a <_Z14SendInterfacesv>
	//	Now send them
    1832:	99 e0       	ldi	r25, 0x09	; 9
    1834:	8e 01       	movw	r16, r28
    1836:	0f 5f       	subi	r16, 0xFF	; 255
    1838:	1f 4f       	sbci	r17, 0xFF	; 255
    183a:	f8 01       	movw	r30, r16
    183c:	39 2f       	mov	r19, r25
    183e:	11 92       	st	Z+, r1
    1840:	3a 95       	dec	r19
    1842:	e9 f7       	brne	.-6      	; 0x183e <__vector_11+0xcc>
    1844:	99 83       	std	Y+1, r25	; 0x01
    1846:	2a 89       	ldd	r18, Y+18	; 0x12
    1848:	2a 83       	std	Y+2, r18	; 0x02
    184a:	91 e0       	ldi	r25, 0x01	; 1
    184c:	9e 83       	std	Y+6, r25	; 0x06
    184e:	90 e8       	ldi	r25, 0x80	; 128
    1850:	98 87       	std	Y+8, r25	; 0x08
    1852:	9a ef       	ldi	r25, 0xFA	; 250
    1854:	99 87       	std	Y+9, r25	; 0x09
    1856:	20 91 57 02 	lds	r18, 0x0257
    185a:	30 91 58 02 	lds	r19, 0x0258
    185e:	27 5f       	subi	r18, 0xF7	; 247
    1860:	3f 4f       	sbci	r19, 0xFF	; 255
    1862:	3c 83       	std	Y+4, r19	; 0x04
    1864:	2b 83       	std	Y+3, r18	; 0x03
    1866:	8d 83       	std	Y+5, r24	; 0x05
	InitControl(maxlen);
	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
	SendInterfaces();
    1868:	c7 01       	movw	r24, r14
    186a:	0e 94 4f 0b 	call	0x169e	; 0x169e <_Z11InitControli>
	return true;
    186e:	49 e0       	ldi	r20, 0x09	; 9
    1870:	50 e0       	ldi	r21, 0x00	; 0
    1872:	b8 01       	movw	r22, r16
    1874:	80 e0       	ldi	r24, 0x00	; 0
    1876:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <_Z15USB_SendControlhPKvi>
}
    187a:	0e 94 a5 0b 	call	0x174a	; 0x174a <_Z14SendInterfacesv>
    187e:	7f c0       	rjmp	.+254    	; 0x197e <__vector_11+0x20c>
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
		return SendConfiguration(setup.wLength);

	InitControl(setup.wLength);
#ifdef HID_ENABLED
	if (HID_REPORT_DESCRIPTOR_TYPE == t)
    1880:	c7 01       	movw	r24, r14
    1882:	2a 8b       	std	Y+18, r18	; 0x12
    1884:	0e 94 4f 0b 	call	0x169e	; 0x169e <_Z11InitControli>
		return HID_GetDescriptor(t);
#endif
    1888:	2a 89       	ldd	r18, Y+18	; 0x12
    188a:	22 32       	cpi	r18, 0x22	; 34
    188c:	41 f4       	brne	.+16     	; 0x189e <__vector_11+0x12c>

    188e:	82 e2       	ldi	r24, 0x22	; 34
    1890:	90 e0       	ldi	r25, 0x00	; 0
    1892:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <_Z17HID_GetDescriptori>
    1896:	89 2b       	or	r24, r25
    1898:	09 f0       	breq	.+2      	; 0x189c <__vector_11+0x12a>
    189a:	71 c0       	rjmp	.+226    	; 0x197e <__vector_11+0x20c>
    189c:	74 c0       	rjmp	.+232    	; 0x1986 <__vector_11+0x214>
	const u8* desc_addr = 0;
	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
	{
		if (setup.wLength == 8)
    189e:	21 30       	cpi	r18, 0x01	; 1
    18a0:	69 f4       	brne	.+26     	; 0x18bc <__vector_11+0x14a>
			_cdcComposite = 1;
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
    18a2:	88 89       	ldd	r24, Y+16	; 0x10
    18a4:	99 89       	ldd	r25, Y+17	; 0x11
    18a6:	08 97       	sbiw	r24, 0x08	; 8
    18a8:	11 f4       	brne	.+4      	; 0x18ae <__vector_11+0x13c>
	}
    18aa:	20 93 54 02 	sts	0x0254, r18
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
    18ae:	80 91 54 02 	lds	r24, 0x0254
    18b2:	81 11       	cpse	r24, r1
    18b4:	18 c0       	rjmp	.+48     	; 0x18e6 <__vector_11+0x174>
    18b6:	63 eb       	ldi	r22, 0xB3	; 179
    18b8:	71 e0       	ldi	r23, 0x01	; 1
    18ba:	1a c0       	rjmp	.+52     	; 0x18f0 <__vector_11+0x17e>
	{
		if (setup.wValueL == 0) {
    18bc:	23 30       	cpi	r18, 0x03	; 3
    18be:	09 f0       	breq	.+2      	; 0x18c2 <__vector_11+0x150>
    18c0:	62 c0       	rjmp	.+196    	; 0x1986 <__vector_11+0x214>
			desc_addr = (const u8*)&STRING_LANGUAGE;
		}
    18c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    18c4:	88 23       	and	r24, r24
    18c6:	91 f0       	breq	.+36     	; 0x18ec <__vector_11+0x17a>
		else if (setup.wValueL == IPRODUCT) {
			return USB_SendStringDescriptor(STRING_PRODUCT, strlen(USB_PRODUCT));
		}
    18c8:	82 30       	cpi	r24, 0x02	; 2
    18ca:	21 f4       	brne	.+8      	; 0x18d4 <__vector_11+0x162>
		else if (setup.wValueL == IMANUFACTURER) {
    18cc:	60 e1       	ldi	r22, 0x10	; 16
    18ce:	81 ed       	ldi	r24, 0xD1	; 209
    18d0:	91 e0       	ldi	r25, 0x01	; 1
    18d2:	06 c0       	rjmp	.+12     	; 0x18e0 <__vector_11+0x16e>
			return USB_SendStringDescriptor(STRING_MANUFACTURER, strlen(USB_MANUFACTURER));
		}
    18d4:	81 30       	cpi	r24, 0x01	; 1
    18d6:	09 f0       	breq	.+2      	; 0x18da <__vector_11+0x168>
    18d8:	56 c0       	rjmp	.+172    	; 0x1986 <__vector_11+0x214>
		else
    18da:	6b e0       	ldi	r22, 0x0B	; 11
    18dc:	85 ec       	ldi	r24, 0xC5	; 197
    18de:	91 e0       	ldi	r25, 0x01	; 1
    18e0:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <_ZL24USB_SendStringDescriptorPKhh>
    18e4:	4a c0       	rjmp	.+148    	; 0x197a <__vector_11+0x208>
	{
		if (setup.wLength == 8)
			_cdcComposite = 1;
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
    18e6:	61 ea       	ldi	r22, 0xA1	; 161
    18e8:	71 e0       	ldi	r23, 0x01	; 1
    18ea:	02 c0       	rjmp	.+4      	; 0x18f0 <__vector_11+0x17e>
	{
		if (setup.wValueL == 0) {
			desc_addr = (const u8*)&STRING_LANGUAGE;
		}
		else if (setup.wValueL == IPRODUCT) {
    18ec:	62 ee       	ldi	r22, 0xE2	; 226
    18ee:	71 e0       	ldi	r23, 0x01	; 1
			return false;
	}

	if (desc_addr == 0)
		return false;
	u8 desc_length = pgm_read_byte(desc_addr);
    18f0:	61 15       	cp	r22, r1
    18f2:	71 05       	cpc	r23, r1
    18f4:	09 f4       	brne	.+2      	; 0x18f8 <__vector_11+0x186>
    18f6:	47 c0       	rjmp	.+142    	; 0x1986 <__vector_11+0x214>

	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
    18f8:	fb 01       	movw	r30, r22
    18fa:	44 91       	lpm	r20, Z
	return true;
}
    18fc:	50 e0       	ldi	r21, 0x00	; 0
    18fe:	80 e8       	ldi	r24, 0x80	; 128
    1900:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <_Z15USB_SendControlhPKvi>
    1904:	3c c0       	rjmp	.+120    	; 0x197e <__vector_11+0x20c>
		{
			ok = SendDescriptor(setup);
		}
		else if (SET_DESCRIPTOR == r)
		{
			ok = false;
    1906:	87 30       	cpi	r24, 0x07	; 7
    1908:	09 f4       	brne	.+2      	; 0x190c <__vector_11+0x19a>
    190a:	3d c0       	rjmp	.+122    	; 0x1986 <__vector_11+0x214>
		}
		else if (GET_CONFIGURATION == r)
		{
			Send8(1);
    190c:	88 30       	cpi	r24, 0x08	; 8
    190e:	21 f4       	brne	.+8      	; 0x1918 <__vector_11+0x1a6>

static inline void Send8(u8 d)
{
	UEDATX = d;
}

    1910:	81 e0       	ldi	r24, 0x01	; 1
    1912:	80 93 f1 00 	sts	0x00F1, r24
    1916:	33 c0       	rjmp	.+102    	; 0x197e <__vector_11+0x20c>
		{
			Send8(1);
		}
		else if (SET_CONFIGURATION == r)
		{
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
    1918:	89 30       	cpi	r24, 0x09	; 9
    191a:	89 f5       	brne	.+98     	; 0x197e <__vector_11+0x20c>
			{
				InitEndpoints();
    191c:	93 70       	andi	r25, 0x03	; 3
    191e:	99 f5       	brne	.+102    	; 0x1986 <__vector_11+0x214>
    1920:	ed e9       	ldi	r30, 0x9D	; 157
    1922:	f1 e0       	ldi	r31, 0x01	; 1
    1924:	81 e0       	ldi	r24, 0x01	; 1
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
		UECONX = 1;
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
    1926:	21 e0       	ldi	r18, 0x01	; 1
	}
	UERST = 0x7E;	// And reset them
    1928:	96 e3       	ldi	r25, 0x36	; 54
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
		UECONX = 1;
		UECFG0X = pgm_read_byte(_initEndpoints+i);
    192a:	80 93 e9 00 	sts	0x00E9, r24
		UECFG1X = EP_DOUBLE_64;
    192e:	20 93 eb 00 	sts	0x00EB, r18
	}
    1932:	34 91       	lpm	r19, Z
    1934:	30 93 ec 00 	sts	0x00EC, r19
	UERST = 0x7E;	// And reset them
    1938:	90 93 ed 00 	sts	0x00ED, r25
static
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
    193c:	8f 5f       	subi	r24, 0xFF	; 255
    193e:	31 96       	adiw	r30, 0x01	; 1
    1940:	85 30       	cpi	r24, 0x05	; 5
    1942:	99 f7       	brne	.-26     	; 0x192a <__vector_11+0x1b8>
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
	}
	UERST = 0x7E;	// And reset them
	UERST = 0;
}
    1944:	8e e7       	ldi	r24, 0x7E	; 126
    1946:	80 93 ea 00 	sts	0x00EA, r24

    194a:	10 92 ea 00 	sts	0x00EA, r1
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
			{
				InitEndpoints();
				_usbConfiguration = setup.wValueL;
			} else
				ok = false;
    194e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1950:	80 93 59 02 	sts	0x0259, r24
    1954:	14 c0       	rjmp	.+40     	; 0x197e <__vector_11+0x20c>
	}
	else
	{
		InitControl(setup.wLength);		//	Max length of transfer
		ok = ClassInterfaceRequest(setup);
	}
    1956:	88 89       	ldd	r24, Y+16	; 0x10
    1958:	99 89       	ldd	r25, Y+17	; 0x11
    195a:	0e 94 4f 0b 	call	0x169e	; 0x169e <_Z11InitControli>
static
bool ClassInterfaceRequest(Setup& setup)
{
	u8 i = setup.wIndex;

#ifdef CDC_ENABLED
    195e:	8e 85       	ldd	r24, Y+14	; 0x0e
	if (CDC_ACM_INTERFACE == i)
		return CDC_Setup(setup);
#endif
    1960:	81 11       	cpse	r24, r1
    1962:	05 c0       	rjmp	.+10     	; 0x196e <__vector_11+0x1fc>

    1964:	ce 01       	movw	r24, r28
    1966:	0a 96       	adiw	r24, 0x0a	; 10
    1968:	0e 94 21 09 	call	0x1242	; 0x1242 <_Z9CDC_SetupR5Setup>
    196c:	06 c0       	rjmp	.+12     	; 0x197a <__vector_11+0x208>
#ifdef HID_ENABLED
	if (HID_INTERFACE == i)
		return HID_Setup(setup);
#endif
    196e:	82 30       	cpi	r24, 0x02	; 2
    1970:	51 f4       	brne	.+20     	; 0x1986 <__vector_11+0x214>
	return false;
    1972:	ce 01       	movw	r24, r28
    1974:	0a 96       	adiw	r24, 0x0a	; 10
    1976:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <_Z9HID_SetupR5Setup>
		ok = ClassInterfaceRequest(setup);
	}

	if (ok)
		ClearIN();
	else
    197a:	88 23       	and	r24, r24
    197c:	21 f0       	breq	.+8      	; 0x1986 <__vector_11+0x214>

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
}

    197e:	8e ef       	ldi	r24, 0xFE	; 254
    1980:	80 93 e8 00 	sts	0x00E8, r24
    1984:	03 c0       	rjmp	.+6      	; 0x198c <__vector_11+0x21a>

static inline void Stall()
{
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

    1986:	81 e2       	ldi	r24, 0x21	; 33
    1988:	80 93 eb 00 	sts	0x00EB, r24
	{
		Stall();
	}
}

void USB_Flush(u8 ep)
    198c:	62 96       	adiw	r28, 0x12	; 18
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	f8 94       	cli
    1992:	de bf       	out	0x3e, r29	; 62
    1994:	0f be       	out	0x3f, r0	; 63
    1996:	cd bf       	out	0x3d, r28	; 61
    1998:	df 91       	pop	r29
    199a:	cf 91       	pop	r28
    199c:	ff 91       	pop	r31
    199e:	ef 91       	pop	r30
    19a0:	bf 91       	pop	r27
    19a2:	af 91       	pop	r26
    19a4:	9f 91       	pop	r25
    19a6:	8f 91       	pop	r24
    19a8:	7f 91       	pop	r23
    19aa:	6f 91       	pop	r22
    19ac:	5f 91       	pop	r21
    19ae:	4f 91       	pop	r20
    19b0:	3f 91       	pop	r19
    19b2:	2f 91       	pop	r18
    19b4:	1f 91       	pop	r17
    19b6:	0f 91       	pop	r16
    19b8:	ff 90       	pop	r15
    19ba:	ef 90       	pop	r14
    19bc:	0f 90       	pop	r0
    19be:	0f be       	out	0x3f, r0	; 63
    19c0:	0f 90       	pop	r0
    19c2:	1f 90       	pop	r1
    19c4:	18 95       	reti

000019c6 <_Z9USB_Flushh>:

static inline void SetEP(u8 ep)
{
	UENUM = ep;
}

    19c6:	80 93 e9 00 	sts	0x00E9, r24
static inline u8 FifoByteCount()
{
	return UEBCLX;
}

    19ca:	80 91 f2 00 	lds	r24, 0x00F2
void USB_Flush(u8 ep)
{
	SetEP(ep);
	if (FifoByteCount())
		ReleaseTX();
}
    19ce:	88 23       	and	r24, r24
    19d0:	19 f0       	breq	.+6      	; 0x19d8 <_Z9USB_Flushh+0x12>

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
}

    19d2:	8a e3       	ldi	r24, 0x3A	; 58
    19d4:	80 93 e8 00 	sts	0x00E8, r24
    19d8:	08 95       	ret

000019da <__vector_10>:

//	General interrupt
ISR(USB_GEN_vect)
{
	u8 udint = UDINT;
	UDINT = 0;
    19da:	1f 92       	push	r1
    19dc:	0f 92       	push	r0
    19de:	0f b6       	in	r0, 0x3f	; 63
    19e0:	0f 92       	push	r0
    19e2:	11 24       	eor	r1, r1
    19e4:	2f 93       	push	r18
    19e6:	3f 93       	push	r19
    19e8:	4f 93       	push	r20
    19ea:	5f 93       	push	r21
    19ec:	6f 93       	push	r22
    19ee:	7f 93       	push	r23
    19f0:	8f 93       	push	r24
    19f2:	9f 93       	push	r25
    19f4:	af 93       	push	r26
    19f6:	bf 93       	push	r27
    19f8:	ef 93       	push	r30
    19fa:	ff 93       	push	r31

    19fc:	80 91 e1 00 	lds	r24, 0x00E1
	//	End of Reset
    1a00:	10 92 e1 00 	sts	0x00E1, r1
	if (udint & (1<<EORSTI))
	{
		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
    1a04:	83 ff       	sbrs	r24, 3
    1a06:	0f c0       	rjmp	.+30     	; 0x1a26 <__vector_10+0x4c>
static
void InitEP(u8 index, u8 type, u8 size)
{
	UENUM = index;
	UECONX = 1;
	UECFG0X = type;
    1a08:	10 92 e9 00 	sts	0x00E9, r1
	UECFG1X = size;
    1a0c:	91 e0       	ldi	r25, 0x01	; 1
    1a0e:	90 93 eb 00 	sts	0x00EB, r25
}
    1a12:	10 92 ec 00 	sts	0x00EC, r1

    1a16:	92 e3       	ldi	r25, 0x32	; 50
    1a18:	90 93 ed 00 	sts	0x00ED, r25
	if (udint & (1<<EORSTI))
	{
		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
		_usbConfiguration = 0;			// not configured yet
		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
	}
    1a1c:	10 92 59 02 	sts	0x0259, r1

    1a20:	98 e0       	ldi	r25, 0x08	; 8
    1a22:	90 93 f0 00 	sts	0x00F0, r25
	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
	if (udint & (1<<SOFI))
	{
#ifdef CDC_ENABLED
    1a26:	82 ff       	sbrs	r24, 2
    1a28:	1d c0       	rjmp	.+58     	; 0x1a64 <__vector_10+0x8a>
		USB_Flush(CDC_TX);				// Send a tx frame if found
#endif
		
    1a2a:	83 e0       	ldi	r24, 0x03	; 3
    1a2c:	0e 94 e3 0c 	call	0x19c6	; 0x19c6 <_Z9USB_Flushh>
		// check whether the one-shot period has elapsed.  if so, turn off the LED
		if (TxLEDPulse && !(--TxLEDPulse))
			TXLED0;
		if (RxLEDPulse && !(--RxLEDPulse))
    1a30:	80 91 5b 02 	lds	r24, 0x025B
    1a34:	88 23       	and	r24, r24
    1a36:	39 f0       	breq	.+14     	; 0x1a46 <__vector_10+0x6c>
    1a38:	80 91 5b 02 	lds	r24, 0x025B
    1a3c:	81 50       	subi	r24, 0x01	; 1
    1a3e:	80 93 5b 02 	sts	0x025B, r24
    1a42:	88 23       	and	r24, r24
    1a44:	69 f0       	breq	.+26     	; 0x1a60 <__vector_10+0x86>
			RXLED0;
	}
    1a46:	80 91 5a 02 	lds	r24, 0x025A
    1a4a:	88 23       	and	r24, r24
    1a4c:	59 f0       	breq	.+22     	; 0x1a64 <__vector_10+0x8a>
    1a4e:	80 91 5a 02 	lds	r24, 0x025A
    1a52:	81 50       	subi	r24, 0x01	; 1
    1a54:	80 93 5a 02 	sts	0x025A, r24
    1a58:	81 11       	cpse	r24, r1
    1a5a:	04 c0       	rjmp	.+8      	; 0x1a64 <__vector_10+0x8a>
}
    1a5c:	28 9a       	sbi	0x05, 0	; 5
    1a5e:	02 c0       	rjmp	.+4      	; 0x1a64 <__vector_10+0x8a>
		
		// check whether the one-shot period has elapsed.  if so, turn off the LED
		if (TxLEDPulse && !(--TxLEDPulse))
			TXLED0;
		if (RxLEDPulse && !(--RxLEDPulse))
			RXLED0;
    1a60:	5d 9a       	sbi	0x0b, 5	; 11
    1a62:	f1 cf       	rjmp	.-30     	; 0x1a46 <__vector_10+0x6c>
	}
}

//	VBUS or counting frames
    1a64:	ff 91       	pop	r31
    1a66:	ef 91       	pop	r30
    1a68:	bf 91       	pop	r27
    1a6a:	af 91       	pop	r26
    1a6c:	9f 91       	pop	r25
    1a6e:	8f 91       	pop	r24
    1a70:	7f 91       	pop	r23
    1a72:	6f 91       	pop	r22
    1a74:	5f 91       	pop	r21
    1a76:	4f 91       	pop	r20
    1a78:	3f 91       	pop	r19
    1a7a:	2f 91       	pop	r18
    1a7c:	0f 90       	pop	r0
    1a7e:	0f be       	out	0x3f, r0	; 63
    1a80:	0f 90       	pop	r0
    1a82:	1f 90       	pop	r1
    1a84:	18 95       	reti

00001a86 <_ZN10USBDevice_6attachEv>:

void USBDevice_::attach()
{
	_usbConfiguration = 0;
	UHWCON = 0x01;						// power internal reg
	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
    1a86:	10 92 59 02 	sts	0x0259, r1
#if F_CPU == 16000000UL
    1a8a:	81 e0       	ldi	r24, 0x01	; 1
    1a8c:	80 93 d7 00 	sts	0x00D7, r24
	PLLCSR = 0x12;						// Need 16 MHz xtal
    1a90:	80 ea       	ldi	r24, 0xA0	; 160
    1a92:	80 93 d8 00 	sts	0x00D8, r24
#elif F_CPU == 8000000UL
	PLLCSR = 0x02;						// Need 8 MHz xtal
    1a96:	82 e1       	ldi	r24, 0x12	; 18
    1a98:	89 bd       	out	0x29, r24	; 41
#endif
	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
		;

    1a9a:	09 b4       	in	r0, 0x29	; 41
    1a9c:	00 fe       	sbrs	r0, 0
    1a9e:	fd cf       	rjmp	.-6      	; 0x1a9a <_ZN10USBDevice_6attachEv+0x14>
	// Some tests on specific versions of macosx (10.7.3), reported some
	// strange behaviuors when the board is reset using the serial
	// port touch at 1200 bps. This delay fixes this behaviour.
	delay(1);

	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
    1aa0:	61 e0       	ldi	r22, 0x01	; 1
    1aa2:	70 e0       	ldi	r23, 0x00	; 0
    1aa4:	80 e0       	ldi	r24, 0x00	; 0
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	0e 94 5e 07 	call	0xebc	; 0xebc <delay>
	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
	UDCON = 0;							// enable attach resistor
    1aac:	80 e9       	ldi	r24, 0x90	; 144
    1aae:	80 93 d8 00 	sts	0x00D8, r24
	
    1ab2:	8c e0       	ldi	r24, 0x0C	; 12
    1ab4:	80 93 e2 00 	sts	0x00E2, r24
	TX_RX_LED_INIT;
    1ab8:	10 92 e0 00 	sts	0x00E0, r1
}

    1abc:	55 9a       	sbi	0x0a, 5	; 10
    1abe:	20 9a       	sbi	0x04, 0	; 4
    1ac0:	08 95       	ret

00001ac2 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    1ac2:	08 95       	ret

00001ac4 <_ZN9Keyboard_5writeEh>:
}

size_t Keyboard_::write(uint8_t c)
{	
	uint8_t p = press(c);  // Keydown
	release(c);            // Keyup
    1ac4:	ff 92       	push	r15
    1ac6:	0f 93       	push	r16
    1ac8:	1f 93       	push	r17
    1aca:	cf 93       	push	r28
    1acc:	df 93       	push	r29
    1ace:	ec 01       	movw	r28, r24
    1ad0:	f6 2e       	mov	r15, r22
	return p;              // just return the result of press() since release() almost always returns 1
    1ad2:	e8 81       	ld	r30, Y
    1ad4:	f9 81       	ldd	r31, Y+1	; 0x01
    1ad6:	04 80       	ldd	r0, Z+4	; 0x04
    1ad8:	f5 81       	ldd	r31, Z+5	; 0x05
    1ada:	e0 2d       	mov	r30, r0
    1adc:	09 95       	icall
    1ade:	8c 01       	movw	r16, r24
}
    1ae0:	e8 81       	ld	r30, Y
    1ae2:	f9 81       	ldd	r31, Y+1	; 0x01
    1ae4:	06 80       	ldd	r0, Z+6	; 0x06
    1ae6:	f7 81       	ldd	r31, Z+7	; 0x07
    1ae8:	e0 2d       	mov	r30, r0
    1aea:	6f 2d       	mov	r22, r15
    1aec:	ce 01       	movw	r24, r28
    1aee:	09 95       	icall

#endif
    1af0:	c8 01       	movw	r24, r16
    1af2:	99 27       	eor	r25, r25
    1af4:	df 91       	pop	r29
    1af6:	cf 91       	pop	r28
    1af8:	1f 91       	pop	r17
    1afa:	0f 91       	pop	r16
    1afc:	ff 90       	pop	r15
    1afe:	08 95       	ret

00001b00 <_Z16HID_GetInterfacePh>:

int WEAK HID_GetInterface(u8* interfaceNum)
{
	interfaceNum[0] += 1;	// uses 1
	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
}
    1b00:	fc 01       	movw	r30, r24
    1b02:	20 81       	ld	r18, Z
    1b04:	2f 5f       	subi	r18, 0xFF	; 255
    1b06:	20 83       	st	Z, r18

    1b08:	49 e1       	ldi	r20, 0x19	; 25
    1b0a:	50 e0       	ldi	r21, 0x00	; 0
    1b0c:	66 e6       	ldi	r22, 0x66	; 102
    1b0e:	72 e0       	ldi	r23, 0x02	; 2
    1b10:	80 e8       	ldi	r24, 0x80	; 128
    1b12:	0c 94 5a 0b 	jmp	0x16b4	; 0x16b4 <_Z15USB_SendControlhPKvi>

00001b16 <_Z17HID_GetDescriptori>:
int WEAK HID_GetDescriptor(int /* i */)
{
	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
}

    1b16:	45 e6       	ldi	r20, 0x65	; 101
    1b18:	50 e0       	ldi	r21, 0x00	; 0
    1b1a:	6f e7       	ldi	r22, 0x7F	; 127
    1b1c:	72 e0       	ldi	r23, 0x02	; 2
    1b1e:	80 e8       	ldi	r24, 0x80	; 128
    1b20:	0c 94 5a 0b 	jmp	0x16b4	; 0x16b4 <_Z15USB_SendControlhPKvi>

00001b24 <_Z14HID_SendReporthPKvi>:
void WEAK HID_SendReport(u8 id, const void* data, int len)
{
	USB_Send(HID_TX, &id, 1);
	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
    1b24:	ef 92       	push	r14
    1b26:	ff 92       	push	r15
    1b28:	0f 93       	push	r16
    1b2a:	1f 93       	push	r17
    1b2c:	cf 93       	push	r28
    1b2e:	df 93       	push	r29
    1b30:	1f 92       	push	r1
    1b32:	cd b7       	in	r28, 0x3d	; 61
    1b34:	de b7       	in	r29, 0x3e	; 62
    1b36:	89 83       	std	Y+1, r24	; 0x01
    1b38:	8b 01       	movw	r16, r22
    1b3a:	7a 01       	movw	r14, r20
}
    1b3c:	41 e0       	ldi	r20, 0x01	; 1
    1b3e:	50 e0       	ldi	r21, 0x00	; 0
    1b40:	be 01       	movw	r22, r28
    1b42:	6f 5f       	subi	r22, 0xFF	; 255
    1b44:	7f 4f       	sbci	r23, 0xFF	; 255
    1b46:	84 e0       	ldi	r24, 0x04	; 4
    1b48:	0e 94 bf 0a 	call	0x157e	; 0x157e <_Z8USB_SendhPKvi>

    1b4c:	a7 01       	movw	r20, r14
    1b4e:	b8 01       	movw	r22, r16
    1b50:	84 e4       	ldi	r24, 0x44	; 68
    1b52:	0e 94 bf 0a 	call	0x157e	; 0x157e <_Z8USB_SendhPKvi>
bool WEAK HID_Setup(Setup& setup)
    1b56:	0f 90       	pop	r0
    1b58:	df 91       	pop	r29
    1b5a:	cf 91       	pop	r28
    1b5c:	1f 91       	pop	r17
    1b5e:	0f 91       	pop	r16
    1b60:	ff 90       	pop	r15
    1b62:	ef 90       	pop	r14
    1b64:	08 95       	ret

00001b66 <_Z9HID_SetupR5Setup>:
{
	u8 r = setup.bRequest;
	u8 requestType = setup.bmRequestType;
    1b66:	fc 01       	movw	r30, r24
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
    1b68:	91 81       	ldd	r25, Z+1	; 0x01
	{
    1b6a:	80 81       	ld	r24, Z
		if (HID_GET_REPORT == r)
    1b6c:	81 3a       	cpi	r24, 0xA1	; 161
    1b6e:	31 f4       	brne	.+12     	; 0x1b7c <_Z9HID_SetupR5Setup+0x16>
		{
			//HID_GetReport();
			return true;
		}
		if (HID_GET_PROTOCOL == r)
    1b70:	81 e0       	ldi	r24, 0x01	; 1
	u8 requestType = setup.bmRequestType;
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
	{
		if (HID_GET_REPORT == r)
		{
			//HID_GetReport();
    1b72:	91 30       	cpi	r25, 0x01	; 1
    1b74:	91 f0       	breq	.+36     	; 0x1b9a <_Z9HID_SetupR5Setup+0x34>
			return true;
		}
		if (HID_GET_PROTOCOL == r)
		{
			//Send8(_hid_protocol);	// TODO
    1b76:	93 30       	cpi	r25, 0x03	; 3
    1b78:	89 f4       	brne	.+34     	; 0x1b9c <_Z9HID_SetupR5Setup+0x36>
    1b7a:	11 c0       	rjmp	.+34     	; 0x1b9e <_Z9HID_SetupR5Setup+0x38>
		}
	}
	
	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
	{
		if (HID_SET_PROTOCOL == r)
    1b7c:	81 32       	cpi	r24, 0x21	; 33
    1b7e:	71 f4       	brne	.+28     	; 0x1b9c <_Z9HID_SetupR5Setup+0x36>
		{
			_hid_protocol = setup.wValueL;
    1b80:	9b 30       	cpi	r25, 0x0B	; 11
    1b82:	21 f4       	brne	.+8      	; 0x1b8c <_Z9HID_SetupR5Setup+0x26>
			return true;
		}
    1b84:	82 81       	ldd	r24, Z+2	; 0x02
    1b86:	80 93 0a 01 	sts	0x010A, r24
    1b8a:	05 c0       	rjmp	.+10     	; 0x1b96 <_Z9HID_SetupR5Setup+0x30>

		if (HID_SET_IDLE == r)
		{
			_hid_idle = setup.wValueL;
    1b8c:	9a 30       	cpi	r25, 0x0A	; 10
    1b8e:	31 f4       	brne	.+12     	; 0x1b9c <_Z9HID_SetupR5Setup+0x36>
			return true;
		}
    1b90:	82 81       	ldd	r24, Z+2	; 0x02
    1b92:	80 93 09 01 	sts	0x0109, r24
	}
    1b96:	81 e0       	ldi	r24, 0x01	; 1
    1b98:	08 95       	ret
    1b9a:	08 95       	ret
	return false;
}

    1b9c:	80 e0       	ldi	r24, 0x00	; 0
//================================================================================
    1b9e:	08 95       	ret

00001ba0 <_ZN9Keyboard_10sendReportEP9KeyReport>:

void Keyboard_::sendReport(KeyReport* keys)
{
	HID_SendReport(2,keys,sizeof(KeyReport));
}

    1ba0:	48 e0       	ldi	r20, 0x08	; 8
    1ba2:	50 e0       	ldi	r21, 0x00	; 0
    1ba4:	82 e0       	ldi	r24, 0x02	; 2
    1ba6:	0c 94 92 0d 	jmp	0x1b24	; 0x1b24 <_Z14HID_SendReporthPKvi>

00001baa <_ZN9Keyboard_5pressEh>:
// USB HID works, the host acts like the key remains pressed until we 
// call release(), releaseAll(), or otherwise clear the report and resend.
size_t Keyboard_::press(uint8_t k) 
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
    1baa:	cf 93       	push	r28
    1bac:	df 93       	push	r29
    1bae:	dc 01       	movw	r26, r24
		k = k - 136;
	} else if (k >= 128) {	// it's a modifier key
    1bb0:	68 38       	cpi	r22, 0x88	; 136
    1bb2:	18 f0       	brcs	.+6      	; 0x1bba <_ZN9Keyboard_5pressEh+0x10>
		_keyReport.modifiers |= (1<<(k-128));
    1bb4:	e8 e7       	ldi	r30, 0x78	; 120
    1bb6:	e6 0f       	add	r30, r22
    1bb8:	25 c0       	rjmp	.+74     	; 0x1c04 <_ZN9Keyboard_5pressEh+0x5a>
    1bba:	e6 2f       	mov	r30, r22
    1bbc:	f0 e0       	ldi	r31, 0x00	; 0
		k = 0;
    1bbe:	67 ff       	sbrs	r22, 7
    1bc0:	11 c0       	rjmp	.+34     	; 0x1be4 <_ZN9Keyboard_5pressEh+0x3a>
	} else {				// it's a printing key
    1bc2:	e0 58       	subi	r30, 0x80	; 128
    1bc4:	f1 09       	sbc	r31, r1
    1bc6:	81 e0       	ldi	r24, 0x01	; 1
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	01 c0       	rjmp	.+2      	; 0x1bce <_ZN9Keyboard_5pressEh+0x24>
    1bcc:	88 0f       	add	r24, r24
    1bce:	ea 95       	dec	r30
    1bd0:	ea f7       	brpl	.-6      	; 0x1bcc <_ZN9Keyboard_5pressEh+0x22>
    1bd2:	14 96       	adiw	r26, 0x04	; 4
    1bd4:	9c 91       	ld	r25, X
    1bd6:	14 97       	sbiw	r26, 0x04	; 4
    1bd8:	98 2b       	or	r25, r24
    1bda:	14 96       	adiw	r26, 0x04	; 4
    1bdc:	9c 93       	st	X, r25
    1bde:	14 97       	sbiw	r26, 0x04	; 4
		k = pgm_read_byte(_asciimap + k);
    1be0:	e0 e0       	ldi	r30, 0x00	; 0
    1be2:	10 c0       	rjmp	.+32     	; 0x1c04 <_ZN9Keyboard_5pressEh+0x5a>
		if (!k) {
			setWriteError();
    1be4:	ea 51       	subi	r30, 0x1A	; 26
    1be6:	fe 4f       	sbci	r31, 0xFE	; 254
    1be8:	e4 91       	lpm	r30, Z
			return 0;
    1bea:	ee 23       	and	r30, r30
    1bec:	09 f4       	brne	.+2      	; 0x1bf0 <_ZN9Keyboard_5pressEh+0x46>
    1bee:	40 c0       	rjmp	.+128    	; 0x1c70 <_ZN9Keyboard_5pressEh+0xc6>
		}
		if (k & 0x80) {						// it's a capital letter or other character reached with shift
			_keyReport.modifiers |= 0x02;	// the left shift modifier
			k &= 0x7F;
    1bf0:	e7 ff       	sbrs	r30, 7
    1bf2:	08 c0       	rjmp	.+16     	; 0x1c04 <_ZN9Keyboard_5pressEh+0x5a>
		}
    1bf4:	14 96       	adiw	r26, 0x04	; 4
    1bf6:	8c 91       	ld	r24, X
    1bf8:	14 97       	sbiw	r26, 0x04	; 4
    1bfa:	82 60       	ori	r24, 0x02	; 2
    1bfc:	14 96       	adiw	r26, 0x04	; 4
    1bfe:	8c 93       	st	X, r24
    1c00:	14 97       	sbiw	r26, 0x04	; 4
	}
    1c02:	ef 77       	andi	r30, 0x7F	; 127
	
	// Add k to the key report only if it's not already present
	// and if there is an empty slot.
	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
    1c04:	16 96       	adiw	r26, 0x06	; 6
    1c06:	8c 91       	ld	r24, X
    1c08:	16 97       	sbiw	r26, 0x06	; 6
    1c0a:	8e 17       	cp	r24, r30
    1c0c:	41 f1       	breq	.+80     	; 0x1c5e <_ZN9Keyboard_5pressEh+0xb4>
    1c0e:	17 96       	adiw	r26, 0x07	; 7
    1c10:	8c 91       	ld	r24, X
    1c12:	17 97       	sbiw	r26, 0x07	; 7
    1c14:	8e 17       	cp	r24, r30
    1c16:	19 f1       	breq	.+70     	; 0x1c5e <_ZN9Keyboard_5pressEh+0xb4>
    1c18:	18 96       	adiw	r26, 0x08	; 8
    1c1a:	8c 91       	ld	r24, X
    1c1c:	18 97       	sbiw	r26, 0x08	; 8
    1c1e:	8e 17       	cp	r24, r30
    1c20:	f1 f0       	breq	.+60     	; 0x1c5e <_ZN9Keyboard_5pressEh+0xb4>
		
    1c22:	19 96       	adiw	r26, 0x09	; 9
    1c24:	8c 91       	ld	r24, X
    1c26:	19 97       	sbiw	r26, 0x09	; 9
    1c28:	8e 17       	cp	r24, r30
    1c2a:	c9 f0       	breq	.+50     	; 0x1c5e <_ZN9Keyboard_5pressEh+0xb4>
    1c2c:	1a 96       	adiw	r26, 0x0a	; 10
    1c2e:	8c 91       	ld	r24, X
    1c30:	1a 97       	sbiw	r26, 0x0a	; 10
    1c32:	8e 17       	cp	r24, r30
    1c34:	a1 f0       	breq	.+40     	; 0x1c5e <_ZN9Keyboard_5pressEh+0xb4>
		for (i=0; i<6; i++) {
    1c36:	1b 96       	adiw	r26, 0x0b	; 11
    1c38:	8c 91       	ld	r24, X
    1c3a:	1b 97       	sbiw	r26, 0x0b	; 11
    1c3c:	8e 17       	cp	r24, r30
    1c3e:	79 f0       	breq	.+30     	; 0x1c5e <_ZN9Keyboard_5pressEh+0xb4>
    1c40:	80 e0       	ldi	r24, 0x00	; 0
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	ed 01       	movw	r28, r26
    1c46:	c8 0f       	add	r28, r24
    1c48:	d9 1f       	adc	r29, r25
			if (_keyReport.keys[i] == 0x00) {
				_keyReport.keys[i] = k;
				break;
    1c4a:	2e 81       	ldd	r18, Y+6	; 0x06
    1c4c:	21 11       	cpse	r18, r1
    1c4e:	02 c0       	rjmp	.+4      	; 0x1c54 <_ZN9Keyboard_5pressEh+0xaa>
			}
    1c50:	ee 83       	std	Y+6, r30	; 0x06
    1c52:	05 c0       	rjmp	.+10     	; 0x1c5e <_ZN9Keyboard_5pressEh+0xb4>
    1c54:	01 96       	adiw	r24, 0x01	; 1
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
		
		for (i=0; i<6; i++) {
			if (_keyReport.keys[i] == 0x00) {
				_keyReport.keys[i] = k;
    1c56:	86 30       	cpi	r24, 0x06	; 6
    1c58:	91 05       	cpc	r25, r1
    1c5a:	a1 f7       	brne	.-24     	; 0x1c44 <_ZN9Keyboard_5pressEh+0x9a>
    1c5c:	09 c0       	rjmp	.+18     	; 0x1c70 <_ZN9Keyboard_5pressEh+0xc6>
			return 0;
		}	
	}
	sendReport(&_keyReport);
	return 1;
}
    1c5e:	bd 01       	movw	r22, r26
    1c60:	6c 5f       	subi	r22, 0xFC	; 252
    1c62:	7f 4f       	sbci	r23, 0xFF	; 255
    1c64:	cd 01       	movw	r24, r26
    1c66:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <_ZN9Keyboard_10sendReportEP9KeyReport>

    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	08 c0       	rjmp	.+16     	; 0x1c80 <_ZN9Keyboard_5pressEh+0xd6>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    1c70:	81 e0       	ldi	r24, 0x01	; 1
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	13 96       	adiw	r26, 0x03	; 3
    1c76:	9c 93       	st	X, r25
    1c78:	8e 93       	st	-X, r24
    1c7a:	12 97       	sbiw	r26, 0x02	; 2
		}
		if (i == 6) {
			setWriteError();
			return 0;
		}	
	}
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
	sendReport(&_keyReport);
	return 1;
}

// release() takes the specified key out of the persistent key report and
    1c80:	df 91       	pop	r29
    1c82:	cf 91       	pop	r28
    1c84:	08 95       	ret

00001c86 <_ZN9Keyboard_7releaseEh>:
size_t Keyboard_::release(uint8_t k) 
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
		k = k - 136;
	} else if (k >= 128) {	// it's a modifier key
    1c86:	68 38       	cpi	r22, 0x88	; 136
    1c88:	18 f0       	brcs	.+6      	; 0x1c90 <_ZN9Keyboard_7releaseEh+0xa>
		_keyReport.modifiers &= ~(1<<(k-128));
    1c8a:	e8 e7       	ldi	r30, 0x78	; 120
    1c8c:	e6 0f       	add	r30, r22
    1c8e:	25 c0       	rjmp	.+74     	; 0x1cda <_ZN9Keyboard_7releaseEh+0x54>
    1c90:	e6 2f       	mov	r30, r22
    1c92:	f0 e0       	ldi	r31, 0x00	; 0
		k = 0;
    1c94:	67 ff       	sbrs	r22, 7
    1c96:	12 c0       	rjmp	.+36     	; 0x1cbc <_ZN9Keyboard_7releaseEh+0x36>
	} else {				// it's a printing key
    1c98:	e0 58       	subi	r30, 0x80	; 128
    1c9a:	f1 09       	sbc	r31, r1
    1c9c:	21 e0       	ldi	r18, 0x01	; 1
    1c9e:	30 e0       	ldi	r19, 0x00	; 0
    1ca0:	01 c0       	rjmp	.+2      	; 0x1ca4 <_ZN9Keyboard_7releaseEh+0x1e>
    1ca2:	22 0f       	add	r18, r18
    1ca4:	ea 95       	dec	r30
    1ca6:	ea f7       	brpl	.-6      	; 0x1ca2 <_ZN9Keyboard_7releaseEh+0x1c>
    1ca8:	20 95       	com	r18
    1caa:	dc 01       	movw	r26, r24
    1cac:	14 96       	adiw	r26, 0x04	; 4
    1cae:	3c 91       	ld	r19, X
    1cb0:	14 97       	sbiw	r26, 0x04	; 4
    1cb2:	32 23       	and	r19, r18
    1cb4:	14 96       	adiw	r26, 0x04	; 4
    1cb6:	3c 93       	st	X, r19
		k = pgm_read_byte(_asciimap + k);
    1cb8:	e0 e0       	ldi	r30, 0x00	; 0
    1cba:	0f c0       	rjmp	.+30     	; 0x1cda <_ZN9Keyboard_7releaseEh+0x54>
		if (!k) {
			return 0;
    1cbc:	ea 51       	subi	r30, 0x1A	; 26
    1cbe:	fe 4f       	sbci	r31, 0xFE	; 254
    1cc0:	e4 91       	lpm	r30, Z
		}
    1cc2:	ee 23       	and	r30, r30
    1cc4:	29 f1       	breq	.+74     	; 0x1d10 <_ZN9Keyboard_7releaseEh+0x8a>
		if (k & 0x80) {							// it's a capital letter or other character reached with shift
			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
			k &= 0x7F;
    1cc6:	e7 ff       	sbrs	r30, 7
    1cc8:	08 c0       	rjmp	.+16     	; 0x1cda <_ZN9Keyboard_7releaseEh+0x54>
		}
    1cca:	dc 01       	movw	r26, r24
    1ccc:	14 96       	adiw	r26, 0x04	; 4
    1cce:	2c 91       	ld	r18, X
    1cd0:	14 97       	sbiw	r26, 0x04	; 4
    1cd2:	2d 7f       	andi	r18, 0xFD	; 253
    1cd4:	14 96       	adiw	r26, 0x04	; 4
    1cd6:	2c 93       	st	X, r18
	}
    1cd8:	ef 77       	andi	r30, 0x7F	; 127
		k = k - 136;
	} else if (k >= 128) {	// it's a modifier key
		_keyReport.modifiers &= ~(1<<(k-128));
		k = 0;
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
    1cda:	20 e0       	ldi	r18, 0x00	; 0
    1cdc:	30 e0       	ldi	r19, 0x00	; 0
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
		if (0 != k && _keyReport.keys[i] == k) {
			_keyReport.keys[i] = 0x00;
		}
    1cde:	ee 23       	and	r30, r30
    1ce0:	51 f0       	breq	.+20     	; 0x1cf6 <_ZN9Keyboard_7releaseEh+0x70>
    1ce2:	dc 01       	movw	r26, r24
    1ce4:	a2 0f       	add	r26, r18
    1ce6:	b3 1f       	adc	r27, r19
    1ce8:	16 96       	adiw	r26, 0x06	; 6
    1cea:	4c 91       	ld	r20, X
    1cec:	16 97       	sbiw	r26, 0x06	; 6
    1cee:	4e 13       	cpse	r20, r30
    1cf0:	02 c0       	rjmp	.+4      	; 0x1cf6 <_ZN9Keyboard_7releaseEh+0x70>
	}
    1cf2:	16 96       	adiw	r26, 0x06	; 6
    1cf4:	1c 92       	st	X, r1
    1cf6:	2f 5f       	subi	r18, 0xFF	; 255
    1cf8:	3f 4f       	sbci	r19, 0xFF	; 255
	
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
		if (0 != k && _keyReport.keys[i] == k) {
			_keyReport.keys[i] = 0x00;
    1cfa:	26 30       	cpi	r18, 0x06	; 6
    1cfc:	31 05       	cpc	r19, r1
    1cfe:	79 f7       	brne	.-34     	; 0x1cde <_ZN9Keyboard_7releaseEh+0x58>
		}
	}

	sendReport(&_keyReport);
	return 1;
}
    1d00:	bc 01       	movw	r22, r24
    1d02:	6c 5f       	subi	r22, 0xFC	; 252
    1d04:	7f 4f       	sbci	r23, 0xFF	; 255
    1d06:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <_ZN9Keyboard_10sendReportEP9KeyReport>

    1d0a:	81 e0       	ldi	r24, 0x01	; 1
    1d0c:	90 e0       	ldi	r25, 0x00	; 0
    1d0e:	08 95       	ret
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
		if (!k) {
			return 0;
		}
		if (k & 0x80) {							// it's a capital letter or other character reached with shift
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	90 e0       	ldi	r25, 0x00	; 0

	sendReport(&_keyReport);
	return 1;
}

void Keyboard_::releaseAll(void)
    1d14:	08 95       	ret

00001d16 <_ZN9Keyboard_10releaseAllEv>:
{
	_keyReport.keys[0] = 0;
	_keyReport.keys[1] = 0;	
    1d16:	fc 01       	movw	r30, r24
	_keyReport.keys[2] = 0;
    1d18:	16 82       	std	Z+6, r1	; 0x06
	_keyReport.keys[3] = 0;	
    1d1a:	17 82       	std	Z+7, r1	; 0x07
	_keyReport.keys[4] = 0;
    1d1c:	10 86       	std	Z+8, r1	; 0x08
	_keyReport.keys[5] = 0;	
    1d1e:	11 86       	std	Z+9, r1	; 0x09
	_keyReport.modifiers = 0;
    1d20:	12 86       	std	Z+10, r1	; 0x0a
	sendReport(&_keyReport);
    1d22:	13 86       	std	Z+11, r1	; 0x0b
}
    1d24:	14 82       	std	Z+4, r1	; 0x04

    1d26:	bc 01       	movw	r22, r24
    1d28:	6c 5f       	subi	r22, 0xFC	; 252
    1d2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d2c:	0c 94 d0 0d 	jmp	0x1ba0	; 0x1ba0 <_ZN9Keyboard_10sendReportEP9KeyReport>

00001d30 <_GLOBAL__sub_I_Mouse>:
//================================================================================
//	Mouse

Mouse_::Mouse_(void) : _buttons(0)
{
}
    1d30:	10 92 68 02 	sts	0x0268, r1
  public:
    Print() : write_error(0) {}
    1d34:	10 92 5f 02 	sts	0x025F, r1
    1d38:	10 92 5e 02 	sts	0x025E, r1
//================================================================================
//	Keyboard

Keyboard_::Keyboard_(void) 
{
}
    1d3c:	8b e4       	ldi	r24, 0x4B	; 75
    1d3e:	91 e0       	ldi	r25, 0x01	; 1
    1d40:	90 93 5d 02 	sts	0x025D, r25
    1d44:	80 93 5c 02 	sts	0x025C, r24
    1d48:	08 95       	ret

00001d4a <__tablejump2__>:
    1d4a:	ee 0f       	add	r30, r30
    1d4c:	ff 1f       	adc	r31, r31

00001d4e <__tablejump__>:
    1d4e:	05 90       	lpm	r0, Z+
    1d50:	f4 91       	lpm	r31, Z
    1d52:	e0 2d       	mov	r30, r0
    1d54:	09 94       	ijmp

00001d56 <__eerd_byte_m32u4>:
    1d56:	f9 99       	sbic	0x1f, 1	; 31
    1d58:	fe cf       	rjmp	.-4      	; 0x1d56 <__eerd_byte_m32u4>
    1d5a:	92 bd       	out	0x22, r25	; 34
    1d5c:	81 bd       	out	0x21, r24	; 33
    1d5e:	f8 9a       	sbi	0x1f, 0	; 31
    1d60:	99 27       	eor	r25, r25
    1d62:	80 b5       	in	r24, 0x20	; 32
    1d64:	08 95       	ret

00001d66 <__do_global_dtors>:
    1d66:	12 e0       	ldi	r17, 0x02	; 2
    1d68:	ca ee       	ldi	r28, 0xEA	; 234
    1d6a:	d2 e0       	ldi	r29, 0x02	; 2
    1d6c:	04 c0       	rjmp	.+8      	; 0x1d76 <__do_global_dtors+0x10>
    1d6e:	fe 01       	movw	r30, r28
    1d70:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <__tablejump__>
    1d74:	22 96       	adiw	r28, 0x02	; 2
    1d76:	cc 3e       	cpi	r28, 0xEC	; 236
    1d78:	d1 07       	cpc	r29, r17
    1d7a:	c9 f7       	brne	.-14     	; 0x1d6e <__do_global_dtors+0x8>
    1d7c:	f8 94       	cli

00001d7e <__stop_program>:
    1d7e:	ff cf       	rjmp	.-2      	; 0x1d7e <__stop_program>
